CAN总线知识：
can：每个can设备都可以是主设备，也可以是从设备。
CAN2.0A：只支持收发11位标识符（id）的标准帧
CAN2.0B:支持收发11位id的标准帧或者29位id的扩展帧
远程帧不发数据段
1.多主控制，多个主机可以开始发送消息，如果多个主机同时发起总线请求时，高优先级id的单元获得优先权；失利的单元则停止发送而进行接收工作
，并在总线再次空闲之前不再发报文
2.同一网络中所有单元的通信速度一致
3.所有unit有检错功能，检出错误会立即通知其他unit，正在发送消息的unit一旦检出错，会强制终止当前发送

5种帧：数据帧，远程帧，错误帧，过载帧，帧间隔
帧结构见图：

can通信案例：
https://blog.csdn.net/z609932088/article/details/84061467
https://blog.csdn.net/weixin_30576859/article/details/95213928?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.control


bms应用层需要实现的功能：
1.测量电压，温度，湿度
2.对relay的控制
3.充放电策略实现
4.针对不同测量量的故障检测处理
4.SOC/SOH的检测->针对不同电芯算法不同
5.热管理

驱动层实现的相对改动很小。

SOC的检测：电流积分--最简单的的办法
影响因素：温度，电芯一致性
SOC=SOC0+/- K*容量变化量
获得的不同的最大最小单体电压，消除一致性后获得整包电池的SOC
显示的SOC不能跳变，给用户感觉不好->需要仲裁，显示哪个值到界面

电芯用久了，内阻会变大
SOH--->估测内阻

SOP=（OCV-最小U）/内阻 *当前U
瞬时内阻计算：电压的变化量/电流的变化量

通信方式：
CAN：抗干扰  BMU-->lecu
				-->lecu
				-->lecu
菊花链：BMU-->LECU-->LECU--LECU
成本低，每个lecu不需要cpu，抗干扰弱

33771：采样芯片-->相比分立器件好处就是可以同一时刻采样多节电池电压，速度极快
认识继电器控制的高边驱动与低边驱动方式的特点--看图
AD1426  采集电压，14bit   cpu是12bit的
sh36730x  采集电流电压温度
ina219  采集电流

——————————————
其实无所谓请求帧数据帧：
我们发的帧都是ID+数据/cmd
可以自己规定收到哪个id的哪个数据后执行对应的操作，都是自己定的。
那些标准帧与扩展帧呢？
扩展帧29bit里面包含了仲裁机制，其实对于我们来说标准帧就够用了，只是车上发来的数据有扩展帧。

看门狗的喂狗最简单的方法就是在定时器中断中IWDG_ReloadCounter();reload计数值，让它无法计数到最大数值。
就不会触发看门狗。

一般看门狗的时钟源频率不会很高，分频下来--差不多x秒才会触发复位的。

短路的一瞬间会有100a通过板子，如果几百us内可以保护则板子不会坏。如果几秒内都不保护则板子会坏。
stm32内部有几个bkp reg，专门用来存运行过程中的一些掉电不消失的数据，写几个reg与flash一样不会掉电消失。

固件库里面有直接集成的对flash的op，LL库里面没有直接集成对flash的函数，得自己从hal库移植。
怎么用time直接写delay函数？
{
	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);    72m/(8+1)=8m time时钟源分频下来是8m
	fac_us = SystemCoreClock/8000000;// 8m/8m=1
}
void Delayms(u16 nms)//通过以下函数写个延时函数，不需要中断的。
{
    u32 temp;
    SysTick->LOAD = (u32)nms*fac_ms;     reload值         
    SysTick->VAL = 0x00;                  当前计数值     
    SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk ;  控制和状态reg，使能systick，开跑
    do
    {
        temp=SysTick->CTRL;
    }while((temp&0x01)&&!(temp&(1<<16)));   当CTRL第1bit为0 || 16bit为1，跑完load值之后ctrl会置位
    SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;  失能systick
    SysTick->VAL = 0x00;                        
}
NVIC_InitStructure.NVIC_IRQChannel=USB_LP_CAN1_RX0_IRQn;//则中断处理函数就是USB_LP_CAN1_RX0_IRQHandler()
NVIC_IRQChannel就对应中断

vscode添加头文件：
Ctrl+Shift+P 打开命令 输入configuration 点第一个才有 c_cpp_properties.json