用户层mmap：
void *mmap(void *addr, size_t length, int prot, int flags,
            int fd, off_t offset);
内存映射函数，将文件内容映射到进程的虚拟内存空间，通过对映射后的内存
的读写修改，实现对文件的读取修改。不需要使用read write函数 也可以操作文件

offset 从文件的哪个位置开始映射，length 映射多少字节

内核层:对应设备在内核层需要为它建立虚拟地址到物理地址的页表
int(*mmap)(struct file*,struct vm_area_struct*) file_operations成员

建立页表方法：
使用 remap_pfn_range 一次构建所有页表
使用 nopage VMA 方法每次建立一个页表


x86处理器有 IO地址空间 只有64K ，
其他cpu都没有IO地址空间

访问io端口：
inb outb   8位
inw outw   16位
inl outl   32位
释放io端口：
release_region(start,n)   

访问io内存之前，要进行物理到虚拟地址映射，ioremap
取消映射：iounmap
release_mem_region(start,len)


裸机开发：
	直接操作寄存器
linux驱动开发：
	不直接操作寄存器
	根据linux下的驱动框架 进行开发
	驱动的最终表现就是/dev/xxx 文件
	新的内核支持设备树，此文件描述了板子上的外设信息
	
驱动分类：
	字符设备驱动：gpio i2c spi usb 按字节顺序操作的设备
	块设备：存储相关的，以固定大小长度（扇区），不需要按照顺序
	网络设备
	一个设备不一定只属于某一个类型：usb wifi，sdio wifi，属于网络设备，usb sdio 也属于字符设备

内核空间：
对 cpu 的所有访问都是没有限制的，所以需要高级程序员去写驱动，
驱动写好后，低级程序员可以在用户空间去操作外设，写错了不会崩溃。
要是在内核空间写错了会导致 操作系统 崩溃

访问内核资源：系统调用，陷入（软中断），中断

ubuntu 的鼠标 中键  复制粘贴 功能很恶心怎么禁用?上网查一下即可
