用户层mmap：
void *mmap(void *addr, size_t length, int prot, int flags,
            int fd, off_t offset);
内存映射函数，将文件内容映射到进程的虚拟内存空间，通过对映射后的内存
的读写修改，实现对文件的读取修改。不需要使用read write函数 也可以操作文件

offset 从文件的哪个位置开始映射，length 映射多少字节

内核层:对应设备在内核层需要为它建立虚拟地址到物理地址的页表
int(*mmap)(struct file*,struct vm_area_struct*) file_operations成员

建立页表方法：
使用 remap_pfn_range 一次构建所有页表
使用 nopage VMA 方法每次建立一个页表


x86处理器有 IO地址空间 只有64K ，
其他cpu都没有IO地址空间

访问io端口：
inb outb   8位
inw outw   16位
inl outl   32位
释放io端口：
release_region(start,n)   

访问io内存之前，要进行物理到虚拟地址映射，ioremap
取消映射：iounmap
release_mem_region(start,len)


裸机开发：
	直接操作寄存器
linux驱动开发：
	不直接操作寄存器
	根据linux下的驱动框架 进行开发
	驱动的最终表现就是/dev/xxx 文件
	新的内核支持设备树，此文件描述了板子上的外设信息
	
驱动分类：
	字符设备驱动：gpio i2c spi usb 按字节顺序操作的设备
	块设备：存储相关的，以固定大小长度（扇区），不需要按照顺序
	网络设备
	一个设备不一定只属于某一个类型：usb wifi，sdio wifi，属于网络设备，usb sdio 也属于字符设备

内核空间：
对 cpu 的所有访问都是没有限制的，所以需要高级程序员去写驱动，
驱动写好后，低级程序员可以在用户空间去操作外设，写错了不会崩溃。
要是在内核空间写错了会导致 操作系统 崩溃

访问内核资源：系统调用，陷入（软中断），中断

ubuntu 的鼠标 中键  复制粘贴 功能很恶心怎么禁用?上网查一下即可

函数的入口一定要做 判空 处理，否则后面执行 可能访问空指针，可能给野指针赋值 -- 好习惯要养成


uboot是通过 if of 命令，将sd卡或emmc 插入到ubuntu 然后放进去的。
拨动拨码开关选择 系统从哪里启动（sd卡 emmc u盘），然后在uboot中配置环境变量bootargs  bootcmd 去启动系统
编译uboot：./mx6ull_emmc.sh  编译uboot  获得 uboot.bin
通过 ./mxdownload uboot.bin /dev/sdf 将boot 放到emmc中
setenv bootcmd 'tftp 80800000 zImage;tftp 83000000 zxx.dtb;bootz 80800000 - 83000000'
setenv bootargs 'console=ttymxc0,115200 rw nfsroot=ip:/home/rootfs ip=本机ip:服务器ip:255.255.255.0::eth0:off'
saveenv  保存设置
boot 命令会执行bootcmd配置的命令

modprobe xx.ko  ，此命令会默认去:/lib/modules/<内核版本>/ 中查找此模块，并安装
所以我们需要把自己编译好的ko文件放到此目录中
直接执行 modprobe 若报错，可以知道 寻找模块的目录，创建此目录即可

第一次加载新的模块的时候会报缺少 dep
需要执行depmod 去生成相关依赖  
modprobe -r  xxx.ko   卸载某个模块

一般在入口函数中注册设备： 以下并不会创建出文件  测试的时候还是要 mknode /dev/haha0 c 250 0  c:字符设备
register_chrdev(major,devicename,&operations)  注册字符设备--与次设备号没关系-注册的是一类--这个函数现在不常用了
也会 申请设备号，也会向内核注册 操作函数--功能多 但是不好
unregister_chrdev(major,devicename);  注销

裸机led实验就是直接操作：6ULL 的寄存器
驱动的地址映射：可以操作寄存器，但是不能直接操作，需要将物理地址映射，映射后才能操作映射后的虚拟地址-因为linux有 mmu

stm32没有mmu-所以不能跑linux
现在新版本的linux已经支持无 mmu了，但是一般没有用没mmu的cpu 跑Linux

虚拟地址是0-4G  开发板上的内存只有512M，怎么映射呢
获取物理地址对应的虚拟地址的函数： 
virtaddr=ioremap(phyaddr,len)
iounmap(virtaddr) 取消映射，卸载模块的时候取消

可以直接拷贝别的目录的.vscode 到当前目录，则C_CPP_.json中包含的 include path 就可以直接引用过来，方便看内核代码时 直接跳转

led.c
#incldue<linux/module.h>
#incldue<linux/kernel.h>
#incldue<linux/init.h>
#incldue<linux/fs.h>
#incldue<linux/io.h>

#define LED_MAJOR 200
#define LED_NAME  "led"

//led的寄存器物理地址
#define CCM_CCGR1_BASE  	(0x2222131)
#define SW_MUX_GPIO1_BASE  (0x2222131)
#define SW_PA0_GPIO1_BASE  (0x2222131)
#define GPIO1_DR_BASE  		(0x2222131)
#define GPIO1_GDIR_BASE  	(0x2222131)
//地址映射后的虚拟地址　指针
static void __iomem *vCCM_CCGR1;
static void __iomem *vSW_MUX_GPIO1;
static void __iomem *vSW_PA0_GPIO1;
static void __iomem *vGPIO1_DR;
static void __iomem *vGPIO1_GDIR;

led_write(file,buf,count,offset)
{
	int ret;
	char databuf[1];//要传地址直接声明为1个数据的数组 可以直接传
	ret=copy_from_user(databuf,buf,count);
	if(ret<0)
	{
		printk("write err\n");
		return -1;
	}
	if(databuf[0]==LEDON){
		val=readl(vGPIO1_DR);
		val &= ~(1<<3); //第三位 置0 开灯
		writel(val,vGPIO1_DR);
	}else{
		val=readl(vGPIO1_DR);
		val|=(1<<3); //开灯  置1 关灯
		writel(val,vGPIO1_DR);
	}
	return 0;
}
led_open()
{
	nothing
}
led_close()
{
	nothing
}
//哪些函数需要实现 根据应用程序 需要实现的功能 去实现需要的函数
static struct file_operations led_fops={
	.owner=THIS_MODULE,
	.write = led_write,
	.open = led_open,
	.release=led_close,
};

//加载模块的时候灯亮  卸载的时候灯灭
static int __init led_init() //__init 只是个修饰符
{
	int ret=0;
	int val=0;
	//有的人把 led的初始化放到 init 入口，有的人放到open的时候初始化，看实际情况
	//初始化led 的配置  映射过来的都是4字节长度的寄存器
	vCCM_CCGR1=ioremap(CCM_CCGR1_BASE,4);  
	vSW_MUX_GPIO1=ioremap(SW_MUX_GPIO1_BASE,4);
	vSW_PA0_GPIO1=ioremap(SW_PA0_GPIO1_BASE,4);
	vGPIO1_DR=ioremap(GPIO1_DR_BASE,4);
	vGPIO1_GDIR=ioremap(GPIO1_GDIR_BASE,4);
	
	//gpio 初始化 操作，就是裸机操作
	//时钟 初始化 不建议的操作就是直接（*vCCM_CCGR1）去操作，但是好像并没有错
	val=readl(vCCM_CCGR1);
	val&=~(3<<26);//清除bit26-27  只操作对应的bit 不要更改其他bit
	val|=3<<26; //在将bit26 27置1
	writel(val,vCCM_CCGR1);
	
	//设置复用 别的位没啥影响 直接设
	writel(0x6,vSW_MUX_GPIO1);
	//设置电气属性 别的位没啥影响 直接设
	writel(0x6,vSW_PA0_GPIO1);
	
	//设置为输出模式
	val=readl(vGPIO1_GDIR);
	val&=~(3<<26);//清除bit26-27  只操作对应的bit 不要更改其他bit
	val|=3<<26; //在将bit26 27置1
	writel(val,vGPIO1_GDIR);

	//初始化为输出 高电平
	val=readl(vGPIO1_DR);
	val|=(1<<3); //开灯
	writel(val,vGPIO1_DR);
	
	ret=register_chrdev(LED_MAJOR,LED_NAME,&led_fops)
	if(ret<0)
	{printk("注册失败\n");return -1;}
	
	printk("in led_init\n");
	return 0;
}

static void __exit led_exit()
{
	iounmap(vCCM_CCGR1);
	iounmap(vSW_MUX_GPIO1);
	iounmap(vSW_PA0_GPIO1);
	iounmap(vGPIO1_DR);
	iounmap(vGPIO1_GDIR);
	
	printk("in led_exit\n");
}

module_init(led_init);
module_exit(led_exit);
MODULE_LICENSE("GPL");  //必须支持GPL协议
------------------
makefile:
KERNELDIR:=/linux-imx-4.3.x   存的内核的makefile
CURRPATH:=$(shell pwd)
obj-m:=led.o  xxx.o xxx必须与.c 文件的文件名一致 否则报错
build:kernel_modules 

kernel_modules:
	$(MAKE) -C $(KERNELDIR) M=$(CURRPATH) modules
clean:
	$(MAKE) -C $(KERNELDIR) M=$(CURRPATH) clean
---------------------

u-boot tftp 下载失败，查看ubuntu 网络是否正常，是否主机或单板 ip 重复了
关闭单板与ubuntu，在windows ping 两个ip 看是否有ip 重复 
改重复的ip的 主机的ip/找到重复ip的设备，更改他的ip
重启tftp服务


内核中提供了专门的读写操作函数：最好不要直接去写虚拟内存
u8  readb(vaddr)
u16 readw(vaddr)
u32 readl(vaddr)
写操作函数：
void writeb(u8 val,vaddr)
void writew(u16 val,vaddr)
void writel(u32 val,vaddr)

-----------------------------------------
优化上面的程序，
register_chrdev(LED_MAJOR,LED_NAME,&led_fops) 根据主设备号创建驱动，浪费次设备号--但是很简洁 一行顶多行代码
1.	
	好一点的创建驱动方法，动态向内核申请：
	alloc_chrdev_region(&devno, mi,count,"hello")
	unregister_chrdev_region(devno,count); 释放申请的设备号 申请几个就释放几个
2.	
	int register_chrdev_region(dev_t from,count,name);
	指定主设备号，使用 MKDEV 构建完整的设备号，一般次设备号用0开始++
	卸载 unregister_chrdev_region 与上面一样的
3. 两个申请设备号的方法优化方法：
	if(major>0){//给定主设备号
		register_chrdev_region(MKDEV(major,0),count,name);
	}else{//啥都没给 自己申请
		alloc_chrdev_region(&devno, minor,count,"hello")
	}

newchrled.c
struct newchrled_dev{
	dev_t devid;	设备号
	int major;		主设备号
	int minor;		次设备号
	struct cdev cdev;//变量名就是类型名  c里面是可以的
};

struct newchrled_dev newchrled; 定义描述设备号的结构体变量

if(newchrled.major>0){//给定主设备号
	newchrled.devid=MKDEV(newchrled.major,0);
	ret=register_chrdev_region(newchrled.devid,count,name);
}else{//没给主设备号 自己申请  minorbase次设备号基地址，一般从0开始写
	alloc_chrdev_region(&newchrled.devid, minorbase,count,"hello")
	newchrled.major = MAJOR(newchrled.devid);
	newchrled.minor = MINOR	(newchrled.devid);
}
struct cdev{ //字符设备结构体  将设备号与操作 联系起来
	设备号，
	.owner,
	操作集,
	count,
}
newchrled.cdev.owner=THIS_MODULE;
cdev_init(&newchrled.cdev,operations);
cdev_add(&newchrled.cdev,newchrled.devid,count);  count 添加几个


dev_del(&newchrled.cdev);  注销的时候用
--------------------------------------------
以前的内核没有代码创建设备节点的功能，2.6以后的内核引入了udev 机制，提供热插拔管理，加载驱动时创建，卸载驱动时删除

用代码创建设备节点： 
//创建类 
newchrled.ledclass=class_create(THIS_MODULE,"led");
if(IS_ERR(newchrled.ledclass))  
	return PTR_ERR(newchrled.ledclass);
//根据类 创建设备
newchrled.leddev=device_create(newchrled.ledclass,NULL,newchrled.devid,NULL,"led");
if(IS_ERR(newchrled.ledclass))  
	return PTR_ERR(newchrled.leddev);
	

出口函数：
device_destroy(newchrled.leddev,newchrled.devid)  销毁设备
class_destroy(newchrled.ledclass);  销毁类

----------------------------文件私有数据  很好用  建议多使用
struct file{
	xxx;
	yyy;
	void *private_data;  //file 结构体中有个重要成员 很好用
};

一般在open的时候设置
int newchrled_open(struct inod*inode,struct file*filp)
{
	filp->private_data=&newchrled;//将程序中 用的最多的 newchrled 赋值给私有数据，然后直接通过 struct file*filp 就可以访问当前驱动的所有属性
	return 0;
}
//在read write close 函数中，可以直接读取私有数据
newchrled_read(struct file*filp)
{
	struct newchrled_dev *dev=filp->private_data;
	操作 dev即可；
}
int newchrled_release(struct inod*inode,struct file*filp)
{
	struct newchrled_dev *dev=(struct newchrled_dev*)filp->private_data;
	return 0;
}

------------------------------设备树
单片机驱动中SPI，速度都是在.c 里面写死的，板级信息都写到 .c中，导致linux 内核描述板子信息的.c 太多。所以引入.dts文件

imx：nxp 恩智浦
hisi：海思 

dts 相当于 .c文件
DTC 工具相当于 gcc 将dts文件编译成 dtb文件（相当于bin文件）

在内核根目录：make dtbs  编译所有的dts 文件 ，在arch/arm/boot/dts/目录找自己需要的编译好的dtb文件
在内核根目录：make xxx.dtb  编译指定dts 文件，编译成对应的dtb文件，只编译这一个dts 文件
arch/arm/boot/dts/makefile 中制定了编译的时候会编译哪些dts 文件 
要编译自己写的dts文件，将自己的dts 放到 makefile中

dtsi 是 头文件

dts文件：
/dts-v1/;
#include "x.dtsi";
#include *.h;
当前root中的修改 ，如果 x.dtsi文件已经存在 则就是用当前的属性覆盖dtsi中的属性
/{ 	//根节点之内描述设备信息
	model="this is freescal board11.1"; 属性
	compatible=""; 属性
	chosen{ //一级子节点
	};
	memory{
		reg=<0x8000000 0x2000000>;起始地址+长度512M
	}; 
	spi4{
	};
	soc{
		apb1:apb1@addr{}
		apb2:apb1@addr{
			i2c1@addr{  i2c上挂了两个设备 
				dev1@03{
				};
				dev2@13{
				};
			};
		};
		apb3:apb1@addr{}
	};
	led{  我们一般加到一级子节点 比较容易找
		编译运行后在/proc/device-tree 可以看到新加的节点
	};
	alphaled{
		#address-cell =<1>;
		#size-cell=<1>;
		status="okay";
		reg=<0x20c405 0x04  /*led 的各种寄存器，长度*/
			0x20c405 0x04	/**/
			0x20c405 0x04	/**/
			0x20c405 0x04	/**/
			0x20c405 0x04>;
	};
	intc:interrupt-controller@00100100{
		冒号前 intc 是标签。
		完整节点名字为：interrupt-controller@00100100
	};
};

//根节点之外 还可以放东西  是追加
&label{  在根节点之外 &+label 可以追加 属性
};
&intc{
};

设备树在系统中的体现：
内核启动后，可以在根文件系统看到设备的节点信息 在 /proc/device-tree 存放设备树信息  
属性对应单个文件，节点对应一个目录，目录里面好多文件对应节点的属性
软链接：/sys/firmware/devicetree/base/

特殊节点：
chose：主要目的是将 uboot 中bootargs 环境变量值，传递给内核 作为命令行参数，可以在/proc/device-tree中看到chose的属性就与boot中一样
多会设置的呢？在uboot中




