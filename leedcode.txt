 
层次遍历树：c++
vector<int> levelOrder(TreeNode* root) {
	queue<TreeNode*> queue;
	vector<int> res;
	if(root==NULL)return res;//若传入NULL，直接返回空vector
	queue.push(root);
	while(!queue.empty()){
		TreeNode *node=queue.front();//临时变量储存当前需要处理的节点
		queue.pop();				//出队列 的同时，将当前出队列的元素的左右孩子都入队列
		res.push_back(node->val);	//结果保存在vector
		if(node->left){
			queue.push(node->left);
		}
		if(node->right){
			queue.push(node->right);
		}
	}
	return res;
}

python实现：
def levelOrder( root: TreeNode) -> List[int]:     
	if not root: return []
	res = []
	queue = []
	queue.append(root)
	while queue:
		node = queue.pop(0)    python中的list无法从头部删除元素，错误。python中的pop可以控制从左边删除还是右边删除。pop(0)就是从左边删除
		res.append(node.val)
		if node.left: queue.append(node.left)
		if node.right: queue.append(node.right)
	return res
	'''以下才是可以成功的代码，用到了collections.deque()。
	if not root: return []
	res, queue = [], collections.deque()
	queue.append(root)
	while queue:
		node = queue.popleft()
		res.append(node.val)
		if node.left: queue.append(node.left)
		if node.right: queue.append(node.right)
	return res
	'''
层次遍历树，格式不同2：
def levelOrder(self, root: TreeNode) -> List[List[int]]:
	if not root: return []
	res = []
	queue = []
	queue.append(root)
	while queue:         在每一次的循环中将queue当前树某1层中所有的数据全部弹出
		tmp = []
		for _ in range(len(queue)):在每一次的循环中将queue当前树某1层中所有的数据全部弹出  
			node = queue.pop(0)   
			tmp.append(node.val)
			if node.left: queue.append(node.left)
			if node.right: queue.append(node.right)
		res.append(tmp)
	return res
	
寻找相交链表的第一个焦点的位置：
太他妈巧妙了，两个指针一个a,一个b。过程就是a将heada遍历一边然后遍历headb，b将headb遍历一边遍历heada。若有焦点就会退出循环，若没有焦点
最终a,b都会指向null。因为a与b走的路程是一样的。每次循环2者都在移动。
def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:  太他妈巧妙了
	a = headA
	b = headB
	while(a != b):
		a = a.next if a else headB
		b = b.next if b else headA
	return a
自制的升序排序好的栈：
#include <stack>
class SortedStack {
public:利用一个辅助栈
    stack<int> stack1;
    stack<int> stack2;
    
    void push(int val) {    
            while(!stack1.empty() && val > stack1.top()){  若栈1不是空的，看新加的val是不是最大值，不是最大值，先将栈1的大于val的数字
                stack2.push(stack1.top());					放到栈2，再放val到栈1.  val放进栈1后再将栈2里面的数据放回栈1. 栈2就是临时用一下
                stack1.pop();								用完就成空的了。
            }
            stack1.push(val);
            while(!stack2.empty()){
                stack1.push(stack2.top());
                stack2.pop();
        }
    }
删除未排序链表中的重复节点，保留前一个节点组成新链表,在原来的链表上改变指针指向。
ListNode* removeDuplicateNodes(ListNode* head) {
        if(head == NULL) return head;
        set<int> set;
        ListNode*tail = head;
        set.insert(head->val);
        ListNode*tmp = head->next;
        while(tmp){
            if(set.find(tmp->val) == set.end()){如果遍历到的tmp点不在set中，则这点是需要的。
                set.insert(tmp->val);
                tail->next = tmp;
                tail = tmp;
                tmp = tmp->next;  先让tmp指向下个节点
                tail->next = NULL;	再将准备返回的节点尾部指向空，不然会丢失原链表的后续节点
            }else{
				tmp = tmp->next;  若当前tmp已经在set中，则继续向后遍历
			}
        }
        return head;
    }
深度优先搜索：dfs
解题模板
这类题通常用深度优先搜索(DFS)和广度优先搜索(BFS)解决，BFS较DFS繁琐
一、自顶而下：dfs
一般路径：
vector<vector<int>>res;
void dfs(TreeNode*root,vector<int> & path)  path最终返回的数据就是本函数执行深度优先查找的过程。
{
    if(!root) return;  //根节点为空直接返回
    path.push_back(root->val);  //作出选择
    if(!root->left && !root->right) //如果到叶节点  
    {
        res.push_back(path);
        return;
    }
    dfs(root->left,path);  //继续递归
    dfs(root->right,path);
}

# **给定和的路径：**
void dfs(TreeNode*root, int sum, vector<int> path)
{
    if (!root)
        return;
    sum -= root->val;
    path.push_back(root->val);
    if (!root->left && !root->right && sum == 0)
    {
        res.push_back(path);
        return;
    }
    dfs(root->left, sum, path);
    dfs(root->right, sum, path);
}

二、非自顶而下：
这类题目一般解题思路如下：
设计一个辅助函数maxpath，调用自身求出以一个节点为根节点的左侧最长路径left和右侧最长路径right，那么经过该节点的最长路径就是left+right
接着只需要从根节点开始dfs,不断比较更新全局变量即可


int res=0;
int maxPath(TreeNode *root) //以root为路径起始点的最长路径
{
    if (!root)
        return 0;
    int left=maxPath(root->left);
    int right=maxPath(root->right);
    res = max(res, left + right + root->val); //更新全局变量  
    return max(left, right);   //返回左右路径较长者
}
这类题型DFS注意点：
1、left,right代表的含义要根据题目所求设置，比如最长路径、最大路径和等等

2、全局变量res的初值设置是0还是INT_MIN要看题目节点是否存在负值,如果存在就用INT_MIN，否则就是0

3、注意两点之间路径为1，因此一个点是不能构成路径的

题目分析
下面是对具体题目的分析和代码呈现
一、自顶向下
257. 二叉树的所有路径
直接套用模板1即可，注意把"->"放在递归调用中  res保存所有的dfs的路径
void dfs(TreeNode*root, string path)
{
    if (!root)
        return;
    path += to_string(root->val);
    if (!root->left && !root->right)
    {
        res.push_back(path);
        return;
    }
    dfs(root->left, path+"->");
    dfs(root->right, path+"->");
}
113. 路径总和 II
直接套用模板2

vector<vector<int>> res;
vector<vector<int>> pathSum(TreeNode *root, int targetSum)
{
    vector<int> path;
    dfs(root, targetSum, path);
    return res;
}

void dfs(TreeNode*root, int sum, vector<int> path)
{
    if (!root)
        return;
    sum -= root->val;
    path.push_back(root->val);
    if (!root->left && !root->right && sum == 0)
    {
        res.push_back(path);
        return;
    }
    dfs(root->left, sum, path);
    dfs(root->right, sum, path);
}
437. 路径总和 III
双重递归：先调用dfs函数从root开始查找路径，再调用pathsum函数到root左右子树开始查找
套用模板2


int count = 0;
int pathSum(TreeNode *root, int targetSum)
{
    if (!root)
        return 0;
    dfs1(root, targetSum);            //以root为起始点查找路径
    pathSum(root->left, targetSum);  //左子树递归
    pathSum(root->right, targetSum); //右子树递归
    return count;
}

void dfs(TreeNode *root, int sum)
{
    if (!root)
        return;
    sum -= root->val;
    if (sum == 0) //注意不要return,因为不要求到叶节点结束,所以一条路径下面还可能有另一条
        count++;  //如果找到了一个路径全局变量就+1
    dfs1(root->left, sum);
    dfs1(root->right, sum);
}
988. 从叶结点开始的最小字符串
换汤不换药，套用模板1


vector<string> path;
string smallestFromLeaf(TreeNode *root)
{
    dfs(root, "");
    sort(path.begin(), path.end()); //升序排序
    return path[0];
}

void dfs(TreeNode *root, string s)
{
    if (!root)
        return;
    s += 'a' + root->val;
    if (!root->left && !root->right)
    {
        reverse(s.begin(), s.end()); //题目要求从根节点到叶节点，因此反转
        path.push_back(s);
        return;
    }
    dfs(root->left, s);
    dfs(root->right, s);
}
二、非自顶向下
124. 二叉树中的最大路径和
/left,right分别为根节点左右子树最大路径和,注意：如果最大路径和<0,意味着该路径和对总路径和做负贡献，因此不要计入到总路径中，将它设置为0


int res = INT_MIN; //注意节点值可能为负数，因此要设置为最小值
int maxPathSum(TreeNode *root)
{
    maxPath(root);
    return res;
}

int maxPath(TreeNode *root) //以root为路径起始点的最长路径
{
    if (!root)
        return 0;
    int left = max(maxPath(root->left), 0);
    int right = max(maxPath(root->right), 0);
    res = max(res, left + right + root->val);  //比较当前最大路径和与左右子树最长路径加上根节点值的较大值，更新全局变量
    return max(left + root->val, right + root->val); //返回左右子树较长的路径加上根节点值
}
687. 最长同值路径


int longestUnivaluePath(TreeNode *root)
{
    if (!root)
        return 0;
    longestPath(root);
    return res;
}

int longestPath(TreeNode *root)
{
    if (!root)
        return 0;
    int left = longestPath(root->left), right = longestPath(root->right);
    // 如果存在左子节点和根节点同值，更新左最长路径;否则左最长路径为0
    if (root->left && root->val == root->left->val)
        left++;
    else
        left = 0;
    if (root->right && root->val == root->right->val)
        right++;
    else
        right = 0;
    res = max(res, left + right);
    return max(left, right);
}
543. 二叉树的直径


int res1 = 0;  
int diameterOfBinaryTree(TreeNode *root)
{
    maxPath(root);
    return res1;
}

int maxPath(TreeNode *root)
{
// 这里递归结束条件要特别注意：不能是!root(而且不需要判断root为空,因为只有非空才会进入递归)，因为单个节点路径长也是0
    if (!root->left && !root->right)  
        return 0;
    int left = root->left ? maxPath(root->left) + 1 : 0;  //判断左子节点是否为空，从而更新左边最长路径
    int right = root->right ? maxPath(root->right) + 1 : 0;
    res1 = max(res, left + right); //更新全局变量
    return max(left, right);  //返回左右路径较大者
}


生成对应数量的左右括号：python解法
def generateParenthesis(self, n: int) -> List[str]:
	res=[]
	def dfs(  left,  right,  curStr):
		if (left == 0 and  right == 0):  #左右括号都不剩余了，说明找到了有效的括号
			res.append(curStr)
			return

		if (left < 0): #左括号只有剩余的时候才可以选，如果左括号的数量已经选完了，是不能再选左括号了。
			return
		if (right < left):  #说明右括号选的比左括号多了，这个函数中选哪个括号则哪个括号的入参就会减小1
			return
		#选择左括号
		dfs( left - 1, right, curStr + "(")
		#选择右括号
		dfs( left, right - 1, curStr + ")")
	dfs(n,n,"")  #内部定义的dfs函数在generateParenthesis函数中得调用一次 在dfs中可以访问外部函数定义的变量，这个方法可以修改原函数入参。
					# fun([],"")空列表，空字符串也可以直接当作入参当作临时变量去调用
	return res
	
class Solution { c++写法
public:
    vector<string> res;
    void dfs(int left,int right,string curStr){
        if (left == 0 &&  right == 0){
            res.push_back(curStr);
			return;
        }
		if (left < 0)return;
		if (right < left)return;
		dfs( left - 1, right, curStr + "(");
		dfs( left, right - 1, curStr + ")");
    }
    vector<string> generateParenthesis(int n) {
        dfs(n,n,"");
        return res;
    }
};

判断括号字符串是否有效：
bool ismatch(char left,char right){  判断是否匹配函数
    switch(right){
        case ')':
            return left=='(';
        case ']':
            return left=='[';
        case '}':
            return left=='{';
        default:
            return false;
    }
}

bool isvalid(string s){
    if(s.length()==0)return true;
    stack<char> stack;
    for(auto ch :s){   遍历传入的string
        if(ch==')' || ch==']'||ch=='}'){   如果当前char是右括号
            if(stack.empty() || !ismatch(stack.top(),ch) ){  判断栈定是否有匹配的左括号
                return false;
            }else{
                stack.pop();
            }
        }else{					如果当前char是左括号直接入栈
            stack.push(ch);
        }
    }
    return stack.empty();
}