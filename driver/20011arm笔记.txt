         
嵌入式系统软件：应用+底层    

嵌入式开发工程师：     嵌入式应用工程师---》
                                     嵌入式驱动工程师---》

嵌入式底层课程：arm 系统移植 驱动 python 人工智能 stm32 nbiot
为什么要学习底层课程？
       1 解释应用层
        2 为我们的职业发展更长远
为什么要学习arm？
      1   学习一款硬件平台，主流嵌入式设备处理器
      2 为后面的底层课程做铺垫
       3 找工作
arm课程学习什么？汇编语言（arm指令集）+裸机编程
arm课程的安排：
     arm介绍 环境搭建 汇编指令
     汇编指令
     汇编指令 软中断
     c和汇编的混合编程 裸机开发 led驱动
     串口驱动 看门狗 pwm
     硬件中断


day1:
1 arm介绍 
    硬件+软件
1.1嵌入式系统：嵌入式硬件+嵌入式软件
        嵌入式软件：app/os+app
        嵌入式硬件:输入+输出+存储器+控制器+运算器（ALU）+总线
 控制器：整个嵌入式系统的指挥中心
 运算器（ALU）：信息进行处理和运算的部件
   cpu=控制器+运算器+寄存器组（通用）
   SOC=cpu+外围组件
存储器：用来存放程序和数据的部件，是设备的记忆装置。
          辅助存储器（外存）：用来永久的存放数据和程序，CPU不能直接访问
                             硬盘 U盘 光盘 软盘 
          内存：是主存储器，用来存放正在执行的程序
          高速缓存器（cache）:用来存放正在执行程序的活跃部分，CPU可以直接访问
          寄存器（组）：是封装在CPU内部的一个组件，用来存放ALU的运算数据和结果值
  
总线（bus）：连接嵌入式硬件的各个模块；传送数据
  flash:  
   nor flash:存贮数据+运行程序
   nand flash:存贮数据
1.2arm体系结构的介绍
    1.2.1 arm是什么？
          第一，arm是一个公司的名字，ARM公司，该公司的主要业务是设计处理器的内核。
        处理器的内核=处理器的架构=处理器的控制时序电路+arm指令集/Thumb指令集（汇编语言）
        第二，arm代表一款处理器的架构，arm不是芯片，arm公司向芯片厂商提供ARM内核，
        芯片厂商用arm内核加上外围组件设计出了处理器芯片
   1.2.2编程模型  mov r0,#5--->010101.....(32位)
    ARM是32位架构：32位指的是CPU一次处理数据指令的能力是32位（32bit）
   cpu的工作就是周期性的去处理指令（取指 译码 执行）
    周期性：看CPU主频，3.2Ghz,该CPU在1s中内取3.2G条指令来处理。周期1/3.2Ghz
    取指：去存储器中取，每次取了32bit(刚好是一条ARM指令)
   ARM 约定:
            Byte ：	8 bits
           Halfword ：   16 bits (2 byte)
           Word :	32 bits (4 byte)
   ARM core 提供：
                   ARM 指令集（32-bit）---》默认 
                  Thumb 指令集（16-bit ）
   ARM 内核有两种工作状态：arm态------》使用ARM 指令集
                                                Thumb态----》使用Thumb 指令集
    当arm内核处于arm态，该内核有8种工作模式：
                          User : 非特权模式，大部分任务执行在这种模式
                          FIQ :   当一个高优先级（fast) 中断产生时将会进入这种模式
	        IRQ :   当一个低优先级（normal) 中断产生时将会进入这种模式
	       Supervisor :当复位或软中断指令执行时将会进入这种模式
                        Abort : 当存取异常时将会进入这种模式
   	      Undef : 当执行未定义指令时会进入这种模式
	      System : 使用和User模式相同寄存器集的特权模式
                    Cortex-A特有模式：
	     Monitor : 是为了安全而扩展出的用于执行安全监控代码的模式；
                                  也是一种特权模式
   1.2.3寄存器：用于在指令执行过程中存放运算数据和结果值
          arm内核的寄存器的容量是多大？ 
             普通的ARM有37个寄存器，每个寄存器的容量4byte
             contex-A的arm内核有40个寄存器，每个寄存器的容量4byte
                  r13（sp）:存放sp栈指针
                  r14(lr):在执行中断或函数调用时保存当前执行指令的下一条指令地址
	r15（pc）:pc程序的取址位置
	cpsr:当前程序状态寄存器，保存的是当前处理器的状态信息
	spsr:是cpsr的备份寄存器，通常在中断时被使用
   1.2.4cpsr/spsr:当前程序状态寄存器
            32bits:
            31bit(N):N=1,表示运算结果为负
                            N=0,表示运算结果为正数或0
            30bit(Z):Z=1,表示运算结果为0
                           Z=0，表示运算结果为非0
            29bit(C):进借位标志位。加法有进位，C=1;加法无进位，C=0；
                            减法有借位，C=0;无借位，C=1
            28bit(V):v=1,ALU运算溢出
            0-4bit：arm内核的工作模式位（mode）
                 10000  User mode;   
	 10001 FIQ mode;          
	 10011 SVC mode;       
	10111  Abort mode;  
	11011 Undfined mode;  
	11111 System mode;        
	 10110  Monitor mode;   
	10010 IRQ
   1.2.5 字节序
    1.2.6 指令流水线   
              arm内核处理指令可以分成多个阶段，多个阶段可以并行执行 
              处理一条指令分三个阶段（取指 译码 执行）
              
             1 mov r0,#5-->32
             2 mov r1,#6
             3 mov r2,#7
2模拟环境搭建        

3 指令集
   赋值指令：mov：  可以把一个小于等于8bit的数装载到通用寄存器
                    ldr伪指令：可以把任何一个32bit的数装载到通用寄存器
     
day1作业:
1 安装ARM模拟环境
2 用汇编实现一个程序，耗时1S

  
day2:
 1 arm指令
    1  cmp:比较指令，会自动影响CPSR的标志位
    2 指令机器码：每一条ARM指令都对应唯一的一条指令机器码（32位）
                         mov r1,#0xc--->E3A0100C
    3 数据处理指令
   算术指令：ADD 	ADC 	SUB 	SBC 	RSB 	RSC
  逻辑指令：AND	 ORR 	EOR 	BIC 
  比较指令：CMP	 CMN 	TST 	TEQ
  数据搬移：MOV	 MVN
  4  合法立即数
      立即数：汇编指令中操作数是一个小于等于32bits位的数即为立即数
     合法立即数：该立即数中最多只有8个bit位是有效位，其他位为0的立即数
    mov指令可以把合法的立即数装载到通用寄存器中去
     如何判断一个立即数是合法立即数？
               1  看该立即数至少有连续24个0，若有该数就是一个合法的立即数
               2 循环右移偶数位
  5 mov mvn ldr-->伪指令
    ldr r0,=<const>  ---->ldr伪指令
     1  mov---->ldr r1,=0xcc---->mov r1,#0x000000cc
          mvn---->ldr r1,=0xFFFFFFFF--->mvn r1,#0x00000000
     2 ldr汇编指令
        ldr--->ldr r1,=0x12345678--->ldr r1,[pc,#-0x0004]
        指令的意思：从数据池中取内容赋给r1
        数据池=pc+偏移+8
        [数据池]:取该地址的内容
  6 分支指令
    b/bl  标号（地址）
     标号的范围：0-23bit共24位，相当于FFFFF,可以表示2的24次方个地址，
     每一个指令占4个字节，跳转最少跨越4个地址单元，所以低两位【0-1】不能有值
     处理器将该标号左移两位，腾出低两位不用，所以用26bit位来存放标号，26bit可以表示
     2的26次方个地址，那B指令的调转范围最大就是64指令M，由于B可以往上跳也可以往下跳
      所以B 的跳转范围就是+-32M（byte）
   7 移位指令
      lsl lsr asr ror rrx 
   8 单寄存器传送指令
      ldr:内存--》寄存器  ldrb ldrh
      str：寄存器--》内存strb strh

day2作业
1 测验#1第1题
2 用汇编指令实现一个数组的所有元素累加求和，数组自定义。
3 预习块传送指令

day3:
1 指令
   1 块传送指令：一次可以传送多个寄存器的内容到/从内存中
      ldm
      stm
    使用块传送指令需要加后缀，后缀表示传送的方向，是从小地址往大地址方向传数据？
   还是大地址往小地址方向传数据？
    后缀：ia:先赋值在增加地址  i++
               ib:先增加地址在赋值  ++i
              da:先赋值后减地址   i--
              db:先减地址在赋值   --i
    ldm:把多个内存单元的数据传送到多个寄存器中去
    stm:把多个寄存器的数据传送到多个内存单元中去
     stmfd=stmdb
     ldmfd=ldmia
   2 swp r1,r1,[r0]
   3 psr传送指令  cpsr spsr  
    mrs r0,cpsr
    bic r0,#0x1F
    orr r0,#0x10
    msr cpsr,r0
    
2 软中断
  中断：是一个过程，是指CPU在执行当前程序的过程中因硬件或软件的原因插入了
          另一段程序的运行过程。
  中断类型：硬件中断---》因为硬件故障导致的中断，硬件中断时不可预测的
                   软件中断---》在程序中提前设计好的中断
   设计一个软中断，分析软中断的处理流程  
   软件分析：1  产生中断的方式？软件---》swi 中断号  swi 88--->用户模式下使用
                    2  哪里能接受软中断？异常向量表---》某个特殊位置上的一段代码
                        位置：位于程序的最开始位置0x00000000
                        代码：由8条跳转指令组成的程序块，并且顺序是固定的
                                   复位异常   b  reset
           		未定义异常nop
		软中断异常b swihandler
		存取异常nop
		数据异常nop
		预留异常nop
		普通中断nop
		快速中断nop			
                    3  处理软中断---》保存现场  处理中断 恢复现场
		swihandler:stmfd--->压栈
                                                        处理中断：88---》swi 88指令机器码---》
		[lr-4]--->bic高8位---》低24位中存放的是中断号
                                                        ldmfd--->出栈
                                     
       当异常产生时, ARM core:
	拷贝 CPSR 到 SPSR_<mode>
	设置适当的 CPSR 位：
	 	改变处理器状态进入 ARM 状态  
		改变处理器模式进入相应的异常模式
		设置中断禁止位禁止相应中断 
	保存返回地址到 LR_<mode>
	设置 PC 为相应的异常向量
      返回时, 异常处理需要:
	从 SPSR_<mode>恢复CPSR
	从LR_<mode>恢复PC
       异常优先级：
	异常指定了优先级和固定的服务顺序:
	Reset
	Data Abort
	FIQ
	IRQ
	Prefetch Abort
	SWI
	Undefined instruction
  3  C和汇编的混合编程
       C：C语言   for() add 
      汇编：汇编语言
     如何实现混合？函数调用
       1 如何调用？
        汇编------》C函数  b/bl  函数名
        C----->汇编函数   mycopy(实参) 
       2 入参
       汇编------》C函数  r0,r1,r2,r3 和栈
       C------->汇编函数  mycpoy(char *dest,char *src,)
                                     r0,r1
       3 返回值
       汇编------》C函数    r0
       C------->汇编函数    r0,mov pc,lr
      return 0;===>mov r0,0  mov pc,lr

       汇编调C:
       C调汇编:
day3作业：
1 梳理软中断流程以及代码
      语言 高级编程 数据结构 软件平台 硬件平台 工具


day4:
 裸机编程
  1 实现led灯的驱动
   实现led2的闪烁----》开发板---》裸机程序
 裸机驱动的开发步骤：需求分析
                                    1 查芯片原理图
                                    2 查芯片手册
                                    3  code
需求分析：查看led2是什么？led2和主控芯片是怎么连接的？
           led2--->开发板 ----通过接线----主控芯片----》主控板
         1 查芯片原理图
          led2--->con2---->con1--->GPX2_7(U1A)
         2 查芯片手册
            配功能：输出--》gpx2con--->0x11000c40    0x1(28-31)      
            赋值：gpx2dat---->0x11000c44     0x1/0x0(7)
         3  code---->交叉编译工具链----》arm板识别的代码
    ubuntu---->gcc4.6.4.tar.gz
  交叉编译:在一个平台上生成另一个平台上的可执行代码

  2 实现uart驱动-----》用串口2实现字符的回显
  串口：uart通用异步收发器
  bps:每秒传送的bit位个数
  波特率：每秒中传送码元的个数--->串口收发数据的速率
 通信方式：单工   半双工 全双工
 同步通信：是指数据传送是以数据块（一组字符）为单位，字符和字符之间，字符内部的
                  位与位之间都是同步的（同步时钟）
 异步通信：是指数据传送是以字符为单位，字符和字符间的传送是完全异步的，
                  字符中位与位间的传送是同步的（字符间异步 字符内部各位同步）

    用串口2实现字符的回显a
       原理图：uart2---->con4--->con3--->u1a
  分析：  一 初始化配置
                 1 配置管脚为UART模式----》gpa1_1  0x11400020  0x2(4-7)
                                                                gpa1_0  0x11400020   0x2(0-3)
                 2 配置UART收发数据的格式（奇偶位 停止位 数据位）
                      uLcon2  0x13820000     0x0(6)  0x0XX（3-5） 0x0(2)  0x3(0-1)
                 3 波特率----115200
                   UBRDIV2  0x13820028    53
                   UFRACVAL2   0x1382002c  4
                4 UART收发数据的方式（中断或轮询方式）
                   ucon2  0x13820004  0x1(2-3)  0x1(0-1)
             二 数据的收发
                 1 数据从哪里收？哪里发？
                   发：UTxHn  0x13820020   
                   收：URxHn  0x13820024
                 2 何时收何时发（收发的触发）？
                    UTRSTATn  0x13820010    tx(1)   rx(0)

  1000：sd卡启动--->u-boot(bios)
   0110：flash--->u-boot

day4作业：
1 实现4个led灯的流水显示
2 用c和汇编实现led2交替闪烁
  汇编： b main
   C:   #define GPX2CON     *( volatile  unsigned int *)0x11000c40
         #define GPX2DAT     *0x11000c44

      GPX2CON=GPX2CON&（~0xF0000000）|   0x1<<28;

     
day5:
硬件中断-----》用k2 按键实现硬件中断

马云
 第一阶段：乘坐某种交通工具去杭州---》连线
第二阶段：筛查----》gic
第三阶段：CPU处理客户---》中断过程

中断的基本概念：
 中断定义：
  cpu和外设之间的数据传送方式：
    1 中断方式：当外设需要与CPU进行数据交换时，由外设向CPU发出
                        请求信号，使CPU暂停正在执行的程序，转去执行外设
                       数据的输入/输出操作，数据传送结束后，CPU在继续执行
	     被暂停的程序
   2 程序控制方式：直接在程序的控制下进行数据的输入和输出操作
   3 DMA方式：直接从内存中拿数据，不通过CPU倒数据
    exynos4412支持160个中断源，这些中断源分三类：
     SGI:软中断，指用软件可以触发的中断，用于各个核（core）之间的通信
     PPI:私有外部中断，为每个核私有的外设中断
     SPI:  公共外部中断，为每个核公有的外设中断      
                
用k2 按键实现硬件中断
 第一阶段：
        1 连线k2---con4---con3----u1a(GPX1_1(EINT9))---->57号中断
           配置GPX1_1管脚为外部中断   0x11000c20   0xF(4-7)
        2 配置中断的触发方式     0x11000E04   0x2(4-6) 下降沿触发
        3 打开中断管脚（取消中断掩码） 0x11000F04  0(1)
第二阶段：筛查----》gic
       1 使能57号中断  0x10490104   0x1(25)
       2 把57号中断交给cpu0处理  0x10490838   0x1(8-15)
       3 设置中断优先级      0x10490438    12(8-15)  优先级范围0-255
       4 使能cpu0中断      0x10480000    1
       5 设置cpu0的中断优先级阈值    0x10480004   0xFF(0-7)
       6 使能GIC 总开关    0x10490000   1(0)
第三阶段：CPU处理客户---》中断过程
      1  得到中断号   0x1048000C     (0-9)
            处理中断------》hello
      2  清除管脚中断标志（必须清）    0x11000F44  1(1)
      3 清除GIC控制器的57号中断标志    0x10490284   1(25)
      4 结束中断          0x10480010    57(0-9)

code :
    汇编：中断向量表  reset irq_handler 
    C:  initKey()  do_irq   main()

day5作业：
1 用key3或key4实现硬件中断 


day6:
1watch log---->5s开发板重启
   看门狗：是一个定时电路，一般有一个输入端叫喂狗端；一个输出端连接到
                 mcu的rst端，mcu正常工作的时候，每隔一段时间会输出一个信号到
                喂狗端，给wdt值（更新WDT值），如果超过时间不喂狗（一般是程序跑飞或死机或死循环），
                wdt的值会递减到0，看门狗会给mcu一个复位信号，使mcu复位。
       注：WDT是看门狗电路的一个寄存器，有递减型和递加型，递减型的减到0,
             看门狗会给MCU复位信号，mcu会复位
功能：5s开发板重启
          plck=100Mhz---->看门狗电路的原始时钟脉冲
         经过两级分频后：100M/250/128=3125hz----->WTCON   249(8-15)  0x3(3-4)  
         那么每隔多长时间给看门狗一个输入呢？（递减周期数）
             t_watchdog=1/3125 (s)
          若让看门狗的递减计数器递减耗时5S，那么需要多少个这样的时钟周期呢？
             5/ t_watchdog=15625次
          所以给递减计数器中赋值15625，当计数器递减到0时刚好耗时5s
         注：每隔1/3125（s）递减计数器递减1
2 pwm
   pwm:脉冲宽度调制
   占空比：高电平时间/时钟周期
   功能：PWM驱动蜂鸣器响
    接线：BUZZER----CON2----CON1----U1A(GPD0_0)
           gpd0_0:设置GPD0_0为PWM输出模式  0x114000A0  0x2(0-3)
           TCFG0:一级分频  0x139D0000   24(0-7)
            TCFG1:二级分频  0x139D0004   0x2(0-3)
            TCNTB0：输入波形的个数=2500  0x139D000C  2500
            TCMPB0：高电平持续时间 2500/2   0x139D0010  2500/2
            TCON:更新规则  0x139D0008   
                       1（0）：使能输出口
                        1（3）：表示输出波形个数从2500减到0，继续在从2500减到0，循环减，类似闹钟
                        1（1）：表示立马修改备份寄存器的值为新值，不用等到原值减为0
                        0 （1）：表示不立即修改备份寄存器的值，当备份寄存器的值减为0后才修改该值为新的
                                       递减次数
          注：TCNTB0和TCMPB0各对应一个备份寄存器（是一个递减计数器），当备份寄存器的值减到0时，
	TCNTB0和TCMPB0会给备份寄存器从新赋新值	
3 arm考试
   

  

   