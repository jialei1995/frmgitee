	如果你的人生起点不高，不曾有人为你走过人生中百步中的任何一步，不打紧，你尽管努力，多出来的步数不会被浪费掉，
总有你在乎的人用得着，而你迟早会遇到你在乎的人。

	数字显示的乱码的自己看不懂在vim 下， 可以16进制查看文件 ：%!xxd ---- 查看
		ctags：

		ctags是一个linux上很普遍的源码分析工具，可以将代码中的头文件以及函数变量等记录在一个名称为tags打文件。 tags文件的产出最简单的方法是在需要生成tags的工程项目的根目录下执行ctags -R命令, 这会调用tags递归的扫描当前目录以及所有子目录中可以被tags识别的文件所以文件数据信息都会汇集到tags文件

		在/usr/include/目录下，   
		执行ctags -R                生成tags 文件
		2， vim  ~/.vimrc               编写家目录下的.vimrc 文件， 没有， 就创建 
		 添加以下：
			set  tags=/usr/include/tags

		3, vim   test.c
		   光标移动到函数、宏、类型、等 ， ctrl + ]         进入
			ctrl + o        退出

数字转字符串：c语言:atoi   itoa
c++
		string to_string(int value)
		string to_string(long value)
		string to_string(double value)
字符串转数字：
		int stoi(const strings str, size_t* pos = 0, int base = 10)
		long stol(const strings str, size_t* pos = 0, int base = 10)
		float stof(const strings str, size_t* pos = 0)
		double stod(const strings str, size_t* pos = 0)
		
	
	编译分为：预处理precompile【处理#将内容粘贴到文件中】--》编译compile【生成.s】--》汇编asseble【生成.o】
	--》链接link【拼接多个.o生成可执行.elf此时包含调试信息（只能在linux中运行）】--》objcopy：剥离无用的调试信息生成.bin可以在板子运行
find：
	find ./ -name *.sh     	find 路径 -name filename  
	find ./ -type  c/d/p/s/l/b/f  		字符设备文件，普通文件f

正则表达式：
		egrep  “[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}”  filename 在filename查找ip地址
			   注意“ 位数	 值范围		仅分割意思   .在正则中有别的意思
	
		. 匹配任一字符   			abc. 可以匹配abcd/abc9,,
		[]匹配括号中任一字符		[abc]d   =ad/bd/cd
		^：[^lxy] 匹配除lxy以外的任意1个字符
		？：[0-9]？\.[0-9]    前面0-9要不要都可以
		^匹配一行开头			^con  匹配开头是con的行
		$:匹配行末尾			;$ 匹配行末是；的行
		^$：空行
		
vim中的字符串替换： 命令行模式下：  ：%s/echo/printf/g	将echo字符串换成printf，不带g也行
sed：
	sed 参数 ‘脚本语句’ filename
	sed 参数 -f ‘脚本文件’ filename
		a, append		追加
		i,insert		插入  不加-i不能反映到文件中，只是在终端显示改了，实际文件没改
		d,delete		删除
		s,substitution	替换
		sed -i '4a xxxxxxxxxxxx' filename  第四行追加xxxxxxxx
		sed -i '2,7d'						删除2-7 行
		sed 's/xxx/yyy/g' filename
直接不打开文件，命令替换  sed '/echo/s/echo/printf/g' filename	s表示字符串	
	static int c  c只在本函数内生命周期变长，跟别的函数的c不一样。
	makefile根据时间戳对新改变的文件进行编译。

io：							
	重定向：设置输入不从键盘输入，输出不在屏幕显示（例：ls > /dev/pts/5）		tty  /dev/pts/ 另一个窗口，每次新建都会加1个
	平时打开一个文件，系统就会分配1个对应的文件描述符（从2往后排）
	ls > /ls.out  将ls的内容放到 ls.out 的文件中（重定向到文件）
	ls /1 /2 >f1 2>f2 将对的信息放f1，错的信息放f2
	>filename 清空文件  如果清空的是l类型的软连接，最后请的还是源文件
	>>filename 不覆盖的创建新文件。如果源文件已存在，并不会覆盖。
	

	获取文件长度简单的方法：
		fseek（fp,0,SEEK_END）;	fseek成功执行返回0
		prinft(%d,ftell(fp))；  ftell返回当前文件指针位置，当前偏移量
		
		lseek(fd,0,SEEK_SET);将指针放到开头		偏移量是负的表示向前移动
					SEEK_END:  SEEK_CUR
		重新打开文件文件指针会重新定位到开始。如果在程序中不重新打开文件，就需要冲定位fseek。
格式化输出：
		fprintf(file*,"格式"，参数)；
		sprintf(char *数组指针，格式，参数)；

	fopen：可以发现用fopen函数打开文件时，位置指针都是处在文件开头处，包括用a和a+方式打开，只是在第一次写时位置指针会移动到文件末尾处。并不是有2个指针：读的时候从头读，写的时候从末尾写。

	如果只有if语句不能用break。必须if外有循环才可以
	io读写函数的效率：通过拷贝一个较大的文件 耗费时间长短	time ./a.out a.c b.c  查看文件执行话费时间
		fread 与 fwrite效率是最高的
		fread >> fgets >> fgetc >> read 
	
	scanf("%s",str):从键盘读入，遇到空格、enter都会停止
	gets(str):从键盘读入，只有遇到enter才会停止接受，而且str中不会包含\n的
	fgets(str,size,fp):从流读，假设是stdin，读多少，遇到enter才会停止读取，而且str中会将\n也包含
	gets危险会改变内存的别的重要数据。不要使用
	puts（str）；会多加一个换行符
	fputs(str,out);字符串地址。流 输出不会多加换行符
	fgets(str,10,in);字符串地址，大小，流  不用把str放到赋值符号左边就可以。会将键盘中的\n读进去
	gets（）；不会将\n读进str
	EOF == -1   读到文件末尾ret = fgets（fp）；
		
	fwrite(buf, size, 1, fp);fread 成对使用并且一般用于结构体数组，因为是一块一块的
						*******返回值不是字节数， 是读成功（写成功）的块数
	
	ldd命令可以查看一个可执行程序依赖的共享库
	环境变量设置vim ./.bashrc    export LIBRARY_PATH=$LIBRARY_PATH:.........
	source ~/.bashrc  连接动态库失败的时候执行一下就好了（更新设置好的环境变量）

进程：ps -ef |more  所有进程一瓶一瓶显示或者|grep查找想看的进程 如：test
	ppid：父进程号
	linux在新建一个进程的时候，会创建3个描述符，0 1 2
	top：隔上3秒更新查看进程的动态信息。
	/proc 此目录存放的所有进程的详细信息,内核的运行信息。虚拟的，这个文件夹目的就是让你观察系统运行状态
	-20 是优先级最高的 +19最低
	nice -n 2 ./test 改变优先级（只针对没有运行的进程）
	renice 可以更改正在运行的 进程优先级
	jobs  查看所有的后台进程
	fg  1   将1号后台进程转为前台进程（foreground）
	ctrl+z 将当前前台进程转为后台
	bg 2   将后台挂起的2号进程重新变为运行态（backgrou）
	
	父子进程，子进程继承父进程所有内容，但是有独立的内存空间。都有变量i，但是I的地址是不一样的
	***所以不能通过全局变量进行数据交换。
	
	一个进程的进程号在生命周期不会改变，但是父进程可能改变，（父进程死了，子进程变为后台进程，子进程交给init）

	进程结束exit	会刷新流的缓冲区   _exit不会刷新    （这两个包含的头文件不一样）
	
	exec函数族 让当前进程执行另外的程序（当前内容被指定程序替换）
	让父子进程执行不同的程序。
	l = list形式,v = vector形式【"ls","-a"】，e = environment自己穿进去环境变量
	p = 函数自己根据命令在默认环境变量中查。带p的exec穿进去的第一个参数就不需要带路经了
	execl（指定程序名称char *含路径，）
	execlp("ps","ps","-ef",null)
	execl("/bin/ps","ps","-ef",null)
	char * arg[] = {"ls","-a","/etc",NULL}		#看的是/etc下的文件
	execv("/bin/ls",arg)
	execvp("ls",arg)
	进程回收 wait（&status） 成功返回子进程进程号，失败返回eof。wait会阻塞等子进程退出它才退，不然就一直等儿子，子进程的exit（10），父进程的status里面就会存10.
	也可以wait（null）表示释放pcb就好，不接收返回值。
	
							
	gcc a.c   ./a.out什么现象都没有
	静态库：1：gcc -c bye.c bye.o   gcc -c hello.c hello.o
			2:打包生成库  ar crs libtest.a hello.o bye.o        或把此库位置放入环境变量/lib和/usr/lib（系统库，用户库）的位置
		试验-3: gcc test.c -L. -l test (不写lib .a)  如果把2步生成的库放入环境变量，第三部为 gcc test.c -ltest就可以 -L.哭的位置
	动态库：1：gcc -fPIC -Wall -c hello.c(会生成忽略位置的hello.o)												
			2: gcc -shared -o libtest.so hello.o bye.o 
			3:编译 gcc test.c -L. -ltest(去lib .so) 
	静态库编译时用一下，执行就不用了；动态库，编译时不用，执行时要用。
	wait  --等任何子进程状态的改变
		WIFEXITED(status) 	子进程必须通过exit return结束，返回true
		WEXITSTATUS(status)  得到子进程返回的exit值
		WIFSIGNALED(status)  子进程被信号打断，返回true
		WTERMSIG(status)     得到子进程被那个信号终止
	
	ps-aux	//WIFSTPEPED(status)   子进程被信号停止，返回true
	才能看	//WSTOPSIG(STATUS)      返回让子进程停止的信号
不能printf 出来		//WIFCONTINUED(STATUS)	如果子进程被信号重启，返回true

	waitpid（pid，status，option）
		pid=-1 任何子进程状态改变
		pid>0 等待此进程号对应的子进程状态改变
		pid=0  等待和当前进程同组子进程的改变
		option = 0 阻塞
		option =WNOHANG 不阻塞，指定子进程没结束马上返回0
		option = WUNTRACED  子进程暂停，不阻塞，马上返回0
		
		
	线程：pthread_self()获取线程号
		线程是在进程中创建的，如果main进程结束，线程也会end。可以调用pthread_exit阻塞线程
		使进程等线程结束再结束。

		pthread_join （tid，void **ret）；传出参数给空的ret，返回后ret里面放的pthread_exit（ret）
			
	线程通信：同步互斥		p同时信号量-1			v同时信号量+1（读写操作，生产完才能消费）
		线程同步的概念：  sem_wait(*sem)			sem_post(*sem)
				信号量：p操作：申请资源	信号--		v操作 信号量++	声明在全局变量，便于线程A,B都能访问
			2类信号量：无名信号（存在于内存中，主要用于进程的线程间通信，全局变量）	
					  有名信号（线程、进程间通信都可以）
				信号初始化：int sem_init(*sem,int pshared,int val)	sem是信号量对象	
											  0线程间1进程间	初始化量大小
											 有名信号量   无名信号量
			要对一个读进程一个写进程进行PV操作，需要2个信号量，sem_r初始化为0   sem_w初始化为1
		信号也可以当锁实现，信号是0不能操作，信号是1才可以操作。	
							【有读信号才能读，有写信号才能写】	
		函数sem_wait( sem_t *sem )被用来阻塞当前线程直到信号量sem的值大于0
		
		
		互斥：一次只允许一个（进程或线程）访问共享资源	声明时在全局变量a，b都能访问
				访问之前申请锁，访问之后释放锁
			mutex：锁子（互斥量）			表示不可读阻塞		表示可写，写完后应该v操作	
				pthread_mutex_init							
				pthread_mutex_lock（mutex）
				(给共享资源枷锁)若：当前未锁，成功加锁
									当前已锁，阻塞等待
				pthread_mutex_destory（mutex）
		线程创建的时候可以这样多个线程号都回调同一个线程处理函数。
			pthread_create(&id[i],NULL,func,NULL);   id[0~n]线程都在执行fun函数，是可行的

		信号是同步的：1个线程写入数据，另1线程读取。如果我不写，你不能读。是对两个动作的同步（你走一下我走一下）
		锁是保护共享资源的，我访问你就不能访问。你访问我就不能访问。
		信号量: 进程间或线程间(linux仅线程间)  两者作用域也不一样
		互斥锁: 线程间 		*******************************************



signal函数: 
	void sig_alarm(int sig) 
	{ 
		printf("sig is %d, sig_alarm is called\n", sig);
	}
	 
	int main(int argc, char *argv[]) 
	{ 				35		函数名
		signal(SIGALRM, sig_alarm);  注册给SIGALRM注册对应的处理函数
		alarm(5);  // 5秒后，内核向进程发出alarm信号， 执行对应的信号注册函数  否则它默认是会杀死进程的
		sleep(20);   //**********必须大于alarm的5s，如果没有这句话，程序瞬间就执行完了。
		printf("end!\n"); 
		return 0; 
	}
	pause（） 暂停挂起进程，等待信号（信号有自己的处理函数， 目前学的信号打断默认都会直接杀死进程
	有些信号让进城状态改变，有些例如-9会杀死进程））这种打断进程就不能执行到exit最后这句了
	kill -l查看所有信号		注意所有信号对进程都有默认的处理方式
	SIGKILL SIGSTOP不能被忽略 也不能被捕捉
	SIGSTOP是暂停进程信号，不是终止
	函数kill(pid,sig)  pid可以指定getppid给父进程。。。。
		raise(sig)只能给自己所在的进程发
	SIGALRM：alarm（5）到时间就会发出的信号，发出信号如果有注册过这个信号的处理函数，就会跳过去执行
	SIGINIT：在终端执行Ctrl+c会触发此信号，发出信号如果有注册过这个信号的处理函数，就会跳过去执行	
	SIGCHILD：有子进程退出会发这个信号，可以提醒父进程去回收啦。
	SIGSEGV 段错误
	 进程收到信号的三种处理方式：
	默认：如果是系统默认的话，那就会终止这个进程
	忽略 ：信号来了我们不处理，装作没看到   SIGKILL  SIGSTOP 不能忽略
	捕获并处理 ：当信号来了，执行我们自己写的代码（捕获信号这个动作是需要我们完成的）  SIGKILL SIGSTOP 不能捕获 
	 
	 
	 
	 
————————————————
SYSTEM-V IPC 通讯机制：
	每个IPC对象有唯一ID。
	IPC一旦创建一支存在，除非主动删除（显式删除）
	每个IPC对象有一个关联的key（key为0表示是私有的）。。1个key可以有很多id
	命令：ipcs 查看当前ipc对象
		  ipcrm 删除ipc对象
	共享内存：读取数据后内容仍在其中。内存创建后一直存在内核，直到删除。所以我们用完要释放。
			key_ t key;		0-127					./a.c  'a'
			key = ftok(".",100);//生成key。路径+文件名+工程名‘m’也可以
			shmid = shmget（key，IPC_CREAT|0666）创建共享内存  只用ipc_private创建出来的key默认为000
							FLAG
			
			返回映射后的地址=shmat(shmid,NULL,0) 	映射      有了地址可以写memcopy。fgets。scanf
						null系统分配		0表示可读可写SHM_RDONLY只读		读：puts（地址）
			shmdt（shmaddr）取消共享内存 传地址（用户空间地址删除）
			int shmctl(shmid,int cmd,jiegouti * buf)（内核空间地址删除）
								IPC_STAT IPC_SET IPC_RMID			这时工享内存没人用就会自动删除了候只是添加删除标记，等
								获取属性存到buf 设置将buf设置到属性 删除共享内存ID用不着buf，传null
	得到地址后可以调用含有地址的读写函数。往当前内核的地址空间写东西。
	
	
	
	消息队列几种ipc通信的第一步都是创建ftok--->key关键字 2。根据关键字创建本类型（内存、队列）id
			创建消息队列：操作消息队列就靠这个id
			消息队列id = msgget(key,IPC_CREAT|0666）
			私有的key IPC_PRIVATE或	ftok（多个进程都要访问用ftok）
			msgflag：IPC_CREAT|0666:如果消息队列不存在则创建，若存在返回id
			向消息队列发送消息：				消息的传送靠的是一个结构体（发送接收都通过这个MSG）
			成功0失败-1 msgsnd（msgid，const void*msgp，size，flag）0或IPC_NOWAIT 堵塞不堵塞
									 消息缓冲区地址		消息正文长度 
			
			通信前先设置消息格式：一个结构体struct {
				long mtype,//消息类型
				char mtest[64]//消息正文
			}MSG;		//
			#define LEN (sizeof(MSG)-sizeof(long))	正文长度
			
			从队列接受消息：					如果是0按照消息顺序接收  要收的mtype
			msgrcv（msgid，const void*msgp，size，long mtype，flag）标志位：0或IPC_NOWAIT
											size要稍微大，不然会丢失信息

			控制消息队列：
			0或-1 --msgctl（msgid,int cmd,jiegouti * buf）
			IPC_STAT IPC_SET IPC_RMID
	信号灯集
	
无名管道
	管道。字符设备。快设备。套接字不占磁盘空间。。
		管道中的数据读了就消失了。当管道没有数据，去读就会阻塞。
		存在于内核空间；占用的3-4g的1个g的内存
		父子进程都有读写端，因为先pipe的，所以要读，先关闭写端，要写先关闭读端。（在别的进程这样操作）
		管道只能通过继承的方式来打开pipe，所以必须是具有血缘关系的进程才可以
		
有名管道：
		只有当读端写段都存在时程序才能打开，否则程序会堵塞。
		但是如果某一端关闭，管道中没数据，则另一端运行的程序也会关闭。
		实现两个。c进程的通讯。


守护进程：
		1.创建子进程，父进程退出
		2.在子进程里面操作
			（1）setsid 设置会话组  这样就脱离终端了
			（2）改变子进程工作目录，chdir（“/”）			
			（3）设置文件权限 umask（0） 				1是标准输出
			（4）关闭所有文件描述符 close 循环 关闭0,1,2,3，---关闭1之后就不能打印了
			（5）进入需要的循环while（1）			避免浪费资源，0,1,2开着没啥用	
网络编程：
		DNS域名解析服务
		典型协议：
		传输层：tcp/udp
		应用层：http、ftp、nfs、ssh
		网络层：ip、igmp、icmp
		网络接口层：arp、rarp、以太网帧协议
		tcp：传输控制协议-面向连接的可靠的基于字节流的
		udp：用户数据报-无连接的传输层协议，不可靠
		ip：Internet 互联协议
		icmp：Internet控制报文 ip主机、路由器之间传输控制信息
		igmp：Internet组管理 主机路由器之间
		ARP：正向地址解析  通过已知ip寻找对应主机mac
		rarp：与arp相反
		3层：终端->路由器->交换机
		2层：终端->交换机
			局域网内消息传递：通过交换机的端口映射表：port->mac（压根不需要ip层就可以通信）相当于lan口
			局域网外：路由器中还有个路由表：可以查看要发送的信息的目的ip是否在本局域网内，如果不在，就将数据放到局域网对外接口，相当于wan口，然后数据就发出去了
		交换机：本网段通信，基于mac地址转发数据，内部有个mac地址表。所以可以在局域网内定向传输数据，不能与互联网交换。
		路由器：有广域网接口，不同网段直接收据收发。本质是个gateway，只接受数据包that包含在本ip表内的ip的数据
		通信的时候路由器看一下数据包的ip，如果在本局域网内，就不从wan口发了，如果是别的局域网内的数据，则
		tcp/ip 4层模型
			网络接口：网络：传输：应用层   ip		端口

	数据传输以以太网帧格式：
		目的mac|源mac|帧类型|数据46-1500byte|crc校验(其中目的mac不知，通过arp请求)
		ff*6     ff*6   2byte     
	arp请求帧：
		目的mac|源mac|帧类型|8|源mac|源ip|目的mac|目的ip（路由器通过对ip的检测，找对应mac）
						0806								回传一个arp应答帧传回mac
	命令：netstat -apn |grep 端口号/程序名		 查看状态
	
	客户端与服务器连接过程用的都是同一个端口。都是服务器的端口，才能通信。
	//端口复用函数，放在bind之前 不然./server运行后退出再运行会出错，等会才能运行
	
	报文组成 [mac][ip][port][协议TCP|UDP]【msg】[crc]
	int opt
	setsockopt(fd,SOL_SOCKET,SO_REUSEADDR,(void*)&opt,sizeof(opt));
					level 11对应  solname
	类似read/write的函数
	ssize_t recv(int sockfd, void *buf, size_t len, int flags);
	recv( newID, buf, SIZE - 1, 0) 最后的flag控制阻塞不阻塞 <0 出错
	send( newID, buf, SIZE - 1, 0)	
	recv(sockfd, buff, buff_size,0);//有数据就返回，不用收完
		recv(sockfd, buff, buff_size,MSG_WAITALL); //MSG_WAITALL不一样的0阻塞模式接收        
        send(scokfd, buff, buff_size,MSG_WAITALL); //阻塞模式发送
        recv(sockfd, buff, buff_size,MSG_DONTWAIT); //非阻塞模式接收        
        send(scokfd, buff, buff_size,MSG_DONTWAIT); //非阻塞模式发送

	recv的前三个参数和read相同，send前三个参数和write相同。
	recv的flags
		默认为0时，它是阻塞 相当于read -- 最常用的
		MSG_WAITALL，等待对方发过的数据填满buf才返回，或者当出错/断开连接/收到信号等等异常情况出现时，会返回。
	
	addr.sin_addr.s_addr = inet_addr(ip) 点分十进制->网络字节序
	inet_ntoa(addr.sin_addr.s_addr)  网络字节序-》点分十进制会报错warning但是可以运行
	子进程结束，父进程会受到SIGCHLD信号，自动的
	
	fcntl:改变已打开的文件属性：
		
	文件描述符：设为不阻塞的，设为阻塞怎么设
	int flag = fcntl(socketID, F_GETFL, 0);//获取当前打开的文件描述符的状态标志位，第三个参数可以忽略
    flag &= ~(O_NONBLOCK);设阻塞		这两种设一种
    flag |= O_NONBLOCK;设非阻塞
	//设置当前打开的文件描述符的状态标志位。第三个参数就是该文件的新的描述符状态标志
    fcntl(socketID, F_SETFL, flag);这个falg不能省略，设的就是它
	这个一旦设置，这个监听套接字socketid的accept就会||不会阻塞了 。	
	
	并发实现：1多线程2多进程3io多路复用都能实现。
		python中的多线程、多进程使用方式一样，Process、、Thread传参方式也一样，只不过一次是在一个进程内处理，一个是多个进程
	多进程并发（多线程并发服务器）注意：只是服务器 它可以1对多
	
	
1.客户端连接 2.数据通信
	select多路io转接：  借助内核监听（本来是服务器自己监听连接：accept阻塞）
	int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);
	使用select好处accept就不会堵塞了，server收到select传过来的客户端请求才会accept新建套接字。
	nfds：监听的所有的文件描述符中最大的文件描述符+1  lfd cfd1 cfd2 cfd3已连接3个客户端 准备连接下一个
														3	4	5	  6						7
	fd_set *readfds, fd_set *writefds,fd_set *exceptfds 传入传出参数：进的时候要带数据，进行处理后传出来
		字符集	读写事件					异常事件	传出参数：给个该类型的空值就好，传出来的是返回的需要的值
	select局限：维护一个存放1024以下的数量的存放文件描述符的数组，单线程下数量有限1024，需要轮询（select只知道有io发生不知道是哪个，每次需要遍历，复杂度为On）

	
epoll:最广泛的多路io复用模型
	fd = epoll_create(size);//创建红黑树，指定监听数量
	epoll_ctl(opfd,op,fd,struct epoll_event * event);		//往红黑树添加、修改。删除节点
							结构体成员：events：EPOLLIN/EPOLLOUT/EPOLLERR
										data:联合体
					op操作：EPOLL_CTL_ADD/EPOLL_CTL_MOD/EPOLL_CTL_DEL
	epoll_wait(epfd,struct epoll_event * events,int maxevents,int timeout)			

epoll与select的区别与联系：select原理概述
	select有返回值说明有事件返回值 >0 表示有可读事件，但是具体是数组中的那个发生的不知道，得遍历lfd+1--->maxfd判断每个套接字是否有事件，然后才能处理。
		select的底层其实是内核再做的，内核查看一遍你的监听集合，如果有事件发生会返回ret。On时间复杂度
	epoll_wait 的返回值都是可读事件，遍历i=0;i<ret;i++这么遍历就可以				  O1时间复杂度
调用select时，会发生以下事情：

从用户空间拷贝fd_set到内核空间；
注册回调函数__pollwait；
遍历所有fd，对全部指定设备做一次poll（这里的poll是一个文件操作，它有两个参数，一个是文件fd本身，一个是当设备尚未就绪时调用的回调函数__pollwait，这个函数把设备自己特有的等待队列传给内核，让内核把当前的进程挂载到其中）；
当设备就绪时，设备就会唤醒在自己特有等待队列中的【所有】节点，于是当前进程就获取到了完成的信号。poll文件操作返回的是一组标准的掩码，其中的各个位指示当前的不同的就绪状态（全0为没有任何事件触发），根据mask可对fd_set赋值；
如果所有设备返回的掩码都没有显示任何的事件触发，就去掉回调函数的函数指针，进入有限时的睡眠状态，再恢复和不断做poll，再作有限时的睡眠，直到其中一个设备有事件触发为止。
只要有事件触发，系统调用返回，将fd_set从内核空间拷贝到用户空间，回到用户态，用户就可以对相关的fd作进一步的读或者写操作了。
epoll原理概述
调用epoll_create时，做了以下事情：

内核帮我们在epoll文件系统里建了个file结点；
在内核cache里建了个红黑树用于存储以后epoll_ctl传来的socket；
建立一个list链表，用于存储准备就绪的事件。
调用epoll_ctl时，做了以下事情：

把socket放到epoll文件系统里file对象对应的红黑树上；
给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。
调用epoll_wait时，做了以下事情：

观察list链表里有没有数据。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已。

总结如下：

一颗红黑树，一张准备就绪句柄链表，少量的内核cache，解决了大并发下的socket处理问题。

执行epoll_create时，创建了红黑树和就绪链表； 
执行epoll_ctl时，如果增加socket句柄，则检查在红黑树中是否存在，存在立即返回，不存在则添加到树干上，然后向内核注册回调函数，用于当中断事件来临时向准备就绪链表中插入数据; 
执行epoll_wait时立刻返回准备就绪链表里的数据即可。

两种模式的区别：

LT模式下，只要一个句柄上的事件一次没有处理完，会在以后调用epoll_wait时重复返回这个句柄，而ET模式仅在第一次返回。

两种模式的实现：

当一个socket句柄上有事件时，内核会把该句柄插入上面所说的准备就绪list链表，这时我们调用epoll_wait，会把准备就绪的socket拷贝到用户态内存，然后清空准备就绪list链表，最后，epoll_wait检查这些socket，如果是LT模式，并且这些socket上确实有未处理的事件时，又把该句柄放回到刚刚清空的准备就绪链表。所以，LT模式的句柄，只要它上面还有事件，epoll_wait每次都会返回。

对比
select缺点:

最大并发数限制：使用32个整数的32位，即32*32=1024来标识fd，虽然可修改，但是有以下第二点的瓶颈；
效率低：每次都会线性扫描整个fd_set，集合越大速度越慢；
内核/用户空间内存拷贝问题。
epoll的提升：

本身没有最大并发连接的限制，仅受系统中进程能打开的最大文件数目限制；
效率提升：只有活跃的socket才会主动的去调用callback函数；
省去不必要的内存拷贝：epoll通过内核与用户空间mmap同一块内存实现。
当然，以上的优缺点仅仅是特定场景下的情况：高并发，且任一时间只有少数socket是活跃的。

如果在并发量低，socket都比较活跃的情况下，select就不见得比epoll慢了（就像我们常常说快排比插入排序快，但是在特定情况下这并不成立）。


	tcp：数据包传输，丢包重传，稳定，数据流量稳定，速度稳定，传递顺序
		缺点：传输速递慢，效率低。系统资源开销大。
		使用场景：数据完整性，文件、大数据、迅雷断点续传
	udp：数据报传输，只发不管能不能收到。不稳定				直接写好就是并发服务器，因为他不用连接
		缺点：传输速递快，效率高。系统资源开销小。
		使用场景：游戏、视频会议。视频电话  qq、华为、阿里---应用层补充校验协议，弥补丢包
		小公司一般采用tcp，成本低。方法简单
	udp专用函数：							
			返回成功接收数据字节数，失败-1.0对端关闭							
			
			sendto（套接字，存数据的缓冲区地址，数据容量，0，通信目标地址结构，addrlen）
			返回成功发送数据字节数，失败-1.																
		sendto( socketID, buf, strlen(buf), 0, (struct sockaddr *)&addr, addrLength);
												这个是传入参数，存了本方的地址结构
		recvfrom(socketID, buf, SIZE - 1, 0, (struct sockaddr *)&addr, &addrLength);
												这个是传出参数，从这里出来的地址结构包含了对方的地址结构信息
												也可以传NULL，不关心对端谁发的
										
	以192.168.1.0网段为例：
		最大的主机地址代表该网段广播地址192.168.1.255.发到这个地址的数据包被当网段所有主机接收
		只有UDP协议（用户数据报）才能实现广播
		tcp的叫单播
		默认创建的套接字不能实现广播，要在套接字创建后，setaddropt设置属性才可以。
		之前发的时候设置的ip是目标ip，现在设置的目标ip是255的广播地址

	
sqlite数据库:																	
	创建数据表：																
		create table stu(id Integer,name char,score Integer);
	插入记录：
		insert into stu values(100,"zhangsan",80);
		insert into stu (name,score)values("sss",89);
	查询记录：
		select * from stu; //查询所有字段结果
		select name，score from stu；
		select * from stu where score=80 and name=“dsadsa”；
	删除一条记录：
		delete from stu where score = 80;
	更新一条记录：
		update stu set name="sss" where id=200;
		update stu set name="sss",score=66 where id=200;
	插入一列：
		ALTER  TABLE   table-name  ADD COLUMN  column-name column-type;
		
	删除一列：不能直接删除
		1.create table stu1 as select id,name,score from stu
		2.drop table stu
		3.alter table stu1 rename to stu
	编程接口：
		int sqlite3_open(char *path,sqlite3 **ppdb)//打开数据库
						带文件路径    指向sqlite句柄的指针
		int sqlite3_close(sqlite3 *db)  //关闭
		const char* sqlite3_errmg(sqlite3 *db)  返回错误信息
		
		int sqlite2_exec(
		sqlite3 * db,	
		const char * sql,  将sql语句当成c语言来用		只有sql为查询语句时才会调用callback
		int (*callback) (void*,int ,char **,char **),//回调函数，此函数执行会调用callback函数
		void *arg,给callback传参
		char ** errmsg
		)			返回成功：SQLITE_OK,
***********************************************【ARM】*********************************************************************		
参数传递：
		1.c执行函数fun（1,2）参数怎么传递过去的，利用栈，从右向左将2,1压栈，出栈1,2赋值给fun
		c与汇编混合编程，怎么调用汇编函数传参。利用寄存器，寄存器比栈速度快。x86寄存器少所以利用栈传参。arm寄存器多
		参数传递只能用用寄存器r0~r3，多于4个参数，多出来的参数用栈。
		2.r0用来接函数的返回值，函数的返回值只有1个。用r0就够了。  把返回值封装成1个结构体返回也行
		pc==r15.lr==r14.	add r0,r0,r1===r0=r0+r1	汇编函数执行完最后一句mov pc,lr lr存的函数返回地址，函数执行完
告诉pc去lr的地址往后执行。
		调用别文件中的函数返回值	extern int fun（）
																		
	时钟周期：1s/频率	例如：1s/1Ghz == 1ns  1s大约能执行10^9个指令								
	thumb指令集：16位--arm指令集：32位																下面的例子会影响
	汇编指令： 操作码（后缀s码）+目的寄存器+源寄存器+立即数	跟了s码才会影响cpsr的nzcv，不然不会影响：adds r0，r1，#ff
	*指令执行前判断cpsr条件码--指令执行后判断s码影响cpsr																								
	相等跳转，检查cpsr		beq aaa。。。先判断是否相等才跳转（条件码）
	存储器速度：
		寄存器->cache（sRAM随机静态存储器）->内存（DRAM动态随机存储器:DDRAM-SDRAM）->硬盘（Flash：norflash-bios，bootloader）
	->网盘
	DDR:(SDRAM)同步动态内存（sychonize）是随机访问存储器：访问那个点数据的事件都一样。怎么做到的呢
	硬盘是顺序访问存储器：开头访问快，后面访问得等磁盘转过去才能访问。
		芯片里面一般不放大电容电阻，体积太大
		DRAM:动态内存（保存一位用1个电容）
		SRAM:静态内存（保存一位用4-6个晶体管）
	
	
	BootLoader：不属于操作系统，用.s与.c编写。因为刚开始有异常向量表，.c不能写
		boot阶段：初始化内存后，内存能用才能自搬移（文件系统与kernel）
		关闭看门狗、中断。。。WTCON寄存器某位。。CPSR 的I/F位中断
		初始化时钟---倍频到某一个主频，为外设分频
		初始化串口，在时钟之后.cai kyi tiaoshi
		初始化内存，主要指ddram
		初始化硬盘nandflash
		loader阶段：
		从Emmc/Flash的kernel搬运到到指定内存中，（自搬移）跳转到kernel所在地址。
	BootLoader启动方式：自启动模式，设置自启动参数。bootargs bootcmd
						交互模式：开发板与pc通过串口调试，网口tftp下载pc的内核，rootfs，然后自己用指令启动
	
	
	看门狗（whatch dog timer）：一个base值例如1000，每个时钟周期--1，当这个值为0，reset信号发给cpu复位，重启（喂狗就是程序员为了不让
它变成0产生复位编写的喂狗程序）。程序如果正常运行就会喂狗，不会复位。程序死了，不能喂狗，当base减到0就会硬件重启
但是板子刚开始没有喂狗程序，得靠BootLoader才能刷进去，所以刚开始要关闭看门狗。	
	
	uboot启动分析：										终端才会用到这些资源
汇编阶段：
			设为svc模式，关闭中断、看门狗、mmu、cache  	中断向量表
			基本硬件初始化（时钟、串口、flash、内存）
			自搬移到内存
			设置栈
			跳转到c main
c阶段：
			大部分硬件初始化
			搬移内核到内存
			运行内核
代码分析：
			.lds 连接文件（查看每段代码的位置）
			.global ——start  中断向量表
			cpu设置svc模式  ：关闭中断、看门狗、mmu、cache  时钟串口初始化
			自搬移到内存（重定位）
			调到。main （大部分硬件初始化）

English：
			poll：轮询
			mspaint  调出画图软件
			refrence：引用
电脑几核：
	SOC：cpu+片内sdram+片内flash
	cpu可以直接访问内存（存当前正在执行的程序与data），但不能直接访问外存。
	3级存储：cache--->主存（内存）---->外存（辅助存）
	r0-r12：保存数据临时变量
		r13：sp-栈顶地址
		r14：lr-函数返回地址，函数调转时存放函数运行完后的地址，调用完函数后，pc调到这里继续往下执行。
		cpsr：当前程序状态寄存器
		spsr：备份当前程序状态寄存器[中断时自动调用]
		3级指令流水线：最高效
	
	
串口裸机驱动：
		arm-none-linux-gnueabi-gcc -g -c -o start.o start.s
		arm-none-linux-gnueabi-ld  start.o -Tmap.lds -o led.elf
		arm-none-linux-gnueabi-objcopy  -O binary -S led.elf led.bin 大写-O -S 
··		【1】只要把指定pin的con设为输出，data寄存器设为高电平就ok了
		异步通信：数据传送是以字符为单位的，字符间的传送是完全异步的，字符中位于位之间同步（字符间异步 字符内部各位同步）
				不知道数据多会发，多会收，让你发就发，别人发就收
		同步通信：传输以数据块为单位，字符之间，字符的位于位之间都是同步的。

		每个uart模块都有这几个寄存器，就地址不一样，功能一样的
		uart2：【1】配置第6章一对管脚pin的con为uart模式
				【2】uart章节一共有好几个uart，配置对应的ulcon配置收发数据格式
				【3】波特率   
				【4】数据收发方式-中断或轮训
				【5】收发存储数据寄存器，UTxHn 0x13820020把要发送的数据放到这个寄存器,【就算发出去了，后面不用管了】
										 URxHn 0x13820024  【把数据放到这里就算读出来了，后面不用管了】
				【6】状态：何时收何时发 UTRSTATn（0x13820010）：read这个寄存器，看	
		
	*******************************timer**********************************	
		为什么说看门狗与pwm都是定时器，因为他们配置的结果就是产生一个频率，实际就是产生一个固定的时间长度，
		你配置输出频率的占空比还是基于这个时间，这个频率可以精准配置时间的。exynos配置的时候好几步都是弄频率的。
		看门狗：WTCON = WTCON  |1 |0x7<<3 |249<<8;配置分频，产中断还是产复位信号。还是只当个定时器来用
				WTCNT = 15625;   //不要老想着位操作	，赋值的时候直接赋值就好了。这个里面的数字会递减
			****看门狗的设置跟管脚没有关系，是芯片内存本来就有的功能。喂狗是硬件来做的。而且软件设置的WTCNT一般也是硬件做的，
			现在只是为了学习看门狗才简单的配置这个寄存器。配置好寄存器，板子上电5s会自动reset或执行中断。
			counter计数器是8-16bit的，总大小是是有限的

		pwm：（其实是可以通过高低电平延时来控制频率的，但是延时函数会占用cpu工作时间，在控制舵机的时候别的事情都干不了。
			共有5个pwm定时器，其中4个外接到了管脚有驱动能力Xpw0-3TOUT0，
				
				外部输入的频率是100mhz，经过2级分频25----4----变成1m，设置2个寄存器
				TCNTB0 = 2500;  2500的波形个数实际就设置了输出的波形是400hz，1000000/400=2500。2500个1m的波形才能产生1个400hz的波形
				TCMPTB0 = 1250;  //2500*1/2---实际就设置了占空比为1/2

		软中断：（swi）是用户命令，得先切换到用户状态才能使用这条命令
				1板子上电汇先运行b reset：我们需要在reset函数中设置好栈（给sp赋值栈底），svc模式栈就初始化好了
			-->2现在改变状态为user态，直接执行swi（也可以随便给r0-r12寄存器赋值，等会中断完看能不能复原）就跳转到了swi的处理函数
			-->3刚进入这个模式，板子状态会恢复为svc模式，lr保存刚才的pc下条指针，spsr保存刚才cpsr的值，
				，在swihandler中先压栈将现在的r0-r12，lr压栈；分析是那号中断（swi有很多跳转号的），switch case对比一下往哪个子函数跳
				，然后bleq fun（这里才真正步入了中断子函数，因为要回来所以bl）；
			-->4在中断fun中随便写几条命令改变r0-r12值，然后回去（mov pc lr）
			-->5现在又回到了swihandler，我们可以出栈了，中断子函数都完事了。把刚才压进去的lr直接出栈给pc就行了
			-->6观察现象，现在各个寄存器的值应该回到了跳转之前的状态。
		硬件中断编程：只有几个pin脚可以触发中断（以前的51单片机可以实现中断的腿很少的，本次的exynos4412有17个管脚可以实现，具体引出来几个腿看具体板子了）
			第一阶段：1.设置pin脚寄存器，设为中断。看一下这个中断对应soc的那个中断号
					2.配置中断的触发方式：（跳变沿还是高低电平）
					3.取消中断掩码
			第二阶段（都在GIC中断章节）：1.使能对应的中断号（在中断源章节看pin对应的那个）
					2.把这个号交给cpun管理（一共有4个cpu）
					3.设置中断优先级（只要大于cpu的中断处理阈值就好，要不人家不管）
					4.使能cpu0中断
					5.设cpu0的中断阈值0xff，（0优先级最好，255最小），这样设表示cpu0所有中断都要处理
					6.使能GIC总开关
			第三阶段（在irq_handler中处理中断）：1.取对应的中断号对比，switch case：中处理
					2.清除管脚中断标志位（在gpio章节EXT_INTXX_PENDD）
					3.清除GIC的中断标志
					4.结束中断
	底层的寄存器。【防止编译器优化】（每次拿值不要从内存中拿，要从寄存器拿）
		(*(volatile unsigned int*)0x11000c40)地址里的值是volatile的
							提示编译器对象的值可能在编译器未监测到的情况下改

			1.需要宏定义串口相关寄存器：设置工作模式、波特率、状态寄存器buf满不满，能不能读能不能写
		（一般状态寄存器用来读取的）、数据寄存器（要发的数据，读进来的数据--发送缓存寄存器，接受。。。）
			2.定义串口初始化函数、void uart_init(void){
				轮询工作模式
				管脚设置功能态（用于串口而不是gpio）（能收能发2个位）
			}
			接收、char uart_getchar(void) //	，把接收缓冲寄存器放到ch，否则while（1）卡住
			发送、void uart_putchar(char ch)//如果状态寄存器表示可以发送数据，把ch放到发送缓冲寄存器，否则while（1）卡住
		
**************************************************【C++】*************************************************************		
C++:c++98||c++11 ||c++14	11最多
		封装、
		继承、继承父类 如果构造函数有参数，必须给赋值，直接初始化子类的 同时必须初始化父类，不然相当于没有初始化父类。
		多态、基类中的虚函数参数要与子类的相同才叫重写。参数列表不同就成重载了，不是实现多态。
				如果一个类，存在和父类相同的函数，那么，这个类将会覆盖其父类的方法
				父类的纯虚函数被继承必须重写，不然继承过去的类还是个纯虚函数。
				构造函数初始化：
	用途：
			c：enum e_cmd cmd；cmd是变量
			c++：e_cmd cmd；定义变量都不一样
		bool类型是c++新增的。if（！）不能==0，，只有c中的int可以这样
		进制输出
		oct hex dec 8 16 10
		#include《iomanip》  setbase（16）16进制
		位宽：setw（10）	123默认右对齐左边补7ge" "
							%-10d.右边补“ ”
		
		1. 类型增强
		1.1 类型检查更加严格 
			1)把一个const类型的指针赋值给一个非const类型的指针
			const int num = 9;    //定义了一个const 类型的变量
			const int * p = &num; //const int *由const int *来赋值
			int * q = &num;       //int * 想让const int *来赋值，在c++中不允许。

			2)enum真正枚举//枚举的本质是整数值
			enum e_cmd
			{
					SEARCH,
					QUIT,
			};			
			
			int main()
			{
					e_cmd cmd = QUIT; //可以定义枚举类型的变量
					printf("cmd = %d\r\n", cmd);
					//cmd = 90; //枚举类型的变量只能赋枚举列写出来的值，不能赋值整型，
					//编译器认为这是类型转换，不允许
					
					int cmd2 = QUIT; //枚举的本质是整数值
					printf("cmd = %d\r\n", cmd2);
					cmd2 = 9;
					printf("cmd = %d\r\n", cmd2);
					return 0;
			}
			
		1.2 新增bool类型			
			bool flag = true;
			if (flag)
			{
				printf("true");
			}
			if (!flag)
			{
				printf("false");
			}
			笔试题：请写出伪代码来实现以下数据类型与0比较：int, float, bool
		1.3 小数，默认都是double类型 
			add(2.3, 4.5); //默认参数都是double类型
			int -> long -> float -> double默认数据类型转换，反向转换不允许
			
	2. 命名空间
		命名空间是为了大型项目开发中避免命名冲突的一种机制。
		当一个项目中，参与的人员越多，或者使用的类库越多，就有可能出现命名冲突，比如，同一个函数名实现不同的功能。引入命名空间，相当于给自家建院墙。其它人使用我家的东西的时候：***家：工具
	
		namespace B
		{
				void func()
				{
						printf("world\r\n");
				}
		}
		int main()
		{
				//方法1，作用域::标识符
				A::a = 9;
				A::func();
				B::func();
				
				//方法2，先提示要用哪个命名空间，再使用它里面的标识符
				using namespace A;
				a = 90;
				func();
		
				//方法3，先提示哪个命名空间的哪个标识符，再使用标识符
				using A::func;
				func();
        }
	3. 输入cin输出cout流
		#include <iostream>
		using namespace std;
		int main()
		{
				int a = 9;
				float b = 3.4;
		
				cin  >> a >> b;
				cout << a << "," << b << endl;          
				return 0;
		}
		3.1 按进制输出 #include <iomanip>
			int a = 1234;
			cout << "十进制" << dec << a << endl;
			cout << "八进制" << oct << a << endl;
			cout << "十六进制" << hex << a << endl;
			cout << setbase(16) << a << endl;
		3.2 设置域宽和位数
			cout << setw(10) << a << endl;
		3.3 设置填充符
			cout << setw(10) << setfill('-') << setiosflags(ios::left) << a << endl;
			cout << setprecision(8) << setiosflags(ios::fixed) <<setw(10) << d << endl;
				//setprecision(7)设置小数位的有效位是7位
				//setiosflags(ios::fixed)小数位不足的用0补齐
	4. 函数重载 function overload
		函数同名不同参，叫函数重载。
		int add(int a, int b)
		{
				return a + b;
		}
		
		double add( double a, double b)
		{
				return a + b;
		}
		
		int main()
		{
				cout <<  add(2, 3) << endl;
				cout << add(2.3, 3.6) << endl;
				
				return 0;
		} 
		c++在编译的时候，会把函数名字进行命名倾轧(name mangling)
		例： int add(int, int, int); -> add_int_int_int 
		例： double add(double, double); -> add_double_double
		c语言,在编译的时候，没有进行命名倾轧，以上两个add函数，编译的时候，无法区分，调用的时候无法区分。
		所以，c语言编译报错。
		命名倾轧是在.cpp和.h都要写清楚。
		练习题：数组中元素按不同的格式进行输出。
			例：元素和元素之间用空格隔开，或者用*隔开
		void output(const int * arr, int len, char ch);
		void output(const char * arr[], int len, char ch);
	5. extern "C"
		c++如何调用c语言
		如果c++中用到的c语言函数比较少，且，比较短，建议直接使用extern "C" {}把函数定义放在{}里。
		extern "C"
		{
			int add(int a, int b)
			{
				return a + b;
			}
		}
		
		int main(int argc, char *argv[])
		{    
			cout << add(2, 4) << endl;
			return 0;
		}
		
		如果c++中用到的c语言函数比较多，建议写一个头文件，把c程序先声明，在声明的时候，要用extern "C" {}
		在c++中包含头文件的时候，也用extern "C" {}，包起来。
		定义头文件
		#ifndef _MYSTRING_H_
		#define _MYSTRING_H_

		extern "C"{
			int myStrlen(const char * str);
		}

		#endif
		函数定义
		#include <string.h>
		#include "myString.h"

		int myStrlen(const char * str)
		{
			return strlen(str);
		}
		c++调用c语言的函数
		#include <iostream>
		using namespace std;
		extern "C"{
			#include "myString.h"  //这次包含头文件就行了**********
		}

		int main()
		{
			cout << myStrlen("hello world") << endl;
			return 0;
		}
		
	6. 函数参数默认值
		原则：
			a. 函数参数默认值是从右到左依次写，不能跳跃
			c. 即有函数声明，又有函数定义时，默认值应该写到函数声明的时候，********************
				如果不小心在函数声明和函数定义时都有默认值，那么，只有声明时的默认值生效。***************
			d. 函数的默认值和函数的重载一定要能够区分。
				不能出现二义性（ambiguous） -- 计算机需要做出选择 -- 臣妾做不到啊！
			例：下面的例子是有问题的
				void print(int a){}
				void print(int a, int b = 9){}
				这两个函数当调用者传递一个整型参数时，编译器就不知道具体应该调用上面哪一个函数。
				所以会编译报错。
	7. 引用 
		什么是引用
			引用就是变量的别名，对引用的操作等价于对变量的操作不给引用分配内存，引用和被引用的变量共享同一块内存
			一个变量可以有多个引用，但，一个引用只能对应一个变量。
		定义引用
			例： 
				int num = 9;
				int & r = num;
				int & h = num; //同一个变量可以有很多引用
			例： 
				int & r = 200; //错的，r不分配内存，不能直接存放200
				
			例： 
				int & p;  //错的，引用必须初始化
				p = num;
			例： 
				int num = 9;
				int & r = num; //给变量起别名
				int & p = r;   //给引用再起别名，相当于引用的引用，就是某个变量的多个别名
			
			例： 
				int num = 9;
				int data = 3;
				int &r = num; //给num定义一个引用(别名)
				r = data;     //用data的值修改num的值
				int * p = &num; //指针p指向num
				p = &data;    //指针p指向data
			例：
				int num[10] = {0};
				int * p = &num[0];//p = num; //定义一个指针指向数组的第0个元素
				int & r = num[0]; //定义一个引用，这个引用是给数组的第0个元素起个别名
				int (*p1)[10] = &num; //定义一个指针指向整个数组    
				int (&r1)[10] = num; //定义一个引用，这个引用是给整个数组起个别名
			例： 
				int num[10] = {1, 2};
				int & r1 = num[0];
				int & r2 = num[1];
				int & arr[2] = {r1, r2}; //数组中不能存放引用
			例:
				int &r = num;
				int & * p = &r; //引用是一个别名，它不分配内存，不能用指针指向它。
			例：
				int sum(int & r, int & h)//使用引用来传参，实际代表的是变量的别名
				{
					return r + h;
				}
				
				void swap(int &a, int &b) //使用引用来传参，实现两个数交换
				{
					int t = a;
					a = b;
					b = t;
				}
			引用和指针的区别
				1. 引用必须初始化，指针可以不初始化
				2. 引用在修改的时候，实际上是修改被引用的变量的值；指针的修改，可以修改指向的变量。
				3. 引用不会被分配内存，和被引用的变量占同一块内存；指针，在32位机，4字节。
				4. 引用的运算，实际上是被引用变量的运算；指针的运算是移动一个数据类型的地址
				5. 可以定义void * 指针，但，不定义void引用
				
	8. 内联函数
		内联函数的定义，就是在普通函数的定义前面加inline关键字。
		这仅仅是一个建议。编译器看到inline关键字，可能会把当前的函数在调用处展开。
		只有简短的函数，才会被编译成内联函数。
		内联函数函数体比较简短，不建议有if/switch...case/for/while/do...while/递归
		类内定义的函数优先编译成内联函数。
		
				void MyClock::run()
				{
					while (1)
					{
						tick();这里调用时不用加：：
						show();
					}
				}	
	深拷贝，浅拷贝：Person p2 = p1；
		浅拷贝：Person p2(p1);b是person类刚才创建的，现在拿b当参数又给a传参
		m_Height = new int (height)//函数传参进来height
		int * m_Height;
		浅拷贝在析构函数中会重复释放内存。	
		堆区的内存空间在这里释放。
		在析构函数中将构造函数中的m_height释放if(m_height != null) {delete m_height; m_height = null;}
	怎么解决：
		析构函数不用管。自己创建一个深拷贝函数，A::A(const A & anotherA)拷贝anotherA里面的所有东西
				申请堆内存。
	
	类对象作为类成员：
		要构造本类（人）的对象，先要构成它包含的哪个类（手机）的对象。
		析构的时候，先析构（人）本身再析构它的里面（手机）的对象
		
	this是个指针常量，永远指向变量本身：本质是Person * const this 	
	成员函数后加const	相当于：const Person * const this 连指向都成固定了，不能修改this-》xxx	
	常函数：void show()const	指针的指向都不可修改了
	常对象：const Person b；
	如果一个变量非要修改，定义这个变量时加关键字：mutable int m;
		常对象只能调用常函数
		不变的对象		不变的函数例如打印
	const：
		常量指针：不能通过指针修改指向变量的值，但是指针可以指向别的变量。
			const int *p = &a;  *p = x; 错，想修改指向的变量值。const 修饰int值不能变
			p = &b;对，可以指向别的变量
		指向常量的指针：指针常量-》指针常量的值不能改，不能存一个新的地址，不能指向别的变量
			int * const p = &a;  *p = 20;对，可以改变指向的变量的值
			p = &b;错，不可以指向别的变量						const 修饰p，p不能重新指向
				
	extern ：本文件a.c全局注意是全局定义int a = 100，在另一个文件如果要使用a，得在文件开头部分extern int a；声明。声明一下就能用a了a还是100	
		他的作用是：本文件声明一个全局变量，这个全局变量在别的文件里面定义好了，
		如果直接在本文件extern int a；会报错，因为别的文件没有定义a。extern不知道去哪里找这个a。
		如果直接在本文件全局变量int a，别的文件又全局变量定义int a；就重定义了，还会报错。。可以函数内定义局部的
		extern int a = 10；错，变量的重定义
		全局变量只要能访问就能修改，所以比较危险。可以定义的时候不初始化，用的时候在函数内部初始化也行。
		
	static：文件1定义了全局变量int global；文件2要想再定义global，可以static int global.只在文件2有效	
	系统中：																
		文件定义全局变量static int global.只在本文件有效。其他文件extern int global找不到
	
	static int global可以定义在函数内部，跟全局变量外部定义一样的，都是全局变量，但是这种只能本文件哪里都能用
	也可在多个函数内定义相同名字，互不干扰。生命期跟全局变量一样
	
	
	全局变量存储在堆上。heap	
		
	继承：
		class 子类 ：继承方式public 父类
			派生类					基类
		
		继承方式：公共继承、保护继承、私有继承
		
		父类子类中有名字一样的属性，访问子类变量：son.m_a  访问父类:son.father::m_a 
		父类子类中有名字一样的方法，访问子类函数 son.function（） 访问父类:son.father::function（）
		如果名字不一样，直接son.func()或者sun.m_a就可以
		
	运算符重载：					
		赋值=： 类比较==  ！=   类+类   <<类输出：哎只能利用全局函数重载  
		class Person{
		public:
			Person(int age)
			{
				m_age = new int(age);
			}
			Person & operator=(Person &p) =的时候先释放本来的堆区空间，从新分配
			{
				if(m_age != null)
				{
					delete m_age;
					m_age =null;
				}
				m_age = p.m_age;
				return *this;  返回对象本身，则可以重复调用 =
			}
			
			m_age = new int (*p.m_age);属性在堆区
		}
	内存分区：
		全局区：全局变量、静态变量static、常量const修饰的、全局常量、字符串。程序结束后由操作系统释放
				
		代码 存放2进制机器指令、是只读的、
	引用做函数返回值：									
	***		注意不能返回局部变量的引用。				永远存的0x11的地址  这个地址中可以放别的值
			引用的本质就是指针常量：int * const a=&b;a的指向不能变，但是指向的内容可以变
			扩展：常量指针：const int *p = &a;p指向一个常量，常量的值不能改，但是p可以指向别的位置。
	
*********************容器string************************
	string容器：它是个类。
		int find(const string &str,int pos=0)  查找str在本字符串中第一次出现的位置
		int find(const char c,int pos=0)		找谁，默认从头开始找
		string& replace(int pos,n,const string& str) 替换从pos开始的n个字符，替换为str的前n个字母

		string& insert(int pos,const cahr* str)从pos位置插入str
		string& earse(int pos,int n)删除从pos位置开始的n个字符
		拼接：直接  str+str1+str2  或者 "asd"+"sadasd"就可以
		compare（string str） >0 ==0 <0
	**	string& substr(int pos,int n); 	返回从pos开始的n个字符组成的字符串


	map容器：默认按照key从小到大排序，不管插入顺序。map<T,T> a;	默认构造，拷贝构造(map<int,int>&a)，赋值就是“=
	map不允许插入重复的key元素。insert时自动忽略。
			map插入的时候随便放进去就好了，它内部是无序的，没有头部尾部概念。
			a.insert(pair<int,int>(1,10)).			(*it).first			it->second
					make_pair(1,10)一样的
			删除：earse(m.begin());迭代器方式   earse(m.begin()，m.end());区间方式删除
				earse(3);按照key值方式删除
		
			查找：map<int,int>::iterator pos=m.find(3),	找到返回所在位置迭代器，找不到反回m.end
****************************************vector***********************
**	vector单端数组	动态扩展可以随时插入新数据  不想数组一样，申请固定大小
	只能push_back插入数据    可以pop_back删除
	insert(迭代器，n，elem)，pos位置插入n个elem
	insert(迭代器，elem)；pos位置插入elem

	erase(迭代器)； erase(迭代器1，迭代器2)；

**	vector的迭代器可以+3  +4 -2 这么移动
	
	赋值V2 = V1；直接容器赋值
	empty();size();
	resize(num,elem)指定长为num并用,var之前没值的位置以elem填充新位置;  resize(num）新位置用0填充；
										若num小于原来大小变小，删除末尾元素

	首元素V.front();    尾元素：V.back();

**	这个容器里面没有排序、翻转的函数。这些通用函数是在algorithm中集成的


**************************************c++*********list****************************

	STL中的链表是个双向循环链表☆  支持两端的操作    
			empty()是否为空;size()元素个数;resize(num,elem)指定长为num并用elem填充新位置;  resize(num）新位置用0填充；
										若num小于原来大小变小，删除末尾元素
			push_back(elem)；pop_back();
			push_front(elem);pop_front();
			list<int> L2(L1.begin(),L1.end()); list<int> L2(L1)拷贝构造；list<int> L2（10,1000）10个1000；
		   	list<int>L;			
			首元素L.front();    尾元素：L.back();  迭代器只能++  —-，不能+n   list不能随机访问，要自己移动迭代器去看
			insert(pos,elem);insert(pos,n,elem); 		clear();
			
			erase(beg,end);删除[beg,end)数据，返回下个数据的位置
			erase(pos)：   删除pos位置的数据，返回下个数据的位置
			remove（val）根据值删除--是删除所有的val节点，如果没有val节点，就不删了
			
			reverse();反转，list的内部方法就可以调用
			sort（）；排序，list的内部方法就可以调用@@@@@@但是他不能调用sort的algorithm算法，因为不支持随机访问
					//人家的排序会根据你的数据量大小自动选底层的不同的排序算法、
	【】因为不支持随机访问数据结构不支持标准算法。

**************************queue***************
	1.也不允许遍历
		push(elem);pop();back()队尾元素；front()队头元素；empty()size()
*************************8stack********************	
	stack：
		1.不允许遍历行为	2.可以判空、元素个数、
			push(elem);pop();top();empty()是否为空;size()
********************************************************8
		降序规则：bool fun(int v,int v2){return v1>v2;}   L.sort(fun);给他一个规则他按照你的规则进行排序
	
		类对象排序排序规则：  bool fun(Person &p1,Person &p2)
								{								
									if(p1.age == p2.age)
									{
										return p1.height > p2.height//如果年ling相同，按身高降序
									}else
									{
										return p1.age < p2.age//按年龄升序
									}
								}
		对于vector《string》不能实现数组的输入，会一直卡到那里。
				vector<string> strVec;
				string i;
				int a{ 0 };
				while (cin >> i) {
					strVec.push_back(i);
				}
	algorithm：
	遍历：for_each(v.begin(),v.end(),print);将迭代器中的值1个1个放到print中执行一次
			void print(int val){cout<<val;}
	查找：vector<int>::itrator it =  find（v.begin(),v.end(),val）;找到返回所在位置迭代器，找不到反回v.end（）。
		  vector<Person>::itrator it =  find（v.begin(),v.end(),person1）;找自定义数据类型数据
				但是计算机不知道怎么比较？？所以自己得在class内部实现 == 的重载 bool operator==(const Person &p1)
	拷贝：将v1全部拷贝到v2。新的v2类型要与v1一致提前指定大小	v2.resize(v1.size());	if a&b都相等返回true，，否则返回false
				copy(v1.begin(),v1.end(),v2.begin());															
	排序：sort(v.begin(),v.end(),fun);fun是排序规则，不填默认升序。
	对调位置：reverse（v.begin(),v.end()）；就2个参数（list不能用这个，因为他的空间不连续）
	条件替换：replace_if(v.begin(),v.end(),com,100);bool com（int val）{return val>30;}
	替换：replace(v.begin(),v.end(),oldvalue,newvalue);替换所有的oldvalue
	求和：int total = accumulate(v.begin(),v.end(),起始累加值);返回总数之和。
	源码：最高位表示数的符号，其他位表示数值。例如+7= 0 0000111Bin.  -7=1 0000111Bin	0是正数
	两容器交换数据：swap(v1,v2);类型必须相同。链表可以交换，vector也可以，要求<int>里面数据类型一样
	
																													计算机这么存的
	反码：正数的反码=源码      负数的反码=源码符号位不变，其他按位取反  -7=1 1111000BIN				源         反           补
	补码：正数的补码=源码		负数的补码=源码符号位不变，其他位取反，再+1		-7=1 1111001	-1---1000001-----11111110------11111111
	补码可以解决 -1+1=0的问题


	函数对象-->又名仿函数
		自己可以自己被调用了多少次。	类内部int count;构造函数初始化为0；每次调用时count++;成员属性记录状态；函数对象可做别的函数的参数
		谓词：返回值是bool才能叫谓词。 重载的是bool operator() ( int val);（）  bool com(int v1,int v2);
															有1个参数1元谓词     2个参数2元谓词
		参数：Pred 就是谓词
		类名+（）； person（）；这就是匿名函数对象。匿名对象

		内建函数--include <functional>





	多继承怎么赋值：
			KindergartenKid::KindergartenKid(string name, int score, int year, int month, int day)
				:Baby(name), Student(score), birthday(year,month,day),num(3)
		怎么重载=
		KindergartenKid& KindergartenKid::operator =(const KindergartenKid & another)
			{
				cout << "operator = is called" << endl;
				Student::operator=(another);
				Baby::operator=(another);
				//释放空间，再重新申请内存，拷贝内容
				return * this;
			}
	--a直接就减了
	Person& Person::operator--()
	{
		m_age--;
		return *this;
	}
	a--；先不减，等会再－
	Person Person::operator--(int a)
	{
		Person p;
		m_age--;
		return p;
	}	
		
	<< 输出流运算符
			//这是一个外部函数，想用到类内的私有成员，它是友元函数
			ostream & operator <<(ostream & out, const 类型 & 对象名another)
			{
				out << another.成员变量;
				return out;
			}	
		
	类型& operator =(const 类型 & 对象名another) 
			{
				if (this == &another)
				{
					return * this;
				}
				this->len = another.len;
				delete []this->p;
				this->p = new ...[this->len];
				memcpy(this->p, another.p, this->len);
				return * this;
			}	
		
	静态
		类内声明的静态变量属于类
		修饰成员变量 存放在数据段 不属于某个对象 属于类 用于对象间传递数据
			类内声明    static int data;
			类外初始化  int 类名::data = 3;
			使用        类名::data 
		修饰成员函数 属于类
			类内声明 static int func(参数列表);
			类外定义 int 类名::func(参数列表){函数体}
			使用     类名::func(实际参数);
		静态常成员常量
			声明的同时要赋值 static const int data = 9;	
		virtual int func() final {} //该函数不能被子类重写 -- 不能重写就不能实现多态
		
linux内核移植：
	arch目录：
		5大子系统：进程管理、内存管理、文件系统、网络协议、设备管理【重点掌握】

	● arch ：包含和硬件体系结构相关的代码，每种平台占一个相应的目录，如i386、arm、
	arm64、powerpc、mips 等。Linux 内核目前已经支持30 种左右的体系结构。在arch
	目录下，存放的是各个平台以及各个平台的芯片对Linux 内核进程调度、内存管理、
	中断等的支持，以及每个具体的SoC 和电路板的板级支持代码。
	● block：块设备驱动程序I/O 调度。
	● crypto：常用加密和散列算法（如AES、SHA 等），还有一些压缩和CRC 校验算法。
	● documentation：内核各部分的通用解释和注释。
	● drivers ：设备驱动程序，每个不同的驱动占用一个子目录，如char、block、net、
	mtd、i2c 等。
	● fs：所支持的各种文件系统，如EXT、FAT、NTFS、JFFS2 等。
	● include：头文件，与系统相关的头文件放置在include/linux 子目录下。
	● init：内核初始化代码。著名的start_kernel() 就位于init/main.c 文件中。
	● ipc：进程间通信的代码。
	● kernel ：内核最核心的部分，包括进程调度、定时器等，而和平台相关的一部分代码
	放在arch/*/kernel 目录下。
	● lib：库文件代码。
	● mm：内存管理代码，和平台相关的一部分代码放在arch/*/mm 目录下。
	● net：网络相关代码，实现各种常见的网络协议。
	● scripts：用于配置内核的脚本文件。
	● security：主要是一个SELinux 的模块。
	● sound：ALSA、OSS 音频设备的驱动核心代码和常用设备驱动。
	● usr：实现用于打包和压缩的cpio 等。
	● include：内核API 级别头文件。
	
	子目录Makefile：
		obj-y:编译进内核
		obj- :不编译
		obj-m:以模块形式编译
	主目录Makefile：
		setenv bootargs root=/dev/nfs nfsroot=192.168.1.101:/source/rootfs rw console=ttySAC2,115200 init=/linuxrc ip=192.168.1.250
		 
系统移植：
		裸机编程与系统编程的区别：
		裸机：1.运行速度快，直接操作硬件管脚（有可能损坏硬件）
			   2.一般裸机编程的板子都比较简单，设备成本低
			   3.处理问题单一，单任务执行，单进程
			   4.打印东西还得自己写函数
		系统：1.多任务，开发效率高
			   2.不会损坏硬件，对硬件的操作都是基于linux的系统调用，linux会驳回你的非法操作
			   3.方便，可以使用linux的库（直接printf）io库
			   
		嵌入式系统种类：（硬件资源有限，系统要裁剪，不用多好的系统，能满足要求就可以）
			1.ucos2，ucos3，RTthread（小型路由器，机顶盒）
			2.freeRTOS 小型
			3.win c e（微软iPad以前就是wince）
			4.Vxworks（收费的，大型路由器会用）一年40万
		系统移植移什么：	exynos4412与原来的origen内部很像
			环境：
				pc：tftpd（d表示damen守护进程）：-->etc/ddefault/tftpd-hpa cat查看tftp目录位置（该目录文件可直接tftp下载）
					nfs:   --->/etc/exports
				demo：ip相关   		bootags:告诉内核使用哪里的文件系统 root = /dev/ram  哪里的nfs
										init=/linuxrc--->应用程序的启动脚本。第一个用户进程
										
			1.BootLoader：☆☆☆☆☆☆它不属于操作系统，bl1+bl2+uboot.bin = uboot-fs4412.bin
			我们选用u-boot（这个是在源代码基础上改改再加上三星提供的bl0+bl1加密规则就可以移植到自己的系统中）
 		4 实验：制作SD卡--->u-boot-fs4412.bin 制作带uboot的sd卡
				sudo dd iflag=dsync oflag=dsync if=/home/farsight/u-boot-fs4412.bin of=/dev/sdb seek=1
					1.指定产品BOARD	编译为u-boot.bin 
						不能直接烧，要添加三星的加密方式，修改makefile
						不能直接make，要用脚本./build这个是写好的带加密方式的编译
					2.要改串口、（不配置串口不能打印）
					3.网卡、（tftp服务能用，ping能用，可以ping通）
					4.emmc、（*******【】）（movi write 命令都不能用）   
				先用sd卡启动（不然连串口都没有），将uboot下载到内存，然后write到emmc，这样直接从emmc启动u-boot可以直接用了
			2.linux内核+设备树（这两在linux3.0之前是一体的）每次编译移动，两者都要做
					解压的源码包：make mrproper--->make exynos_defconfig(给自己板子弄合适的配置)
								--->make menuconfig(选择要编译的模块)--->make uImage（vmlinux->zimage->uimage）
					1.配置内核乱七八糟的
					2.配置网卡，否则nfs不能用，则rootfs不能用
				内核启动： 2汇编
						  3打印内核启动信息->初始化各模块->挂载根文件系统->启动第一个用户进程init
					内核调试：printk()-->打印高于默认打印级别的信息
					arm-none-linux-gnueabi-addr2line：很多2表示to的意思。寻找addr所在的文件行数
					oops:pc:[<0xxxxxxxxx>].报错的时候回显示行号
			3.rootfs：自己制作或者选用别人的改改。


		uboot制作过程步骤：	1、确认第一条指令有运行到（点灯法）
		每步都在初始化硬件	2、实现串口输出
		加载引导内核到内存	3、网卡移植
							4、FLASH移植（EMMC）  1.1初始化EMMC    1.2添加相关命令（movi write。。）
		PC端：配置tftp服务（传电脑的-要移植的东西-到板子的内存，然后板子可以烧到emmc，以后就不用接电脑了）					
			配置nfs服务：实现象windows与linux的文件挂载功能的挂载，（板子挂载到linux，在linux运行程序就是在板子运行）
*************************************内核编译*******内核调试****************************************8
		•解压内核
		
		•修改内核顶层目录下的Makefile
		ARCH		?= $(SUBARCH)
		CROSS_COMPILE	?= $(CONFIG_CROSS_COMPILE:"%"=%)
		为：
		ARCH		?= arm
		CROSS_COMPILE	?= arm-none-linux-gnueabi-
		•	导入 默认 配置
		$ make   exynos_defconfig 只是配置不是编译
		•	配置内核
		$ make menuconfig
		•	编译内核make uImage
		arch/arm/boot目录下生成一个uImage文件（如果编译过程中提示缺少mkimage工具，uboot源码中的tools/mkimage拷贝到ubuntu的/usr/bin目录下）******************************
		弄设备树


		2.	修改drivers/char/Kconfig  drive目录中的每个文件夹都有Kconfig文件，写的代码最终会显示到对应的menuconfig中
			在menu "Character devices"下面
			添加如下内容：
		config FS4412_LED    头，到是也不能省略
			tristate "FS4412LED Device Support"  有三个选项（bool是两个） + 标题
			depends on ARCH_EXYNOS4
		help //选项说明，没有也可以
				support  leddevice on FS4412develop board
		register_chrdev_region(devno, LED_NUM, "newled"); 1个设备号的注册，cat /proc/dev
												对应的内核管理1个newled文件		/dev/newled
*********************************************文件系统制作**************************************
		进入Busybox解压后的源码目录
		配置->编译->导入库（其中就有arm-gcc）->
		自制的文件系统中的etc下添加文件inittab
		在etc下添加文件fstab（proc下、   sys下的fs  这是2个文件系统 ）
		用文件系统工具生成ramdisk文件系统映象文件
**************************************************************************************************
	交叉编译工具集：arm-linux-	
		size xxx：显示可执行文件的数据段、代码段、bss段大小  注意：没有堆栈，堆栈在内存中的
		nm xxx：符号标签	显示代码与地址的对应关系表
		strip xxx：剔除xxx中 代码与地址的对应关系表，剔除了mn 命令就查不到了
		strings xxx：查看此二进制文件中 的字符串  就是printf对应的打印信息
		objdump -d xxx：查看二进制文件的汇编代码与对应的地址之间的关系
		arm-none-linux-gnueabi-objcopy  -O binary -S led.elf led.bin 大写-O -S 格式转换
	调试：
		选择将linux的某个文件夹挂载到demo。这样就会同步demo与linux中的数据，可以通过操作linux来操作demo
	
		tftp客户端：tftp 20008000 a.txt	//将a.txt数据搬移到内存空间		md 20008000 显示这里的数据存的什么
		tftp服务端：32位：sudo tftpd-hpa tftpd表示是守护进程	netstst -ua 查看目前的网络服务
			
					
		nand：格式--nand +earse/write/read +内存地址源/目标 +nandflash内部地址 +搬移大小
			写之前要先擦除：
				nand earse 0x6000000 2048//擦除6m地址空间2k字节大小空间（其实是扇区擦除的）
				nand write 20008000 6000000 2048//将20008000内存中2k的数据搬到6m nand所在位置。这样断电也不会消失
				nand read  20008000 6000000 2048//将nand中的6m位置的数据搬到内存中		
	emmc的分区：	config--库--ramdisk--dtb--uImage--bootloader
	内核启动：
		1，bootagrs:root=rfs在哪里	init=启动的第一个init在哪里 	console=使用哪个设备做控制台
		2，fs烧写：rfs用户与内核之间的中介
			1>>nfs普遍用的  TCP/IP
				先安装nfs-kernel-server								自己做/copy
				配置/etc/exports  设置一个自己想挂载的任意目录（这个目录这会还是空的） *（rw，sync，no_subtree。check） 
				sudo etc/init.d/nfs-kernel-server restart 
				root=/dev/nfs 	nfsroot=ip地址（ubuntu）：/挂载目录 	ip=ip号不能与linux一样
				
				
			2>>ramdisk掉电消失
				root=/dev/ram 	initrd=02100000,8M 	init=/linuxrc	console=ttySac..
				完整代码：
					tftp 20008000 uImagine 	
					tftp 21000000 initrd.img.gz	rfs压缩包
					setenv bootagrs root=/dev/ram 	initrd=2100000,8M 	init=/linuxrc	console=ttySac..
				bootm 20008000 这样就可以启动内核了	不能用go，go命令是直接执行的，内核的头不能执行
		
**************************************下载安装git  version control sys**********************************
以往对于共享资源，1个人操作的时候其他人不能打开此文件。
			git config -global user.name 'yonghuming'
			git config -global user.email 'youxiang'
	# Untracked files:未被跟踪的文件
	new file:   hello.c  git add之后，hello.c被放到暂存区
git status后发现-	modified:   hello.c 表示暂存区的hello.c被修改了
	git commit -a -m "//adas"  -a参数要求hello.c已经在暂存区了（之前必须已经git add过了）更新暂存区的hello.c
					这个操作直接将工作区的代码添加到代码库，不再需要先加到暂存区
	比较版本的差异：git log 查看提交日志
				git log --oneline  少量信息显示（**用的更多）
		git diff 315f9fe 666eb6c比较版本1与版本2
		git diff 315f9fe 比较当前版本与版本315f9fe
		git diff HEAD~ HEAD~~ 比较 上2个版本差异
			HEAD表示当前版本
	如果rm *所有文件丢了怎么办？
		git checkout HEAD  .  “·”表示返回最新版本所有  “.”类似于通配符“*”
		git checkout HEAD~  . / hello.c 捡1个  “·”表示返回上个版本所有
		git checkout 666eb6c hello.c弄回来最旧的版本的hello.c
	tag：git tag v0.9 315f9fe相当于给315f9fe重命名
	版本删除：rm readme.txt + git commit -a 从仓库删除readme.txt 不然git status显示的删除只是本地的删除，不是真正仓库的删除 
		git rm hello.c 		从仓库删除hello.c
	
	打包：git archive HEAD~ -o pro.tar.gz
	添加前缀：git archive HEAD~ --prefix=work_ -o pro.tar.gz
	 $ : tar -ztf pro.tar.gz 只查看不是真正的解压
	work_hello.c
	work_readme.txt

	linux@ubuntu:~/work$ git branch 查看分支结构
	dev  
	* master：*表示目前所在分支

	git branch dev：创建分支 dev
	切换分支：
		linux@ubuntu:~/work$ git checkout dev
		Switched to branch 'dev'
	一般主分支用来打补丁，改bug的。
	合并分支：合并之前要切换回对应要合并的主分支（不一定是master）。
	git checkout master
	git merge dev（没有冲突会自动合并）
	如果主分支与别的分支都修改了hello.c
	merge时会：
	Auto-merging hello.c
	CONFLICT (content): Merge conflict in hello.c
	Automatic merge failed; fix conflicts and then commit the result.
	重新修改hello.c再合并：git commit -a这样就合并完了。

	传统开发模型：
		需求分析，概要分析，详细设计，编码，单元测试，集成测试，验收测试（1环套1环，时间出问题周期太长）
	敏捷开发流程：					（迭代）
		做一段先上线，有问题改问题，一个一个阶段来。每个阶段不会出大问题。根据客户需求改动

	 git remote:远程同步 git clone https://gitee.com/jl_git/intelligent_warehouse.git
	 建立远程连接git remote add origin https://gitee.com/jl_git/intelligent_warehouse.git
	 删除远程git remote rm origin https://gitee.com/jl_git/intelligent_warehouse.git
	 push到这里git push
	 git push -u origin master    -u：以后默认往这里推送（git push就好了）
		工作区->缓存区->本地代码库->远程代码库
	 * [new branch]      master -> master表示将本地的master推送到了远程代码库master

	 git clone  https://gitee.com/luyuxingit/intelligent_storage_system.git复制别人的整个项目
	 写wiki：项目的详细介绍

		先将服务器的数据下载到本地git clone 仓库地址：自己在下载的那里赋值一份download
		git config --list   git clone开始下载
		先将自己的文件保存到本地仓库然后push
		git push：将本地仓库提交到远程仓库
		
		git remote add origin https://github.com/jialei-github/jialei.git
		git push -u origin master

		git fetch + git merge显示当前冲突
		git log -p master.. orgin/master
		git merge master.. orgin/master
********************************makefile********************************************
		%.o:%.c:
			$(cc) -c %.c -o %.o  自动将所有.c生成对应的.o

		obj = 1.o 2.o 3.o ...太多了怎么破？函数参数，参数直接写到函数名后面即可之间用‘，’隔开
		1.src = $(wildcard ./*c)获取本目录下的所有的.c赋值给src
		2.obj = $(patsubst ./%.c,./%.o, $(src))  将src中的任意1个.c转变为.o赋值给obj
		依赖生成目标
		无依赖执行直接执行伪目标
		直接make生成的是终极目标 target
		make clean命令：执行的就是clean目标
		make hello执行的就是hello目标（就是打印1句话）
		hello:
			echo "hello makefile"
*************************************************************************************		
QT:
	qt的lable还可以显示图片，gif，可跳转的域名
		
	qt中所有的事件类都继承与qevent	，bool event（QEvent* ev）函数不直接处理事件，而是按照事件类型分派给
	特定的事件处理函数。在函数体内把自己想处理的事处理一下，其他事件交给父类处理，你不可能处理所有的事件。
	qwidget中定义了很多事件处理函数都是虚的，可以在子类重新实现的。protected function
	事件不用connect写好了发生就可以触发事件函数。	
	图片：
		QPmixmap pix；pix.load("路径")。设置参数
		p.draw(0,0,pix);

	connect(sock,SIGNAL(error(QAbstractSocket::SocketError)),this,SLOT(on_error()));
	connect连接中信号只写类型不写形参，slot可以参数比signal少。
	
	主窗口控制事件分发：
			在mainwindow中：重定义event（）将传进来的实体化的QEvent *e事件，根据类型选择对应的处理函数
								{
									switch事件（e->type（））
									 == xxx    mousemove事件；
									 == xxx    closeevent事件；
								}
		
	filename = QFileDialog::getOpenFileName();
	匿名对象，不用起变量名，直接用：pl：（QString()<<"你好"）作参数传进去
										(QStringList()<<"xx"<<"yy")作参数传进去

SMTP:cmd 
>>telnet smtp.qq.com 25
Trying 183.3.225.42...
Connected to smtp.qq.com.
>>helo localhost
250-newxmesmtplogicsvrsza8.qq.com-9.21.160.46-56014474
250-SIZE 73400320
250 OK
>>auth login
334 VXNlcm5hbWU6
>>NjQyNTY3OTMz
334 UGFzc3dvcmQ6
>>eWVjbG1hZWJ5bnprYmJjaA==
235 Authentication successful
>>mail from:<642567933@qq.com>
250 OK.
>>rcpt to:<iamleilei1234@163.com>
250 OK
>>data
354 End data with <CR><LF>.<CR><LF>.
>>From:<642567933@qq.com>
>>To:<iamleilei1234@163.com>
>>Subject:mail from telnet

hello from telnet
sadasdasdas
dsfdsfsdfd
vsdvdsvdss
>>.
250 OK: queued as.
>>quit
221 Bye.
Connection closed by foreign host.

	qt的静态库要自己编译所以一般使用动态库。
	将写好的qt程序编译成release版本，copy生成的app.exe到一个新目录，在此目录中打开powershell，//powershell用起来？？
			然后用windeployqt.exe ./app.exe操作，会将它需要的动态库文件都放到此文件夹
			或者：cd /d D:\现在新建的存app.exe的目录   windeployqt.exe ./app.exe
	代码编译不一定非要用qt软件内点击鼠标：
			1.直接使用qmake.exe进行qmake，然后使用mingw32-make.exe进行make就会生成app.exe
	在linux下可以直接安装需要的动态库就好了，apt-get，它会解决安装包的依赖问题。 
	qt中函数alt+enter自动补全
	


**************************************驱动开发******************************************

	内核目录执行：make modules  啥意思：往板子的rfs目录放个含linux的makefile的modules文件夹。
				make modules_install INSTALL_MOD_PATH= ~/rootfs	将模块安装到rootfs中  
					则   ~/rootfs/lib/ 下多了1个modules文件夹

		直接写模块入口函数：int init_module(void)		    这么写就不需要写module_init了
				出口函数：void cleanup_module(void)		这么写就不需要写module_exit了
		module_init与module_exit相当于给入口函数出口函数重命名的
		安装：insmod +demo.ko---------对应module_init(demo_init);入口函数【安装】 module_init;
		卸载：rmmod+demo  ---------对应module_exit(demo_exit);出口函数【卸载】	module_exit();

		模块安装完成可以$: lsmod | grep 模块名------>查看系统模块有没有，ismod就有了rmmod就没了
		dmesg查看打印信息

		modinfo ./hello.ko查看模块的相关信息
		模块传参：  在源码中写好可以传参，然后模块安装的时候就可以传参进去
				代码.c中也要有配置才行
				int x；
				module_param(x,int,0664); 变量名、类型、权限不能是0666
				char y;
				module_param(y,charp,0664) char型指针，传字符串的
			sudo insmod ./hello.ko x=1 y=“字符类的这么传” z=3...安装时才传，安装后以后这里面的变量就固定下来了
	
		多个.c的模块怎么写：
				更改makefile：在obj-m:=hello.o  下一行+
				还只能是objs：hello-objs := hello.o hehe.o  注意不能这么写，两个hello.o产生了递归了。生成的hello.ko卸载不了了
									可以写成 hehe1.o hehe2.o
			
	模块导出：产生依赖A---->B  b中使用了a的函数与变量***（删除的时候先卸载b.ko才能卸载a.ko）
			1.编写a.c时再变量后面加一行EXPORT_SYMBOL(变量名)；
					函数名后面加一行EXPORT_SYMBOL(函数名)；	
			2.编写b.c时先要声明extern int x;
							extern int add(int a,int b);
			3.编译a.c----->生成a.ko------>insmod a.ko
		方法一：4.将a.c所在目录下的Module.symvers拷贝☞b.c所在目录，然后编译b.c----->生成b.ko---->insmod b.ko
		modprobe：
			modprobe ：  模块探测 
			把相关的模块 copy 到/lib/modules/3.123-gerneric  下 
			sudo depmod -a     建立模块之间的关系 
			sudo modprobe hehe  这个随便在哪里执行都可以安装模块2了

		设备文件：
			     
			mknod /dev/xxx  c   222   0   

			设备号：  设备号是一个纽带， 链接驱动程序 和  用户空间的设备文件，

			设备号------------- 32位的整数  
			高12 位 ------------------ 代表主设备号， 代表一类设备，250 --- 串口 
			低20位 ------------------ 代表从设备号 ， 0------- 串口0    1 ------- 串口1 

			#define MINORBITS	   20
			#define MINORMASK	((1U << MINORBITS) - 1)

			#define MAJOR(dev)	((unsigned int) ((dev) >> MINORBITS))        获取主设备号， dev 是设备号， 
			#define MINOR(dev)	((unsigned int) ((dev) & MINORMASK))       获取从设备号， dev 是设备号， 
			#define MKDEV(ma,mi)	(((ma) << MINORBITS) | (mi))            知道主设备号ma， 从设备号mi， 获取设备号 



			 写设备驱动程序， 首先申请设备号：
			cat /proc/devices   查看可用的设备号（主设备号还是从设备号？？？？？？）  


			  
			静态申请设备号：
			int register_chrdev_region(dev_t from, unsigned count, const char *name
				成功0   失败负值			设备号        几个         名字“name”
			注销设备号：
			void unregister_chrdev_region(dev_t from, unsigned count)
			

		驱动要在demo板中运行，编译的时候相应得makefile路径要换成编译相应得内核用的makefile。
			在ubuntu里面的驱动makefile中：KERNELDIR ?= /lib/modules/3.14.0/build  ubuntu中linux内核的makefile
			在demo板中的makefile：KERNELDIR ?= /source/rootfs/lib/modules/3.14.0/build arm中的makefile

		$ dmesg			查看内核的日志信息 ，一般查看之前先清一下历史记录 sudo dmesg -c----清除历史日志信息
		
	内核模块与设备驱动之间的关系：
		模块：linux内核组件管理的方式		驱动：都是基于模块进行注册和注销的
		驱动的种类：
			字符设备：IO传输以字符为单位-----应用层read/write，硬件就紧接发生进行读写操作
				eg：鼠标、键盘、触摸屏
			块设备：有缓存的				应用层read/write，硬件不会紧接发生
				eg：磁盘，闪存
			网络设备：eg：网卡【网络设备没有设备文件】
	描述所有字符设备有个结构体：cdev【内核要管理就要有统一的机制】就是这个结构体
		
			struct cdev{
				struct module *owner;//THIS_MODULE
				const struct file_operation * ops;	//里面全是函数指针，操作方法集【不同驱动操作集不一样】，提供给应用层
				dev_t dev;					//设备号
				int  count;				//一般一个驱动对应一个设备，有时候一个驱动也会对应多个设备
				struct list_head list;	//链表
			}
		
			MKDEV(major，minor)；根据主次设备号生成设备号
			MAJOR（设备号）；提取主设备号
			MINOR（），提取次设备号
	如何编写字符设备驱动：5步     操作集刚上来就要写
			0.注册设备号【2中方法】
				[1]自动分配
				[2]指定设备号注册
			1.struct cdev * cdev_alloc();			为cdev结构体分配内存空间
			2.void cdev_init(&cdev,&ops操作集);		初始化cdev结构体【系统完成的】
			3.int cdev_add(&cdev，设备号，设备个数)； 添加【注册】字符设备到内核，由内核统一管理
			4.void cdev_del(&cdev);					注销cdev结构体
		mknod:建立设备文件与设备号之间的联系

		read与write操作硬件的时候：
		read:copy_to_user
			要把内核空间的的buf拷到用户空间,
		write:copy_from_user
			用户空间有个buf，内核空间有个kbuf要把用户空间的数据拷到内核空间进行操作。
	用户空间：（在内存中占用0-3）
		运行用户程序
	内核空间：（3-4）
		运行：驱动，内核代码
		
		printK:打印优先级，可以设置打印出来那种信息：错误、调试、、、、
		
		make menuconfig:遍历显示所有目录下的kconfig。每个配置项都对应kconfig中的一个文件
		menuconfig中的一行在kconfig中有5、6行对它的描述
*************************************8	IIC****************************************
		iic < spi < sdio < 网络 bv usb
	直接touch + 已存在的文件名相当于把文件重新写一下，不会让之前的内容消失.目的是更改时间戳
	iic的芯片（8脚的为例）：7根线表示地址（7中的4个已固定为1010 ），其他3个(a2 a1 a0)接线确定h/l
									1 0 1 0 a2 a1 a0 r/w
	eeprom是iic通讯芯片
	iic速度一般都是400kbps
	通讯开始之前sck一直是H电平
	通讯开始：第1个clk为h的时候sda由高变低，start信号
	接下来的7个sck为h的时候，sda发1 0 1 0 0 0 0即从机地址
	第8个sck为h时，主机发送r/w要求。
	第9个sck为h的时候，从机给主机发ack信号。-------------建立好握手可以实现数据发送
	10--17个sck中，sck上发送8位数据......
	18sck中从机回ack表示接受完成
	19sck中stop信号触发通讯结束
	iic寄存器说明：
		con：sck速度，状态位（正在传输、已传完），使能ack，使能tx/rx
		stat状态：主机作为发送/接收，设置开始/停止条件，数据Tx/rx使能，ack能否被接收（**主方提供时钟**）
		dat：可以装设备地址也可以收发8bit的数据
	传输时1次传输8bit，高位在前低位在后
	总线空闲状态：sda为H
	陀螺仪：mpu6050  三轴传感器
	fs4412硬件资源：
		gpio接口驱动：pwm接口驱动：按键中断驱动：adc接口驱动：spi接口驱动：iic接口驱动：
	mpu6050.c ：物理总线iic下的驱动，真实的总线的驱动
			驱动中还是探测函数--->探测函数会带过来iic设备pdevice
	平台驱动：虚拟总线下的驱动
*******************************内核内编译模块********************************
	内核内编译模块：
		1.写驱动程序
		2.修改Kconfig  添加1个菜单项，这项可以在make menuconfig中进行配置
		3.make menuconfig 配置刚才的那一菜单项，要不要编译
		4.查看.config 看一下是否配置了
		5.在drive/char 下修改Makefile（a.c所在目录的）
	

	字符设备：以字节为单位访问的设备
	基本没有soc自带网络功能，一般都没有网络功能。都有uart。spi。iic
		用的DM9000，网络有专门的芯片，可以通过驱动网络芯片实现soc与dm9000通讯就好
	块设备是有文件系统的，fd = open（块），读写操作进行访问、写入
	inode：						xxx
		创建设备文件：mknod /dev/hello c 249 123 观察inode使用情况
		普通文件：touch 1 2 3 观察inode数量
		硬盘容量很大只占用20%但是写不了文件？？？因为inode用满了
	作驱动的时候open的是设备文件，不是普通文件，操作还是读写
	struct file_oprations hello_ops={
		.release = hello_close,  //并不会直接关闭，如果2个程序同时打开同一个dev，其中1个并不会关闭另一个的打开。直接关闭的话大家都不能用了
	}

	查看linux中的函数跳转vi -t IO_W   ----ctrl+[

	1.驱动编写完成insmod后要cat /proc/devices 看一下对应的dev号
	2.然后mknod  /dev/dev中的驱动名  +   c  +刚才看的dev号（主设备号）+ 驱动文件中的从设备号     //创建设备文件
	驱动中的设备号与应用程序中的要一致。
	写应用程序之前要申请设备号，应用程序操作此设备号。（是mknode申请的吗？）
	命令都是32位的，驱动中的命令都是32位的。
	struct file与之前学的FILE *f 完全不是1个东西
	df-f  :查看inode使用情况
		register_chrdev_region：  静态插入自己定义MKDEV的设备号
		alloc_chrdev_region(&devno, mi,count,"hello"); 动态插入动态申请的设备号
	inode结构体{
		.设备号dev_t
		.cdev结构体{
			.struct file_ops
		}
	}


	ioctl:
		系统调用里面有个ioctl:
			sys/ioctl.h
			int ioctl(int d, int request,...)
			对打开的文件描述符，发命令
		驱动里面：
			file_operations的结构体成员
				long(*unlocked_ioctl)
			命令生成：
				_IO  _IOR  _IOW 这几个命令写法、参数不一样，功能基本差不多
			#define _IOC(dir,type,nr,size)
				type----随机数magic
				dir-----命令的方向，读，写
				nr------命令的序号
				size----命令的参数类型（int char）
	/proc 此目录存放的所有进程的详细信息,内核的运行信息。虚拟的，这个文件夹目的就是让你观察系统运行状态
	/sys 也是虚拟的目录，不会随硬盘转移。设备、驱动信息
*************************************	adc：*****************************************************************
		一般soc内部用的逐次逼近型。猜数字量转换成模拟量与实际模拟量对比，多猜几次结果就对了
		soc内有多个ad转换模块，每个模块多个通道，理论上都可以与pin脚连接起来，但是1般只会引出部分pin脚。
		采样有单端采样，差分采样模式
		采样精度不高的adc基准源直接接ACC就可以。
		采用不同采样分辨率，时钟设置不一样（分辨率高的采样慢）

		编程配置：
		1。打开adc模块时钟源（等会用的时候自己再分频）+pin脚对应的port组的时钟
		2.pin脚功能设置为adc用（不是设普通gpio）
		3.
			1）adc时钟分频设置
			2）采样时间（long time /short time）
			3）用多少精度
			mux1）选择哪个通道呢
			trigger方式：软件/硬件
			连续采样/1次采样（连续采样比较耗电，费cpu）
			数据从adc0的14mux读
			这条不是初始化设置的：观察采样完成的flag（采样1次是否完成），读数据后把这1bit擦除了


		adccon： 分辨率、FLAG转换是否结束、时钟使能、分频、工作模式（省电standby、正常）、启动方式（置1转换开始，转换完自动为0）
						exynos4412两种启动方式0bit  1bit都可以启动，我们选择0bit启动（启动后这bit自动清0）
		adcdata：数据reg
		adcmux：通道选择reg
		End of conversion flag(Read only)  当它置1，值才可读
挂载：
      $ sudo mount -t nfs localhost:/source/rootfs    /mnt
      $ sudo umount /mnt/      

      inode结构体:
      		每个文件（包含字符设备文件）都有自己的inode结构体
      cdev结构体：
      		内核空间，每个cdev结构体代表一个设备
      file结构体：
      		用户空间每打开文件，在vfs（虚拟文件系统）层，都有对应的file结构体，结构体中有个成员指向的就是属于它操作集（）

      自动创建设备文件：
      		之前的创建方法：
      			cat /proc/devices  查看分配的主设备号
      			在驱动.c中查看第一个从设备号
      			mknod xxxxx
      		现在创建：不需要mknod自动创建 cat /sys/class/hello(有5个hello)
      			cat /dev/ 里头也有
      			设备其实不是驱动程序（内核空间的）创建的，只是向sys注册，设备是守护进程创建（守护进程看到这里sys有信息，就根据信息去创建）（驱动本身不能在用户空间创建dev）
      		通过创建类设备（设备信息），创建设备device（设备信息），只是向sysfs注册设备信息，sysfs是内核里内存型的fs，主要管理设备、驱动
      		sysfs在开机时候就会挂载到/sys
      sudo cat /proc/kmsg  enter另一窗口运行主程序，看内核打印信息
      传感器一般都是iic通信（包括摄像头基本都是iic）
    真正控制led灯：
    	内核   ：操作硬件寄存器，通过内核空间的虚地址
    	arm裸机：操作硬件寄存器，使用的真正的寄存器物理地址*(int *)0x4444444
    linux下的硬件编程：
    	1.io内存空间映射
    		映射物理寄存器的地址到内核空间，得到其在内核空间的虚地址
    		p = ioremap（0x2432423423,4）地址长度
    	2.内核空间操作该虚地址，操作它就是操作真正的物理寄存器
    		val = ioread(p)
    		iowrite(val,p)
    	3.iounmap
    linux内核内存分配
    	按页申请内存
    		__get_free_pages(int gfp_mask,ulong order);
    		mask----属性
    		order---0----2^0页   ----n-----2^n页
    		分配的内存物理上是连续的
    结构体数组初始化struct a[3]
    				{
    					{.x=1,.y=2},       //a[0]的初始化
    					{.x=1,.y=2},		//a[1]的初始化
    					{.x=1,.y=2}
    				}

驱动模块的makefile：
    ifeq ($(KERNELRELEASE), )//注意有个“ ，”这句话是看KERNELRELEASE是否为空
	KERNELDIR ?= /lib/modules/$(shell uname -r)/build   //选择制作ubuntu所在的makefile所在的路径
	#KERNELDIR ?= /home/farsight/rootfs/lib/modules/3.14.0/build   //选择板子上的linux内核makefile路径
	PWD := $(shell pwd)   //当前驱动.c的路径
	modules:
		$(MAKE) -C $(KERNELDIR) M=$(PWD) modules
	else
	  obj-m := hello.o
	endif

	clean:
		rm -rf *.o *~ core .depend .*.cmd *.ko *.mod.c .tmp_versions Module* modules*
file_operations操作集（部分）
struct file_operations hello_ops = {
	.owner = THIS_MODULE,
	.read = hello_read,
	.write = hello_write, 
	.open = hello_open, 
	.release = hello_close, 
	.unlocked_ioctl = hello_ioctl,
	.mmap = hello_mmap, 
};
************************************linux 内核中内存的使用*********************************************
按页申请内存：
unsigned long  __get_free_pages(int gfp_mask, unsiged long order)
mask  ----申请内存的属性 
order  -------------0 ----------- 2^0          1页
                1 ---------- 2^1          2 页
1页 ==== 4096 字节
分配的内存物理上是连续的 ， 申请到的内存的大小一定是2 的order 次幂 
使用该函数一次可以申请的最大的内存 1024页 * 4096字节 ===== 4m 字节 
申请的内存 内核空间使用

void free_pages(unsigned long addr, unsigned long order)

按精确的字节数申请：
static __always_inline void *kmalloc(size_t size, gfp_t flags) 
size ---- 具体的字节数
flags ---- 申请内存的属性 
按具体的字节数申请内存， 物理地址是连续的 ，
申请的内存 内核空间使用
flags  :
GFP_KERNEL - 申请内核空间的一段内存时， 可以睡眠，  正常情况下用它
GFP_ATOMIC----- 申请内存时不能睡眠，  主要用在中断的处理函数里，
 

void kfree(const void *objp)
vmalloc ：
void *vmalloc(unsigned long size)
申请精确字节的内存， 内核空间使用， 
物理地址不一定连续 

void *p; 碎片如果很多但是不连续
p = vmalloc(30);   可以申请到， p[0] , p[1],p..., p[29],  
p =kmalloc(30) ;    申请不到 


void vfree(const void *addr)




内存对象池：
内核为了满足任意数量的内存使用请求，创建了由各种不同固定大小的内存块组成的内存对象池  当kmalloc申请内存空间时，内核就会将一个刚好足够大的空闲内存块分配出来。比如要申请100字节，kmalloc就会返回一个128字节的内存块
在4k字节大小页面的系统上，分配的最小内存块是32字节，最大128k字节

后备高速缓存（slab）
设备驱动程序如果常常反复使用同样大小的内存块，可以自己创建一个内存池

内核空间内存：
线性映射区域：3g开始的虚地址  和 物理内存0地址开始的 一段内存 一一对应的关系 。
高端内存（内核空间的一段虚地址）：很少的高端内存的虚地址  可以访问到 更大的物理地址空间 ，


mmap 方法：
应用层里：
void *mmap(void *addr, size_t length, int prot, int flags,
                  int fd, off_t offset);
把内核的一段内存， 映射到用户空间 
addr ------------ 映射到用户空间的地址， NULL---- 映射到用户空间的地址由内核决定， 可以返回映射到用户空间的地址，这里填NULL就好
length ------------ 把内核空间的一段内存， 映射到用户空间，  映射多大？
prot ------------  内核空间的一段内存，映射到用户空间，  映射属性？PROT_READ | PROT_WRITE
flags ------------- 内核空间的内存的映射方式，  共享的映射， 私有的映射？MAP_SHARED
fd ---------------- 从哪里进行映射？
offset ----------- 映射时的偏差地址， 

返回值：  内核空间的内存， 映射到用户空间的地址

int munmap(void *addr, size_t length);
解除映射 


驱动里：
实现mmap 方法,
/**
 映射内核空间的一段内存到用户空间
 * @vma: 用户映射内核内存的要求 
 * @addr: 映射到用户空间的地址
 * @pfn: 内核空间的一段内存的物理地址（以页为单位）
 * @size: 映射多大
 * @prot: 映射属性
 */
int remap_pfn_range(struct vm_area_struct *vma, unsigned long addr,
		    unsigned long pfn, unsigned long size, pgprot_t prot)

 virt_to_phys（pkbuf） >> 12          虚地址转换成物理地址, 物理地址/ 4096 得到pkbuf 的内存的页码  
************************************ 设备树编写与开发板设置*********************************************
	有了设备树，就不用写平台设备的代码了。内核加载的时候就将平台设备注册好了。
		linux-3.14/arch/arm/boot/dts  目录中的exynos4412-fs4412.dts就是设备树源代码
		更改目录下的exynos4412-fs4412.dts，添加设备节点
		在顶层目录linux-3.14/下执行  make dtbs生成exynos4412-fs4412.dtb  放入/var/lib/tftpd-pha/目录中（可以给这个dtb换个名字）
		在板子的env环境变量中添加1个变量：
	mytest=tftp 41000000 uImage;tftp 42000000 exynos4412-fs4412.dtb;bootm 41000000 - 42000000
									这个设备树是自己改变完成的dtb名字
		【】用device+drive写驱动时，match通过platform_driver.name与platform_device.name匹配
		【】用设备树时，驱动的匹配通过，platform_driver.of_match_table  描述驱动支持的设备树里的某一个设备
	***一个设备节点可以包含整个板子的所有寄存器，不用建立很多节点
***********************************************驱动中断************************************************
	内核中的定时器：
		jiffies：自系统开机就开始计数+1+1+1+1，驱动程序中的延时							应用程序里面的用sleep延时
			HZ：决定多长时间+1  决定每s产生多少次定时器中断
		***jiffies每隔 1/HZ 时间 +1  即1/(1s/100)  是个时间段数（这个HZ不是Hz单位）
			HZ = 1s/100		
驱动中断：在dtb中指明那个脚要中断，中断触发方式
		fs4412-key {
			compatible = "fs4412,key";
			interrupt-parent = <&gpx1>;  gpx1的2脚，第二个2是触发方式：下降沿
			interrupts = <2 2>;
		};
	plat_drive.c只改of_table_id.
	hello.c中：
			在初始化函数外部实现中断处理函数：
			int keypara = 100;
			irqreturn_t  keyhandler(int no,  void *para（这里可以给它传参）)
			{
				printk("no = %d, para = %d\n",no, *(int*)para);
				return IRQ_HANDLED;
			}
		1.pkres = platform_get_resource(pDevice, IORESOURCE_IRQ, 0);（获取的是中断号）
				printk("pkres->start = %d, pkres->end = %d\n",pkres->start, pkres->end);
		2·初始化注册中断
	ret = request_irq(pDevice->resource[0].start, keyhandler, pDevice->resource[0].flags, "key-int", (void*)&keypara);	
	中断函数默认就会禁止掉其他中断，不允许中断嵌套。例如你在中断函数中{HAL_delay(5)},这个delay本身就是中断，所以他会卡死到这里。

***********************************************并发竟态*******************************************
		通过1个全局变量的值解决竟态可以吗？？（看着没啥毛病，但是由于时间片的分配会影响的）程序的执行可能会被打断

		hello_open()		-----这个函数其实不实现也可以，平时打开文件打开的是设备文件，open并不是只通过这个函数打开的文件
		{									hello_opne的作用本质是实现设备的初始化可以在此函数中添加  pwm_init();
			if(flag==0)						这才是这个open函数的作用，如果只是函数中prink一下的话，这个函数没啥用，可以不定义的
			{								hello_open更像一个初始化函数
				现在没人打开，你可以用
				flag=1；把它置1，防止另一个进程也调用---但是如果cpu给他的时间片到了，同时另一个进程在它置1之前也进行了调用。就出错了
			}else
			{	现在有人已经打开了，不能使用}
		}
	problem：1个程序运行时flag准备推出显示0，在推出时，时间片刚好完了，此时还未正常推出，另一个程序不能继续open的。

		原子操作：（每个函数就是一条命令，一定会执行完成，不管时间片还有没有都能正常 执行完运行）
			之前的程序不会被切断


	自旋锁：在操作全变变量的过程前后加锁解锁*****保证操作全局变量的过程即使被打断，别人也没办法操作这个全局变量，
		对共享资源枷锁，保护共享资源（注意只是在全局变量操作前后加解锁，不能中间隔得太远，不然别的程序获取不了锁，会卡死）
****如果只用1个全局变量，不用锁，open一个文件后，还来不及修改全局变量，另一个进程也可以打开这个文件，这样就会有问题了
	$:gnome-system-monitor---任务管理器
	信号量要点：在驱动中全局变量定义：struct semaphore mysem;
	在驱动初始化函数中初始化信号量：sema_init(&mysem, 1);
	在hello_open函数中：down_interruptible(&mysem); //获取信号量，sem-1
	在hello_close函数:up(&mysem);  // 释放信号量 sem+1
	信号量的值只有1--0  二值信号
	如果有2个打印机（2个资源），可以信号量初始为2，第一次操作可以用其中1个打印机，第二次用第二个
	互斥体使用与信号量类似


	阻塞非阻塞：（看drive目录中应用程序的对比）
		针对非阻塞，驱动怎么实现
		初始化时init_waitqueue_head(&myqueue);初始化队列头
		睡眠与while1：程序阻塞的时候是睡眠，cpu不会升高，只会卡住程序
		while1cpu升高，卡死程序
		sleep是延时运行（程序也在运行，滴答定时器，中断弄得）
	【】【】睡眠与sleep函数不是1个东西
	**********select的驱动poll**************
		select--->需要定义file_operations里面的poll函数

		读事件是fd即/dev/hello0 的读事件，（读事件是*需要fd进行读*的事件，有人往fd里面写东西就会触发fd的读事件）
	异步通知：设置支持异步（信号驱动的异步io）
			底层检测的 异步链（队列）有没有 这种信号发出来 然后调用相应得中断处理函数
等待队列：
		队列+进程调度机制   实现 异步事件通知机制+信号量
	
**********************************设备驱动中的阻塞与非阻塞*****************************************
	阻塞：想要对设备操作时不能操作，则阻塞，进程睡眠。
	满足可操作条件后，内核唤醒，进程继续执行。
	非阻塞：不能操作时，不会睡眠立刻返回结果。


****************************************python*****************************************************
	大蟒蛇 爬虫 遵循GPL协议：你用我的语言就必须开源	
	pip安装更换为国内源：
		matplotlib：图形化界面库
		numpy：专门做张量运算的/矩阵运算的库
		opencv-python：python的opencv库
	pip install requests b
	pip install numpy -i https://mirrors.aliyun.com/pypi/simple/
	pip install matplotlib -i https://mirrors.aliyun.com/pypi/simple/
	pip install opencv-python -i https://mirrors.aliyun.com/pypi/simple/
	例如：pip install sklearn -i https://mirrors.aliyun.com/pypi/simple/

	豆瓣 ：https://pypi.douban.com/simple/ 
	阿里 ：https://mirrors.aliyun.com/pypi/simple/ 
	中国科学技术大学：https://pypi.mirrors.ustc.edu.cn/simple
	清华：https://pypi.tuna.tsinghua.edu.cn/simple
			
	缩进要注意，不能前面加空格，可以加table。一个.py文件写完直接就能运行		
	first = int(input("input the first num")) #强转直接在前面加int后面括起来，不然接收的str	
	from tkinter import * # 图形化界面包		
	#创建widget窗体
	root = Tk	
	# 设置宽高，设置的时候乘号是’x‘字母，括号带双引号
	root.geometry("320x240")
	# 创建lable控件，text内容是s
	lb = Label(root,text=s)
	# 将lable放进去
	lb.pack()
	# 防止程序退出
	root.mainloop()		
********************************************python***str**************************************8			
		#mystr = "0123456789"
		#for i in range(5,10):   # 左闭右开打印56789 \t结尾
		#   print(i,end="\t")
		#print(mystr[0:5])   #打印0-4位置
		#print(mystr[0:])    #print all
		'''
		print(mystr[-1:])   #只打印9
		print(mystr[-1::-1]) #前面第一个给-1代表逆序截取
		print(mystr[-1:4:-1])  #逆向截取
		# str_name[起始下标：终止下标：步长]
		print(mystr[0::3])  #正向跳跃截取0369
		print(mystr[0:9:3])  #只有036,9对应的字符打不出来
		print(mystr[-1::-2])  #逆向跳跃截取
		print(mystr[9::-3])  #逆向跳跃，0也能打印出来
		print(mystr[9:0:-3])  #963，不包含0下标对应的字符
		'''


		'''
		myStr = "jackkkk"
		print(myStr)
		print(myStr.capitalize())   # 不能改变原字符串，第一个字母大写输出
		print(myStr.upper())    # 不能改变原字符串，只是以大写输出
		#newstr = myStr.center(8,"*")    #打印到中间
		newstr = myStr.upper()      #不能改变原字符串，但是可以将大写赋值给另一个字符串
		print(newstr)
		print(myStr.count("k"))       #k字符出现的次数
		print(myStr.count("k",0,5))     # jackkk 还是左闭右开
		'''
		'''str = "01\t234\t56789"
		print(str.endswith("3",0,4))    # true 01234 还是左闭右开，不算4
		print(str)
		print("1234567890")
		print(str.expandtabs(tabsize=8))   # 空格转tab table默认是8个\t'''


		'''
		#find方法：index方法
		str = "0123456789"
		print(str.find("3465"))      # 返回子串的下标位置，如果子串不存在返回-1
		print(str[str.find("345")])
		# print(str.index("3465"))    # 正常返回子串下标，如果子串不存在抛出异常
		'''

		'''
		mystr = "1234mk55"
		print(mystr.isalpha())  #都是字母？
		print(mystr.isdigit())  #都是数字？
		mystr = "FFF"
		print(mystr.isupper())  #都是大写？
		print(mystr.islower())  #都是大写？
		mystr = "a   "
		print(mystr.isspace())  #都是空格？
		'''

		'''
		mystr = "nihao"         # 多个英文单词，每个首字母大写，其他字母小写的字符串就是title格式
		print(mystr)
		print(mystr.title().istitle())  #原串还是不会变的
		mystr = mystr.title()   #字符串转换过来
		print(mystr)
		'''		
		'''
		my2 = ["a","b","c"]
		mystr = "***"
		newstr = mystr.join(my2)  #
		print(newstr)

		mystr = "          as   d     "
		print(mystr.lstrip().rstrip())       # 截掉左边空格,然后再截掉右边空格
		print(max(mystr))           # 打印最大字符以ASCII比较
		mystr = "abcdddddefg"
		mystr.replace("b","4")      #原字符串都不会变，但是可以通过str = str.jjj去改
		print(mystr.replace("d","4",2))
		'''

		#mystr = "192.168.1.23"
		#list = print(mystr.split("."))  # 将原来的字符串截取不用的字符，以list接受

		#mystr = "33\n44\n33"
		#mylist = mystr.splitlines()     # 截取换行符
		#print(mylist)

		'''
		mystr = "len:213412"
		print(mystr.startswith("gi"))       # 是否以某子串开头
		if(mystr.startswith("len")):
			list = mystr.split(":")
			lenth = int(list[1])
			print(lenth)                    # 截取字符串某部分，并转化

		str = "NiHao"
		print(str.swapcase())           # 大写转小写，小写转大写

		'''			
********************************python***list************************************************************					
		
			'''
			l = [23, [1, 2, 3], 5, "xiaoming", 34, 54, 67]
			# print(l[-1])        # 打印列表最后一个

			print(l[:3:2])
			print(len(l))

			'''

			# 函数的封装,声明
			def mylist_trave(mylist):
				for i in mylist:
					print(i)
			'''
			mylt = [12,3.41,"helo",(1,2,3),[4,5,6]]
			mylist_trave(mylt) 
			'''

			'''
			if __name__ == "__main__":      # 整个python程序入口
				# 函数的调用，没有形参的类型
				mylt = [12,3.41,(1,2,3),[4,5,6]]
				mylist_trave(mylt)
			'''

			def mylist_print(mylist):
				for i in range(len(mylist)):        # range很重要，可以实现分行打印
					print(mylist[i])                # 这里i的类型是int型的。   for i in mylist  这里i是变化的mylist的成员

			def mylist_appen(dst,src):
				dst.append(src)

			if __name__ == "__main__":
				mylt = [1, 2, 3, 4]
				src = ["helo", "wrold"]
				mylist_appen(mylt, src)     #将src作为一个元素加进去[1, 2, 3, 4, ['helo', 'wrold']]
				mylt.pop()          #弹出最后一个元素
				mylt += src         #将src中元素一个一个加进去[1, 2, 3, 4, 'helo', 'wrold']
				print(mylt)         #****这些操作都会改变原来的列表
*********************************python的循环****************************************
'''
# 斐波那契数列
a = 1
b = 0
c = 0

n = 10
while n:
    if(n <= 0):
        return
    c = a+b
    a = b
    b = c
    n -= 1
    print(c,end=" ")
'''
def ysf(mylist,n):
    if(n == 0):
        return;
    count = 0;
    while len(mylist)>2:
        n = 2;

        if(count > len(mylist)):
             count = 0;
        while n:
             count += 1;
             n -= 1;
        del(mylist[count%len(mylist)])
    return mylist
if __name__ == "__main__":
    mylist = ["songjiang","sunwukong","caocao","lindaiyu","yangyuhuan","zhaofeiyan","likui","bajie","guanyu","xuyou","dianwei"]
    new1 = ysf(mylist,3)
    print(new1)

bt = tk.Button(text="click me",command=myclick)		设置1个按钮，按下按钮执行myclick，因为这个函数没有入参，所以调的时候也不用传入参数

************************************python***爬虫*********************************************
	豆瓣 ：https://pypi.douban.com/simple/ 
	阿里 ：https://mirrors.aliyun.com/pypi/simple/ 
	中国科学技术大学：https://pypi.mirrors.ustc.edu.cn/simple
	清华：https://pypi.tuna.tsinghua.edu.cn/simple
	
		requests安装********不能在直接进去的那个目录下安装，因为是adminstrate权限有问题
		；pip install keras -i http://pypi.douban.com/simple --trusted-host pypi.douban.com
		scrapy:网站级爬取，并发性能好，是个爬取框架，爬的时候往框架函数中填东西（配置）
		requests：网页级爬取，性能差，灵活
		scrapy -h:scrapy命令行
		scrapy cmd option args：cmd可换，一共有6种
			scrapy	startproject 	name 	dir	创建功能
			scrapy	genspider 	options name domain		创造爬虫
			scrapy	settings 	options		获取爬虫配置信息
			scrapy	crawl spider			运行爬虫
			scrapy	list				列出所有的爬虫
			scrapy	shell url			启用url调试
	
	演示网站：h
	import requests		关键字运用
	kv = {'q':'Python'}
	r = requests.get("https://www.so.com",params=kv)
	print(r.status_code)
	print(r.request.url)
	soup.title  #汤的title
	soup.a #汤的含链接的标签（只能显示第一个含连接的）
	soup.a.name #a标签的名字  soup.title.name
	soup.a.pqrent.name	#a父亲的名字
	soup.a.attrs  #标签a的属性信息，属性包含[class/id/href：链接]
**********************************类**************************8
class Cat:
	def __init__(self,new1,new2,new3):
		self.1 = new1;	# 给属性赋值
		self.2 = new2;
		self.2 = new3
		
	xiaohuamao = Cat(1,2,3)	
**************************************************************************************88
字符串处理函数：
	capitalize():将字符串第一个字符转换为大写
	center(width, fillchar)：返回一个指定的宽度width居中的字符串，fillchar为填充的字符，默认为空格。
	count(str, beg=0, end=len(string))：返回str在string里面出现的次数，如果beg或者end指定返回指定范围内str出现的次数
	endswith(suffix,beg=0,end=len(string)):检查字符串是否以obj结束，如果beg或者end指定则检查指定的范围内是否以obj结束，
										   如果是，返回True，否则返回False
	expandtabs(tabsize=8):把字符串string中的tab符号转化为空格，tab符号默认的空格数是8。
	find(str, beg=0, end=len(string)):检查str是否包含在字符串中，
									  返回开始的索引值，否则返回-1
	index(str, beg=0, end=len(string)):跟find()方法一样，只不过，如果str不在字符串中会报出一个异常。

	isalpha():如果字符串至少有一个字符并且所有字符都是字母则返回True，否则返回False
	isdigit():如果字符串只包含数字则返回True否则返回False
	isnumeric():如果字符串中只包含数字字符，则返回True，否则返回False（识别不出小数点，只能判断整数字符串）
	
	istitle():如果字符串是标题化的(见title())则返回True，否则返回False
	title():将字符串设置为title格式，说白了首字母大写。(且操作对象，凡是在字符串中有多个英文单词，会将每个英文单词的首字符大写)
	join(seq):以指定字符串作为分隔符，将seq中所有的元素(的字符串表示)合并成一个新的字符串(将list转换为string)	
	len(string):返回字符串的长度
	lstrip():截掉字符串左边的空格
	rstrip():删除字符串末尾的空格
	replace(old,new,[max]):把将字符串中的old替换成new，如果max指定，则替换不超过max次
	注意：max代表的是替换次数
	split(str="",num=string.count(str)):以str为分割符截取字符串，如果num有指定值，则仅截取num个子字符串
	splitlines(num=string.count('\n')):按照行分割，返回一个包含各行作为元素的列表，如果num指定则仅切片num个行
	startswith(str, beg=0, end=len(string)):检查字符串是否是以obj开头，是则返回True，否则返回False。
										   如果beg和end指定值，则在指定范围内检查。
	swapcase():将字符串中大写转化为小写，小写转换为大写	
	str[起始下标：终止下标：步长];左闭右开  
		起始下标：从0开始
				  -1：最后1个元素
		步长：正数向后跳跃；负数向前跳跃
***************************************************list*************************************		
	list.append()
	list.pop()	
	list的遍历：for
				range()
	list[起始下标:终止下标:步长]
	del(a[2])  删除a的第二个
		
	tkinter:Button(command=def_name,)通过command设置按钮的响应事件	
	包的调用
	'''版本1'''
	#from pack import pack_test     # 脚本调脚本里面的方法。脚本是个文件
	#pack_test.pack_func()           # 从包里面导一个需要的文件，调用的时候文件+"."+function名字
										#这里还可以将文件名字改为as file   file.function()也可调用函数
	'''版本2'''
	#from pack.pack_test import pack_func        #从包里面的那个文件导入文件中某个function可以将函数名字as 为fun
	#pack_func()						
		
																											   文件夹
	import cls 		类也可以导入然后供子类继承	，这里导入的是文件名。同一级目录下也可以直接导入，不在同目录也可以：from 面向对象 import myclass
	Stu k("jialei",99) 		#python里面实例化得用一个变量去接受，不能这样做	
	k = Stu();		上面是c++的写法	
		
		
	如果父类有相同的方法,子类会优先调用先被继承的类的方法。	
		
	要拓展父类的属性的时候，最后还要加super父类源有的属性，不然会提示原有属性不存在	
	def __init__(self,name,age,score):
	        self.score=score
	        super(Student,self).__init__(self,name,age)	
	私有属性，私有方法	
	print(p1.__dict__)				#将私有变量以字典方式打印，不然都不知道有哪些属性。类内的全局属性不打印	
	{'_People__sex': 'man', 'weight': 89}	
		_People__sex	一杠两杠属性
		_People__sayHello()		一杠两杠方法
	
	People.sum：类变量	
	class People():
			sum = 0
			def __init__(self,sex):
				self.sex = sex			#实例变量self.
				People.sum += 1			#People.sum也可以写成self.sum
				print('现在有%d个人。'%People.sum)	#类变量class.
	函数参数：
	以下是调用函数可以使用的正式参数类型：
		必需参数
		关键字参数
		默认参数
		不定长参数	*：元组  **：字典
		
		往文件中写数据，拿出来依然是数据：pickle包，
			不然存的时候都是转化为str，都不知道人家原来什么类型了。
		协议：0--写入字典使用
			  1--写入list时使用
		
		
		SSL：表示层加密的
		传输层：tcp/udp
		网络ip层：ICMP/IGMP跨子网通信（否则）  路由器：路由转发->下一跳
	进程线程：
		进程：在普通函数中打印出来的getpid()与主程序中打印出来的getpid一样
		p = Process(target=f,args=('Jack',))f函数就是个进程，类似linuxc中的线程
		创建以后要p.start()开启进程，回收用p.join（）
********************************************人工智能*****************************
	机器学习：numpy，matplotlib
		算法：
		监督学习：线性回归，逻辑回归（有人教你，训练接自带标签）
		无监督学习：聚类（自己乱学，自己分类，没人教，训练集不带标签）
		SVM：支持向量机
		强化学习：有奖惩机制（环境反馈）作为输入，输出结果可以作为输入
	opencv：
	TensorFlow：

	深度学习：
		卷积神经网络：
		案例：语音识别
		百度AI平台使用
			人脸对比，语音合成，语音识别
		彩色图片存储起来就是三维（RGB)的，每个每个数据都是二维（图片横款）的，二维的每个数据都是一维的
					相当于三张图片叠加（R通道）（G通道）（B通道），每张图就是纯二维的图片了
	语音合成-->将合成的语音播放（pygame/pyaudio）
	语音合成--->文字转语音（存起来双击（调用语音播放软件）可以播放）--->百度ai-->短语音python合成
	语音采集——->pyaudio（官方有实例文档）-->将语音采集为文件存起来双击（调用语音播放软件）可以播放
	语音识别-->声音文件在屏幕打印出对应文字-->百度aipspeech
	语音播放-->pygame.mixer--->直接调用函数（打开文件）就可以播放不用打开别的软件

	图片显示-->不通过直接双击（用tkinter去显示）
		img_open = Image.open("1.jpg") # 将jpg照片转为img图片
		photo = ImageTk.PhotoImage(img_open)
		img_label = Label(root,imag=photo)
	图片采集（调用摄像头）：CV2库退出时可以保存1张图片信息
	图片中眼睛采集：还用CV2库
	人脸对比：import requests 	import base64发图片信息给百度让它给你分辨你读取返回值的对比度95%就说明是同1个人照片
	https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&client_id=%s&client_secret=%s'%(API_Key,Secret_Key)
*****************************************STM32*******************************************
stm32-----------cortex-m(arm)系列
arm处理器--------cortex-a------application应用型产品
				coetex-r-------realtime-----汽车级，军工产品
				cortex-m--------mcu --单片机
	stm------st公司---microcontroller微控制

单片机使用：1.寄存器
			2.库函数
			3.HAl--硬件抽象层
keil5----------mdk5 v5（必须自己安装芯片包）
keil4-------默认支持很多处理器

cubemx  ---ioc---ioconfigration
stm32f0xx_it.c：中断相关的文件
		void TIM6_DAC_IRQHandler(void)
		中断处理函数中可能有很多触发方式，要选择对应的触发函数进行函数的定义，触发之后干什么
cubemx与keil联合编程的时候，只能在main.c指定区域进行指令的书写，不能随便往project中加东西
cubemx：
	sys->debug serial wire:启用下载调试口（不是uart）
	串口每次采样16次  8M的串口时钟-----分频得到--->115200x16（1.7M左右）则波特率就成了115200（其实每次都是采样了16次的）除数4.4整数小数都要处理一下
	打印函数printf的底层其实调用的futc函数，把它实现了就好了。
	spi:时钟是主机产生的，每个spi周期传输1bit数据
		主机主动拉低cs，表示我要与某个spi设备进行通信

		LCD模块的通信（芯片之间的通讯）
		高速、串行（只有2根线是收发）、全双工、同步总线（总线就是多对多，usart就不是总线1对1）
		极性：在未开始通信前（或者说空闲状态下）的sck的电平0/1  可以设置
		相位：0--->前沿采样后沿输出    1--->前沿输出（发送）后沿采样（获取）（通过这个双方同步）（沿：上升沿或下降沿）根据sck的沿
		速度：目前最快3.4M/s  输入口速度48M，所以要预分频。确定波特率
		First bit：LSB/MSB
		主机驱动mosi信号----采样miso信号
		spi的通讯双方的极性与相位要一致（配置）
	编程时每个spi模块都有自己的一套寄存器，就地址不一样，名字功能都基本一样
		配置conr：开启中断|使能spi|发完中断？|设主机还是从机|极性|相位|先lsb|msb
		baud：bus总线过来的时钟 / 分频因子 = baud
		状态reg：接收完成flag（接收缓冲区满）| 可以发送（发送buf空）

	adc： 
		adc的接收数组数据类型必须是volatile的。不然他不会变化了
		stm32代码换行的时候要\r\n，只有\n有时候不能换行的
	位数是soc内部的模块，与管脚无关，每个adc管脚都是n位的分辨率。soc的adc有几个模块，多少通道数有限，如果都启用，最多有几个
		转换速率：完成1次ad转换的v
		量化误差：由于ad的有限分辨率引起的误差
		输入为0的误差：模拟输入为0，数字已经是00000011了		
		满刻度误差：1022时已经采集到5v
		线性度：最好就是一条斜线不弯曲
	dma：寄存器的值直接读到变量（变量在内存中）中。不经过cpu。只有有限的通道数，不是无限的（有指定的方向谁->谁）
	用于外设与主存储器（内存）之间快速的交换数据，提高了CPU的利用率。
	中断的分析：都在fxx_it.c中存着所有的中断函数，要跳寻找需要更改的最终的中断处理函数
	timer中断的时候，触发中断的是update事件，隔1s就会触发1次，所以隔1s就会调用1次timer的中断处理函数（timer开启start后就会不断有update事件）
	串口的中断回写：串口只有收到数据才会回写，所以需要有recv函数收到东西才行，所以recv需要在while（1）中，才能接受所有的接收消息事件-->触发中断void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)重写这个函数

	***函数以外不能直接调函数，函数的调用要在函数内部。

	调试：
	1Word = 4byte
	halfWord = 2byte

	HAL_ADC_Start_DMA(&hadc1, (uint32_t*)&adc_val, 4)相当于4次传输8字节
	DMA的memory中设置为Halfword  x  4

	void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
	{
		 HAL_UART_Transmit(&huart1,&temp,  1, 1000);//不需要临时变量存了，直接读uart的接受buffer
		 HAL_UART_Transmit(&huart1,huart1.pRxBuffer，strlen(huart1.pRxBuffer), 1000);这种写更好
	}

*************************************************************************************************
	tar -czf  	c--create打包并不会压缩  z--gzip压缩  j-bzip2压缩   f-指定要处理的文件名    - x解压
	-v显示解压缩过程      											f放最后面+文件名







































































*************************************************linux启动流程*******************************************
	BootLoader：boot初始化硬件,关闭中断看门狗，
	load加载内核到内存，跳到内核代码起始位置
	kernel：自解压、初始化编译进内核的驱动模块、挂载fs，执行initrc（配置用户环境与执行服务进程）


************************* 安装用于编译源码的交叉编译工具链 ***************************************************
1. 设置VMWARE 和WINDOW的共享  
   虚拟机 ->  设置 ->选项 -> 共享文件夹 -> 添加共享目录。  选择总是启动
   成功后能在  /mnt/hgfs 下看到目录。
   如果不成功，可能原因：
     a  vmware tool需重装。
     b  重装一下VMware,或选新版本的vmware安装。
     c  拷贝别人，安装好的过来。（有可能ubuntu有问题）
2. 拷贝gcc-4.6.4.tar.xz 到linux某目录下,并解压tar -xvf gcc-4.6.4.tar.xz
   进入解压后的gcc-4.6.4/bin   输入pwd 查看当前路径（如/home/farsight/gcc-4.6.4/bin)
   输入 export PATH=$PATH:/home/farsight/gcc-4.6.4/bin       
   注意：这种方式只是当前有效，重启后消失。
     想永远有效，需追加该行到当前用户启动脚本（~/.bashrc）的末尾，方法： 
       $ vim  .bashrc
	     在最后一行下面添加
	     export PATH=$PATH:/home/farsight/gcc-4.6.4/bin
	     :wq 保存退出
	   $ source .bashrc
   切换到别的目录， 输入arm-n ，按tab键能补全为arm-none-linux-gnueabi- 说明OK

****************************************圈复杂度***************************************************8
减少1函数中的判断if  switch  （不可以if if if 连这写）
	将这个函数中的需要判断的部分提取出来重装函数。降低1个模块的复杂度
	case里的东西写成int arr【10】；循环对比
www.lizard.ws  代码拖进去，可以看代码圈复杂度
sudo apt-get install python-pip
pip install lizard
$:lizard weekday.c 可以显示圈复杂度

公司项目分工--谁分工---周期多久---公司技术部人数--试用期多久，试用期薪资
职业规划：3年以后可以有自己的小组，独立完成项目。希望以后能转硬件，希望能做产品架构师

***************************V4L2 video for linux 2***************************



**********************总复习********************
针对指针判空：if(p == NULL) 或 if(p == 0) 其实NULL 就是0

++i 与 i++与编译器有关

或者用n>>1的方法做，不要用1 << 的方法
正整数中1的个数 ：
public class Solution {
    public int NumberOf1(int n) {
        int num = 0;  
        while (n != 0) {  
            n = n & (n - 1);  
            num++;  
        }  
        return num;  
    }
}
负数右移的时候左边补的是1；-4 / 2 = -2
正数右移左边补的0

老鼠试毒药1000瓶，给瓶编号1100 1101 1110 ....

微软飞机油箱

int main(){
get(arr);			输入字符数量太多的话
printf("%s",arr);
return 0;        程序结束的时候会回收资源，发现越界
}

栈爆掉了？？
局部变量不要写太大。
int main()
{
	int arr[100000000];  消耗的是栈空间   
	struct{int * arr；}变量中数据说如果太多，要自己分配内存
}

strncpy(p,q,x);  x要写sizeof(p) -1;防止目的p越界
		目标，源		不能写strlen(q)-1.如果p比q小，这就越界了

mkfifo同1pc的不同进程间。共享内存效率最高，消息队列（先进先出、按信号类型存取）
***********************************函数类型*****************************8
signal(int type,void(*pFun)(int arg))-----
void (*)signal(int type,void(*pFun)(int arg))(int);
void (*signal(int type,void(*pFun)(int arg)))(int);  signal返回函数指针，不是返回一般的char*指针（看着就很麻烦，所以要typedef）


typedef void (int,int) ABC;
typedef void ABC（int,int）;       

typedef void (*handle_t)（int）;   函数指针，定义这句话的最重要的目的就是下一行写的时候简单点，没别的用了，因为咋们要调用的函数就是这种类型的
handle_t signal(int sig,handle_t handlefun);


typedef int (*pfunc)(int,int);
int function(int a,int b)
{
	return a+b;	
}
int mytest(int a,int b,pfunc name)
{
	return name(a,b);
}
int main ()
{
  	printf("%d\n",mytest(10,5,function));
}
*********************************************************

系统移植uboot指令：md----------------memory display

#define API() printf("%s %s %d",__FILE__,__FUNCTION__,__LINE__)

*****
char *getstr()
{
	char * tmp = "123"; 程序结束才会释放“123”
	return tmp;  返回常量区的地址，常量区不会释放
}
可以得到“123”的地址。

char *getstr()
{
	char p[] = "123";   函数分配空间，函数结束空间释放
	return p;			局部变量地址，不可以返回。
}
**************

那么要是想让 程序 跳转到 绝对地址是 0x100000 去执行
    #include <stdio.h>
    typedef  void (*ABC)();   函数类型指针
    void swap()
    {
        printf("asda\n");
    }
    int main()
    {
        printf("%p\n",swap);
        ( (ABC) 0x40057d  )  ();
           类型   地址       参数
        return 0;
    }

**********************8结构体定义同时赋值
struct file_operaters var = { 部分初始化
	.name = asdsa,
	.age = 12,
};

struct stu p = {1,2,3,4};全部初始化，定义同时才可以这样

结构体传参：
	函数参数是栈段分配的，传结构体指针因为指针占用的内存小
	如果值传递，系统得在栈中分配很大的空间。所以不管你改不改结构体中的内容，都建议传递结构体指针。
	参数是栈段分配的
	内存使用原则：小栈大堆

位段结构体：
	struct data{
		uint year:5;
		uint month:4;
		uint day:5;
	};     给每个参数规定占位，不浪费
结构体默认4字节对齐，位段结构体也是4字节对齐

gcc -L：库路径     -I：头文件路径 -l：库名

1个字符串往另1个字符串里面赋值的时候注意“\0”也要复制过去；
可以直接str[j] = mystr[i];  i指向mystr的最后1个字母后面的“\0”

***************************************注意**************************************************
1. char a[10]  = {“hello”};
a++;  里就会报错,因为a是char[]类型的，它表示的是这个数组的首地址和第一个元素的地址，不能直接去操作a++去移动地址，
如果想移动可以char *p = a；然后再操作p，p++这样是完全正确的。
因为a是数组名,不能进行赋值操作,所以也不能++操作,如果对数组名进行了赋值操作就会报
while(*p != '\0')  以后注意尽量不要直接判断p是否为NULL结束，应该*p取值取判断p指向的内存的数值取判断字符串是否到底了

数据结构：
	哈希表很重要。
	顺序表大小固定，只能在现有空间中插入，数组插满就不能再插入了

	线性表中至少有1个元素，错的。空的线性表也可以的。

	根据中序 确定可能的 先序与后序顺序，技巧：看中序的较小的树
		分析g-f分析他的排序可能，排除答案中的结果。
	先序与后序中2个节点怎么摆放合适


两个队列实现栈：

void CStack<T>::appendTail(const T& node)//实现栈元素的插入
{
	//数据的插入原则：保持一个队列为空，一个队列不为空，往不为空的队列中插入元素
	if (!q1.empty())
	{
		q1.push(node);
	}
	else
	{
		q2.push(node);
	}
}
T CStack<T>::deleteHead()//实现栈元素的删除
{
	int ret = 0;
	if (!q1.empty())
	{
		int num = q1.size();
		while (num > 1)
		{
			q2.push(q1.front());
			q1.pop();
			--num;
		}
		ret = q1.front();
		q1.pop();
	}
	else
	{
		int num = q2.size();
		while (num > 1)
		{
			q1.push(q2.front());
			q2.pop();
			--num;
		}
		ret = q2.front();
		q2.pop();
	}
	return ret;
}

☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞☞
查找里面的分块查找：
	分块有序.二维数组横有序纵有序。从右上角或左下角
	遍历，移动坐标指针。

*****重要点
char *strcpy(char*dest,char *src)
{
	return &dest;错，不能返回入参的地址
}

char *strcpy(char*dest,char *src)
{
	char * p = str;
	return dest;可以返回入参
}

链表逆序：
	给原来的链表p--q指向第一个第二个节点；(保护起来)
	ph->next = null;第一个节点拿出来，这个数据也并没有破坏
	while{
		p->next = ph->next;
		ph->next = p;   头插法
		p = q;q++;
	}

io：
	errno其实是个全局变量。（在errno.h）发生异常会设置error值
	perror：根据error值打印对应的错误信息。
	switch（error）  case 2：打印“要打开的文件不存在”
	strerror(error)；根据传入errno return 对应的字符串
	
	标准io：方便移植，只要#include<stdio.h>就好了
	文件io：是内核里面的函数，移植困难

	ls  ----->通过stat（&st_size）  查看var.st_size

	库就是可执行的二进制代码，可被OS载入内存执行，windows与linux库不兼容
	动态库运行时会调用库，如果库不在了，程序不能正常运行
	静态库方便移植，生成的代码体积小。不需要库
	动态库不方便移植，生成的代码体积小，需要下载库。

	-lpthread  库名。他是第三方库。	最初linux没有线程，99年才被引入的。
		linux内部的库都在环境变量中了，库也不需要-l...
		
		1.把库拷贝到/lib  或/usr/lib就不用加-L 库位置了
		系统会在这里自己找库

		2.在.bashrc改环境变量 

	点亮灯：open设备文件ioctl点灯
	获取传感器值：open设备，read读值
	操作类的用ioctl  读写read write

进程线程：
	进程：程序执行，资源管理最小单位。
		每个进程有个虚拟0-4g内存空间，每次运行1个进程，
		系统就要分配1个0-4g虚拟内存
	申请的内存没释放：内存泄漏

	C++的智能指针：自己new了，不用程序员自己delete。后来添加的功能
	QT：父对象死亡，子对象中内存自动释放。

	 .bss + .data：静态区==全局变量+静态变量

	 交互进程：shell  敲个命令回应一下
	 进程都是被进程创建出来的。看linux进程树，
	 第一个进程init，分支分支分支形成多个进程

	 批处理进程：gcc arm-none-linux-gnueabi-gcc
	 需要预处理-....

	 守护进程：系统起来他就启动，系统关闭它才关闭
	 	TTY:?   说明它不属于某个终端 
	 	tty：当前进程的控制终端
	 	自己是自己进程组组长，会话组组长

	 进程停止态：  其实是暂停状态
	 死亡态： 也是僵尸态	

	 task_struct 描述进程的状态的结构体

	 1个cpu多个任务，那个任务抢到cpu那个任务执行，时间片轮转

	 sigstop--->sigcont 被暂停--被继续

	 用户模式，普通函数运行  系统调用  会进入到内核模式
	 相应得cpu状态从user--svc

	 创建子进程，父进程退出--setsid会话--改目录掩码--关闭文件描述符

	 线程：pthread_detach(pthread_t th);	 		将线程设置为游离态  detach：使分开
	 		退出的子线程会被系统回收线程资源。相当于linux内核调用的pthread_join();
	 		成功返回0，失败返回错误号errno。

	 共享内存：内核只有1个，但是不同进程都可以通过映射访问这个内核。 所以就可以实现进程间通讯

	 shmget 创建   
	 shmat  映射
	 shmdt  取消映射
	 shmctrl 删除
	 共享内存需要同步互斥机制 配合sem


网络：
	传输层：
	保证数据可靠传输--
	语音与视频用的udp
	网络层：路由用的

服务器:
accept 之前3次握手 已经完成的
accept 只是为了获得新创建的套接字的
ser能收能发     cli能收能发

3次握手
1：cli->我要发
2:ser->我可以收-->我也要发
3：cli->那我也收

4次挥手
1：cli我不发了
2：ser我不收了  你等下我把我的数据发完
3：ser我也不发了 
4：cli 反正你都发完了，我也不收了


端口号：寻找对应的进程
字符串传输时不需要转换。
listen：将socket主动--->变为被动套接字
服务器ip与端口必须是固定的，必须bind
	wireshark抓包


epoll：红黑树方式
	epoll_create(int size)；创建epoll句柄epollfd，监听数目。


	
	int  epoll_ctl(int  epfd,  int  op,  int  fd,  struct  epoll_event   *event); 
					ep句柄      操作命令   操作的fd            包含fd的结构体
								EPOLL_CTL_ADD
								EPOLL_CTL_DEL
	这个函数调用的时候其实已经初始化event了，是读事件还是别的事件在event结构体里面说明了。
	select（maxfd+1,&rset,NULL,NULL,NULL);select函数才确定的事件类型


	int epoll_wait(int epfd, struct epoll_event *eventarr, int maxevents, int timeout);
								从内核得到事件集合			1次监听几个   超时时间  
	
	epoll流程：
		socket+bind+listen得到监听套接字socketID
		创建epollfd
		根据socketID创造struct epoll_event event
		将刚才用socketID创建的结构体EPOLL_CTL_ADD放进epollfd
		while（1）
		{
			struct epoll_event eventArr[10] = {0};
			ret = epoll_wait(epollfd,eventArr,10,15000);
			返回值<0说明失败
			返回值 = 0，超时，continue；
			否则直接遍历eventArr数组
			{
				if(EPOLLIN == eventArr[i].events)
				{	
					//是监听套接子的事件
					if(socketID == eventArr[i].data.fd)
					{
						getLink(eventArr[i].data.fd,epollfd);
						int getLink(int socketID,int epollfd)
						{
							struct sockaddr_in addr;
							newid = accept(socketID,(struct sockaddr*)&addr,&addrlen);
							新的套接字连接上本服务器了
							printf("server is connect by ip:%s,port:%d\n",inet_ntoa(addr.sin_addr),ntohs(addr.sin_port));
							printf("newid = %d\n",newid);
							要添加这个新的套接字，又得把他弄到一个结构体里面然后放进epollfd中
							struct epoll_event event = {
								.events = EPOLLIN,
								.data = {
									.fd = newid
								}
							};
							epoll_ctl(epollfd,EPOLL_CTL_ADD,newid,&event);
							return 0;
						}
					}else //是别的读事件
					{
						duevent = eventArr[i].data.fd;
						recv(duevent,buf,1024,0);
						printf("%s",buf);
						ret = send(duevent,buf,strlen(buf),0);
					}
				}
			}
		}

	需要监听的文件描述符放到1个链表中
	线程池---

	多线程/进程并发：适用于长链接

	select：适用短连接。ex：浏览网页

	广播：不管你想不想收，我都给你发过去了，反正传到你的传输层了
	组播：加到我组里面你才能收到。没加进来，在数据链路层就丢掉了
		群聊--不让别人看。就部分人看


c++：

			不要改人家名字
	extern C：还按照c的方式编译。不然你按照c++的方式编译，add被命名成了add_int_int，再调用时找不到函数了就


	const：定义只读变量 生产
	define  给常量取了个别名字

	类内函数用const-----本质是const修饰的this指针
	所以this指向的内容不能被更改

	mutable：const修饰的又可以被修改了

	封装：将想隐藏的隐藏起来，想暴露的暴露出来（给你接口）


	对象大小：
		空类：1字节大小（区分不同对象）
		demo里面1个int 1个static int sizeof（demo）  4
		编译的时候就分配好空间了，不在分配对象的时候分配
					static在静态区
								sizeof（变量）4
	

	深拷贝浅拷贝

	static：
	修饰局部变量
	全局变量
	普通函数 
	类成员  成员属于类


	菱形继承：用虚继承解决问题（D里面有2份A）

	重写：子类与父类函数 同名同参通返回 

	多态：同一指针变量（父类指针指向子类对象） 调用同1个虚函数，产生的结果不同

	联函数。减少栈的使用。代码量，函数在调用处被展开。逻辑简单
	编译时展开

	宏预编译时展开，简单的文本替换

	struct与class

	static成员变量的使用，必须是public，不然外面调用不到了

	c++的空类，默认会产生，默认构造、拷贝、析构、取址、赋值运算符函数

	构造有参数可以重载，析构不能重载，没参数

	构造函数public外面才可以调用

	深浅拷贝：

	自己写个string类。自己写个vector数组类：实现构造析构赋值

	什么是多态。

	虚函数怎么实现的？虚函数表---重新放个函数地址

	










































