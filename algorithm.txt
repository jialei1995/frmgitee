------------------------------------1----------------------------
//多项式加 乘计算
//设计存储结构体

typedef struct{
    int cnt;//多项式有几项
    int array[100];//每项两个数字--系数+幂
}Polynomial;

//读入多项式
Polynomial ReadPoly()
{
    Polynomial input;
    memset(input.array,0,100);
    int cnt;
    int xishu,mi;
    int i=0;
    cin>>cnt;//多项式中分式个数
    input.cnt = cnt;
    while(cnt--)
    {
        cin>>xishu>>mi;
        input.array[i] = xishu;
        input.array[i+1] = mi;
        i+=2;
    }
    return input;
}
Polynomial Add(Polynomial p1,Polynomial p2);
//多项式相乘
Polynomial Mult(Polynomial p1,Polynomial p2)
{
    Polynomial mul;
    memset(mul.array,0,100);
    mul.cnt=0;
    Polynomial tmpmul;//存储当前p1中此项*p2中所有项的结果
    int index=0;
    for(int p1head=0;p1head<p1.cnt;p1head++)
    {
        index=0;
        tmpmul.cnt=0;
        memset(tmpmul.array,0,100);
        for(int p2head=0;p2head<p2.cnt;p2head++)
        {
            tmpmul.array[index++]=p1.array[(p1head*2)+0]* p2.array[(p2head*2)+0];//系数相乘
            tmpmul.array[index++]=p1.array[(p1head*2)+1]+ p2.array[(p2head*2)+1];//指数相加
            tmpmul.cnt++;
        }
        mul = Add(mul,tmpmul);//每次算完将结果ADD到返回值中
    }
    return mul;
}

Polynomial Add(Polynomial p1,Polynomial p2)
{
    int p1head=0,p2head=0;
    Polynomial sum;
    memset(sum.array,0,100);
    sum.cnt=0;
    int sumindex=0;
    while(p1head<p1.cnt && p2head<p2.cnt)//相加的时候按照幂从高到低扫描
    {
        if(p1.array[(p1head*2)+1] > p2.array[(p2head*2)+1])
        {
            sum.array[sumindex++]=p1.array[(p1head*2)+0];
            sum.array[sumindex++]=p1.array[(p1head*2)+1];
            p1head++;
        }else if(p1.array[(p1head*2)+1] < p2.array[(p2head*2)+1])
        {
            sum.array[sumindex++]=p2.array[(p2head*2)+0];
            sum.array[sumindex++]=p2.array[(p2head*2)+1];
            p2head++;
        }else//相同幂的系数相加，指针都向后偏移
        {
            sum.array[sumindex++]=p2.array[(p2head*2)+0]+p1.array[(p1head*2)+0];
            sum.array[sumindex++]=p2.array[(p2head*2)+1];
            p2head++;
            p1head++;
        }
        sum.cnt++;
    }
    if(p1head == p1.cnt)//说明p2还有数据
    {
        while(p2head<p2.cnt)
        {
            sum.array[sumindex++]=p2.array[(p2head*2)+0];
            sum.array[sumindex++]=p2.array[(p2head*2)+1];
            p2head++;
            sum.cnt++;
        }
    }
    if(p2head == p2.cnt)//说明p1还有数据
    {
        while(p1head<p1.cnt)
        {
            sum.array[sumindex++]=p1.array[(p1head*2)+0];
            sum.array[sumindex++]=p1.array[(p1head*2)+1];
            p1head++;
            sum.cnt++;
        }
    }
    return sum;
}

void PrintPoly(Polynomial pp)
{
    cout<<"sum cnt="<<pp.cnt<<endl;
    for(int i=0;i<pp.cnt;i++)
    {
        cout<<pp.array[i*2+0]<<" "<<pp.array[i*2+1]<<"---";
    }
    cout<<endl;
}
int main()
{
    Polynomial P1,P2,PP,PS;
    P1=ReadPoly();
    P2=ReadPoly();
    PS=Add(P1,P2);
    PrintPoly(PS);

    PP=Mult(P1,P2);
    PrintPoly(PP);
    return 0;
}
----------------------------------------------2---------------------------------------------
在数组边界建立哨兵：
例如：在数组中查询是否存在K
正常的做法:
for(i=0;i<size;i++)
{
	是否当前位置==K;
	返回当前位置；
}
建立哨兵的做法：
给数组0位置赋值K
array[0]=K;
for(i=size-1;array[i]!=K;i--)
{
	return i;
}
这样做肯定有返回值，如果返回值是0，说明数组1~size-1位置都没有K



-----------------------------------------------3--------------------------------
利用栈中序遍历二叉树：
void InorderTraversal(BinTree BT)
{
	Bintree T=BT;//临时指针指向根节点
	Stack S = CreateStack(MAXSIZE);
	while(T || !IsEmpty(S))
	{
		while(T)//一直压栈左子树，直到当前节点没有左子树
		{
			push(S,T);//第一次碰到
			T=T->left;
		}
		if(!IsEmpty(S))
		{
			T=pop(S);//弹出栈顶数据，第二次碰到某节点
			printf("%d--",T->data);
			T=T->right;//访问右子树
		}
		
	}
	
}


由两种遍历序列确定二叉树的时候必须有中序序列才可以。
