qmainwindow（菜单栏，工具栏）与qdialog（对话框）都是继承qwidget，
qwidget的父类是所有对象的祖宗QOBJECT
QApplication a(argc, argv);//应用程序对象，有且只有一个
myWidget w; //实例化窗口对象
ctrl+shift+↑/↓ 将当前行移动到上方或者下方
同名的.h与.cpp切换，按键F4
选中多行，按ctrl+i自动对齐多行
查看帮助文档：打开bin文件夹下的assistant.exe 可以直接打开帮助文档
Qdialog：对话框（里面一般按钮较少，一般用于设计登陆页面啦、出错界面、下一步界面）
.pro中的target=test生成的exe的名称就是text.exe
Q_OBJECT 有这个宏表示允许使用信号和槽机制
函数声明与定义中只有1个里面允许有默认参数=0...
	btn的op：settext（“设置文本”）；
			setparent（this）；-------直接Qpushbutten * btn = new Qpushbutten（“文本”，this）；设置到对象树中
			move（100,100）；坐标从左上角开始数
			resize（100,100）；

	qt里面私有属性里面一般都是qpushubutten * btn；然后在构造函数中new出来的
	也可以在类里面直接QPushButton btn;在构造函数中settext，setparent

	窗口设置标题直接：setwindowtitle（“窗口标题”）；
	设置固定的窗口大小：setfixedsize（600,400）；
	调整窗口大小。直接resize（600,400）；其实可以this->resize()。也可以默认直接resize就可以。

	qDebug（）<<“sadasd”；
	或者qDebug（“sadasdd”）；自动换行的
对象树，创建的时候由上至下，析构的时候由下至上，只要是下级属于上级的对象，析构的时候父对象会帮你析构
子对象的析构函数自己还是得去实现，只是这个函数的调用是父对象去管理的，并不是它帮忙实现的。

                也可以写成&Mybut::clicked,this,&Mybut::close，必须是类名，如果子类继承父类自然信号函数也继承了。
				不可以直接写对象或者对象地址，必须写类::信号
	connect(&btn,&QPushButton::clicked,this,&QPushButton::close);
			信号发出对象地址				信号接收对象地址
			信号类型地址					槽函数地址
	connect(sock,SIGNAL(connected()),this,SLOT(on_connected()));
			SIGNAL（默认会选择sock的父类里面的信号，不用再加作用域了括号中的函数要加参数类型
	connect(sock,SIGNAL(error(QAbstractSocket::SocketError)),this,SLOT(on_error()));
								这是error信号的参数类型，不用加形参名		

	connect(sock,SIGNAL(error(QAbstractSocket::SocketError)),this,SLOT(on_error()));
	connect连接中信号只写类型不写形参，slot可以参数比signal少。
				槽函数声明的时候信号也可以只写类型，不写形参，在定义的时候再写形参。
	注意自定义的类才可以自定义信号和槽函数&&&&&&：自定义槽函数时要在头文件中加：
	public slots:   信号加到signals：下。自定义的信号只需要头文件声明一下就好了,不需要实现
	返回值是void，可以有参数，可以重载。
    								 void btn_deal();
	槽函数直接写到public中即可，类似普通的函数
	返回值void，需要声明，也需要实现，可以有参数，也可以重载
	
	信号与槽都写完之后只需要connect即可，然后等着触发此信号即可。
	exp:在widget中connect(t1,&Teachar::hungry,st,&Student::eat);
	
   	自定义的信号怎么触发这个信号呢？？	
   	可以在widget中定义一个普通的函数，调用这个函数就会emit signal
   	{
   		emit t1->hungry();		//通过在widget的构造函数中调用这个函数去发信号。构造函数在创建mywidget的时候就会执行内部所有的东西
   	}

    如果自定义的类不属于任何别控件，应该让他继承与QObject-----这样他就不用管自己的内存释放了。这个类会管理内存的...

    connect信号可以连接信号的***，触发信号1则触发信号2
	
    QString转char*；s.toutf8().data(); qstring->qbytearray->char*
	QString str = QString("abc %1 ^_^ %2").arg(123).arg("mike");  格式化字符串
	qstring打印时默认带“”，char *打印时不带“”

	对于重载的signal函数与slot函数调用的时候函数名字都一样怎么区分呀？
	通过制定函数类型：
	void (Teacher::var)(QString) = &Teachar::hungry;  定义的(sig或者slot一样)函数指针变量var就是&Teachar::hungry，
	而且这个变量指向，返回值void，参数是qstring的hungry，而不是空入参的hungry。

    1个新号怎么调用多个槽函数呢？用lambda表达式
    lambda表达式：定义并创建匿名函数对象  
    [=](){		[]中放：	=等号用的最多  	&
    	btn->settext("12");
    };中括号小括号大括号
	connect(btn,&QPushubutton::clicked,this,[=]()
	{
		this->close();
		emit 另一个信号()；
		...外面的变量函数都能在这里面调用。。。
	})
	如何新建另一个窗口？？connect按钮按下则调用lambda表达式【=】（）{
		QDialog dlg；
		dlg。exec（）；就ok了
	}
	qt资源文件：添加文件->resource file->open in edit->设置路径名，以后用资源的时候复制路径就可以

	qt样式表：控件的样式
		设置按键，label，主窗口的样子-背景字体...
	qt的lable还可以显示图片，gif，可跳转的域名
		
---------------------事件 
	事件类似一个个的软件中断*****	
	qt中所有的事件类都继承与qevent	，bool event（QEvent*）ev）函数不直接处理事件，而是按照事件类型分派给
	特定的事件处理函数。在函数体内把自己想处理的事处理一下，其他事件交给父类处理，你不可能处理所有的事件。
	qwidget中定义了很多事件处理函数都是虚的，可以在子类重新实现的。
	protected ：
	***事件不用connect，写好了发生就可以触发事件函数。	
	QString str = QString("abc %1 ^_^ %2").arg(123).arg("mike");
		str = abc 123 ^_^ mike  类似sprintf
	鼠标按下事件：在一个mylabel的类中实现的
	但是键盘按下的键得在mywidget中实现，因为键盘按下的事件只有主窗口才能收到，但是鼠标的按下事件是按在了label中，mylabel可以接收到
	定时器也一种事件：timerevent。可以在mywidget中重写虚函数
					同时定时器需要在mtwidget中去starttimer
	图片：绘图看例子，很详细
		QPmixmap pix；pix.load("路径")。设置参数
		p.draw(0,0,pix);

	
	主窗口控制事件分发：
			在mainwindow中：重定义event（）将传进来的实体化的QEvent *e事件，根据类型选择对应的处理函数
								{
									switch事件（e->type（））
									 == xxx    mousemove事件；
									 == xxx    closeevent事件；
								}
	连接sqlite：
	messageBox:：warning（this，“wrong”）出错弹出对话框用到。
	
	
关于QT事件(event)的简单介绍
　　　事件(event)是有系统或者Qt本身在不同的时刻发出的。当用户按下鼠标，敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件是在对用户操作做出响应的时候发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。
　　一般来说，使用Qt编程时，我们并不会把主要精力放在事件上，因为在Qt中，需要我们关心的事件总会发出一个信号。比如，我们关心的 QPushButton的鼠标点击，但我们不需要关心这个鼠标点击事件，而是关心它的clicked()信号。

　　Qt的事件很容易和信号槽混淆。这里简单的说明一下，signal由具体对象发出，然后会马上交给由connect函数连接的slot进行处理；
	而对于事件，Qt使用一个事件队列对所有发出的事件进行维护，当新的事件产生时，会被追加到事件队列的尾部，前一个事件完成后，取出后面的事件进行处理。但是，必要的时候，Qt的事件也是可以不进入事件队列，而是直接处理的。并且，事件还可以使用“事件过滤器”进行过滤。
	总的来说，如果我们使用组件，我们关心的是信号槽；如果我们自定义组件，我们关心的是事件。因为我们可以通过事件来改变组件的默认操作。比如，如果我们要自定义一个QPushButton，那么我们就需要重写它的鼠标点击事件和键盘处理事件，并且在恰当的时候发出clicked()信号。
　　还记得我们在main函数里面创建了一个QApplication对象，然后调用了它的exec()函数吗？其实，这个函数就是开始Qt的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt将创建一个事件对象。Qt的所有事件都继承于 QEvent类。在事件对象创建完毕后，Qt将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数(event handler)。
　　在所有组件的父类QWidget中，定义了很多事件处理函数，如keyPressEvent()、keyReleaseEvent()、mouseDoubleClickEvent()、mouseMoveEvent ()、mousePressEvent()、mouseReleaseEvent()等。这些函数都是protected virtual的，也就是说，我们应该在子类中重定义这些函数


class　EventLabel　:　public　QLabel
{
protected:
　　　　void　mouseMoveEvent(QMouseEvent　*event);
　　　　void　mousePressEvent(QMouseEvent　*event);
　　　  void　mouseReleaseEvent(QMouseEvent　*event);
};
void　EventLabel::mouseMoveEvent(QMouseEvent　*event)
{
this->setText(QString("Move:　(%1,　%2)").arg(QString::number(event->x()).arg(QString::number(event->y())));
}
void　EventLabel::mousePressEvent(QMouseEvent　*event)
{
　this->setText(QString("Press:　(%1,　%2)").arg(QString::number(event->x()).arg(QString::number(event->y())));
}
void　EventLabel::mouseReleaseEvent(QMouseEvent　*event)
{
　　　QString　msg;
　　　msg.sprintf("Release:　(%d,　%d)",event->x(),　event->y());//与上面的显示不一样的语法
　　　this->setText(msg);
}
int　main(int　argc,　char　*argv[])//事件不需要connect slot函数就可以触发，只需要重载事件处理函数即可，这些处理函数在父类种不做处理
{
　　　QApplication　app(argc,　argv);
　　　EventLabel　*label　=　new　EventLabel;
　　　label->setWindowTitle("MouseEvent　Demo");
　　　label->resize(300,　200);
　　　label->show();
　　　return　app.exec();
}
　　这里我们继承了QLabel类，重写了mousePressEvent、mouseMoveEvent和MouseReleaseEvent三个函数。我们并没有添加什么功能，只是在鼠标按下(press)、鼠标移动(move)和鼠标释放(release)时把坐标显示在这个Label上面。
注意我们在mouseReleaseEvent函数里面有关QString的构造。我们没有使用arg参数的方式，而是使用C语言风格的sprintf来构造QString对象

----------------------------------------------------------------------------

	qt的静态库要自己编译所以一般使用动态库。
	将写好的qt程序编译成release版本，copy生成的app.exe到一个新目录，qtshell，Qt命令行(左下角)
			然后用windeployqt.exe ./app.exe操作，会将它需要的动态库文件都放到此文件夹
			或者：cd /d D:\现在新建的存app.exe的目录   F:as\d\d\d\windeployqt.exe .\自己的.exe
	代码编译不一定非要用qt软件内点击鼠标：
			1.直接使用qmake.exe进行qmake，然后使用mingw32-make.exe进行make就会生成app.exe。 
	qt中函数alt+enter自动补全
	
易错点：定义变量放在.h文件中，不然.c中其他函数无法访问。
     在当前类的.cpp文件中访问当前类的成员，可以通过this->shuxing（fun）或者直接调用成员属性（方法），不加this都可以。

串口收发参考连接：https://blog.csdn.net/qq_39017187/article/details/88935705

定时器：
1.QTimer * timer=new QTimer(this);
    timer->start(500);
    connect(timer,&QTimer::timeout,this,[=](){
        qDebug()<<"shijiandao";
    });
2.监听timerEvent();事件，不推荐哦

ctrl+i：全选后，所有行自动对齐
QT_CHARTS_USE_NAMESPACE：首行需要加命名空间	
直接参考example文件中的c文件。

QLineSeries定义的变量series要add到QChart定义的变量chart中去，charts最后要加到QChartView chartView变量中去，
最后chartView又要加到QMainWindow  window.setCentralWidget(chartView)中去。

可以参考QT左上角的欢迎->示例

绘制各种图形举例：https://blog.csdn.net/lwbeyond/article/details/41479809?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.control


qt：编译报错  Error while building/deploying project all-class-in-one (kit: Desktop Qt 5.10.1 …
When executing step “qmake”
改工程所在的路径不能有中文出现，改完后重新打开工程编译即可
-------------------------------老贺发的资料----------------------------各种对话框
QGridLayout* gridLayout = new QGridLayout;布局管理器
可以通过gridLayout对象去布局当前界面中各个控件的位置：
gridLayout->addWidget(colorPushBtn, 0, 0, 1, 1);
setLayout(gridLayout);最后通过setlayout启用设置结果

QGridLayout* layout = new QGridLayout();
/这里create几个控件，设置好属性/
layout->setSpacing(10);//设置控件之间的间距
layout->addWidget(&TestBtn1, 0, 0);//往网格的不同坐标添加不同的组件
layout->addWidget(&TestBtn2, 0, 1);
layout->addWidget(&TestBtn3, 1, 0);
layout->addWidget(&TestBtn4, 1, 1);
layout->setRowStretch(0, 1);//设置行列比例系数
layout->setRowStretch(1, 3);// 
layout->setColumnStretch(0, 1);
layout->setColumnStretch(1, 3);
layout->addWidget(&TestBtn1, 0, 0, 2, 1);//坐标（0，0）的组件占用两行一列
layout->addWidget(&TestBtn2, 0, 1, 2, 1);//坐标（0，1）的组件占用两行一列
layout->addWidget(&TestBtn3, 2, 0, 1, 2);//坐标（2，0）的组件占用一行两列
layout->addWidget(&TestBtn4, 3, 0, 1, 2);//坐标（3，0）的组件占用一行两列
setLayout(layout);//最后通过setlayout启用设置结果

-----------槽函数集成-----------
不同的按钮按下可以调用同一个槽函数：
connect(colorPushBtn, SIGNAL(clicked()), this, SLOT(doPushBtn()));
void CBuiltinDlg::doPushBtn()
{
#当QPushButton发出一个信号时就记录发出这个信号的对象，sender获取发出信号的对象；
#当有多个OBject发出信号时可根据sender()函数判断是哪个对象发出的；然后qobject_cast类型转换为QPushButton类型
    QPushButton* btn = qobject_cast<QPushButton*>(sender());
    if(btn == colorPushBtn) {// 如果被按下的是颜色对话框.
        QPalette palette = displayTextEdit->palette();//创建textedit对象的调色板
        const QColor& color = QColorDialog::getColor(palette.color(QPalette::Base), this);//获取选择的颜色
        if(color.isValid()) {
            palette.setColor(QPalette::Base, color);//设置调色板颜色
            displayTextEdit->setPalette(palette);//将调色板颜色设置到textedit
        }
    }
    else if(btn == errorPushBtn) {//如果被按下的是错误信息框.
        QErrorMessage box(this);//创建qerrormessage对象
        box.setWindowTitle(tr("错误信息框"));//设置标题
        box.showMessage(tr("错误信息框实例xx。"));//错误内容
        box.exec();//对话框不退出
    }
    else if(btn == filePushBtn) {// 文件对话框.
        QFileDialog *fileDialog = new QFileDialog(this);
        fileDialog->setWindowTitle(tr("Open Image"));
        fileDialog->setDirectory(".");//设置当前目录

		QStringList filter;//文件过滤器
		filter << "*.jpg" << "*.png" << "*.bmp" << "*.gif";//过滤的文件名后缀
		fileDialog->setNameFilters(filter);//设置过滤器生效
        if(fileDialog->exec() == QDialog::Accepted) {
            QString path = fileDialog->selectedFiles()[0];//获取路径
            displayTextEdit->setText(path);//显示路径
        }
    }
    else if(btn == fontPushBtn) {// 字体对话框.
        bool ok;
        const QFont& font = QFontDialog::getFont(&ok,//给ok变量赋值
                                    displayTextEdit->font(),//获取当前textedit字体
                                    this,
                                    tr("字体对话框"));
        if(ok) {// 如果<确定>,设置字体.
            displayTextEdit->setFont(font);//给textedit设置字体
        }
    }
    else if(btn == inputPushBtn){// 输入对话框.
        bool ok;
        QString text = QInputDialog::getText(this,
                                            tr("输入对话框"),
                                            tr("输入文本："),
                                            QLineEdit::Normal,
                                            QDir::home().dirName(),
                                            &ok);
        if (ok && !text.isEmpty())
           displayTextEdit->setText(text);
    }
    else if(btn == pagePushBtn) {// 页设置对话框.
        QPrinter printer;
        QPageSetupDialog dlg(&printer, this);
        dlg.setWindowTitle(tr("页设置对话框"));
        if (dlg.exec() == QDialog::Accepted) {
            // 进行下一步的处理。
        }
    }
    else if(btn == progressPushBtn) {// 进度对话框.
        QProgressDialog progress(tr("正在复制文件..."), tr("取消"), 0, 1000, this);
        QFont font("ZYSong18030",10);
        progress.setFont(font);

        progress.setWindowModality(Qt::WindowModal);
        progress.setWindowTitle(tr("进度对话框"));
        progress.show();
        for (int i = 0; i < 1000; i++) {
            progress.setValue(i);
            qApp->processEvents();
            if (progress.wasCanceled())
                break;
            QTest::qWait(1);
            //... 复制文件处理。
        }
        progress.setValue(1000);
    }
    else if(btn == printPushBtn) {// 打印对话框.
        QPrinter printer;
        QPrintDialog dlg(&printer, this);
        dlg.setWindowTitle(tr("打印对话框"));
        if (dlg.exec() == QDialog::Accepted) {
            // 进行下一步的处理。
        }
    }
}

同时打开多个文件的对话框：
void CBuiltinDlg::MultiOpenFile()
{
    QStringList files = QFileDialog::getOpenFileNames(
                                    this, tr("Select one or more files to open"),//弹框标题
                                    "/",
                                    tr("All Files (*);;Text Files (*.txt)"));//过滤设置
    if (files.count()) {//如果选中的文件不是0个
      displayTextEdit->setText(QString("[%1]").arg(files.join(", ")));//将所有选中文件的路径显示到edit
    }
}
向导对话框：
void CBuiltinDlg::slotWizard()
{
    QWizard wizard;//创建向导
    wizard.addPage(createFirstPage());//对话框有2页
    wizard.addPage(createSecondPage());

    wizard.setWindowTitle(tr("向导对话框"));
    wizard.exec();
}
QWizardPage* CBuiltinDlg::createFirstPage()
{
    QWizardPage *page = new QWizardPage;//向导对话框中的页内容
    page->setTitle(tr("简介"));
    QLabel *label = new QLabel(tr("第一页"));
    label->setWordWrap(true);有没有好像没啥变化
	
    QVBoxLayout *layout = new QVBoxLayout;//布局器
    layout->addWidget(label);
    page->setLayout(layout);
    return page;
}
QWizardPage* CBuiltinDlg::createSecondPage()
{
     QWizardPage *page = new QWizardPage;
     page->setTitle(tr("正文"));
     QLabel *label = new QLabel(tr("第二页"));
     label->setWordWrap(true);
	 
     QVBoxLayout *layout = new QVBoxLayout;//布局器
     layout->addWidget(label);
     page->setLayout(layout);让布局器去布局
     return page;
}

错误信息框：
QMessageBox::critical(this, tr("错误"),tr("告诉用户一个严重的错误!"));

告警信息对话框：
void CBuiltinDlg::slotWarning()
{
    switch(QMessageBox::warning(this,tr("警告"),tr("是否要保存文档?"),
            QMessageBox::Save|QMessageBox::Discard|QMessageBox::Cancel,QMessageBox::Save))
    {
    case QMessageBox::Save:
        displayTextEdit->setText(tr("警告对话框 / 保存"));
        break;
    case QMessageBox::Discard:
        displayTextEdit->setText(tr("警告对话框 / 不保存"));
        break;
    case QMessageBox::Cancel:
        displayTextEdit->setText(tr("警告对话框 / 取消"));
        break;
    default:
        break;
    }
}
询问消息框：
void CBuiltinDlg::slotQuestion()
{//tr("询问")是标题    tr("重新开始?")是内容   下面是多个按钮
    switch(QMessageBox::question(this,tr("询问"),tr("重新开始?"),
            QMessageBox::Ok|QMessageBox::Cancel,QMessageBox::Ok))
    {
    case QMessageBox::Ok:
        displayTextEdit->setText(tr("询问按钮 / 确定"));
        break;
    case QMessageBox::Cancel:
        displayTextEdit->setText(tr("询问按钮 / 取消"));
        break;
    default:
        break;
    }
}

函数 tr()全名是QObject::tr(),被它处理的 字符串可以 使用工具提 取出来翻译 成其他语言, 也就是做国际化使用。
只要记住,Qt 的最佳实践:如果你想让你的程序国际化的话,那么,所有用户可见的字符串都要使用 QObject::tr()!
但是,为什么我们没有写 QObject::tr(),而仅仅是 tr()呢?原来,tr()函数是定义在 Object里面的,所有使用了 Q_OBJECT 宏的类都自动具有 tr()函数。

qcustomplot库
QTimer mDataTimer;
connect(&mDataTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));  得先connect再start，每40ms执行timerslot函数。
mDataTimer.start(40);

我们可以根据qt代码目录编译后生成的buildxx目录看到之前编译此工程的qt是哪个版本。
正则表达式控制textedit的输入值：
QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");regExp可接收数据被确定
ui->lineEdit->setValidator(new QRegExpValidator(regExp, this));只有有效的数据才能被写到lineedit
//lineedit文本发生改变才进入slot函数
connect(ui->lineEdit, SIGNAL(textChanged(const QString&)), this, SLOT(on_lineEdit_textChanged()));
void GoToCellDialog::on_lineEdit_textChanged()//只有lineedit满足要求ok按钮才能被点击
{
	ui->okButton->setEnabled(ui->lineEdit->hasAcceptableInput());
}
-------------目录操作
m_appFolder = QDir(QApplication::applicationDirPath());获取当前工程目录路径

QDir imageFolder = m_appFolder;
imageFolder.cdUp();//进入上层目录
imageFolder.cdUp();
imageFolder.cd("src");//进入src目录
imageFolder.cd("charts");//再进入charts目录
imageFolder.cd("doc");
imageFolder.cd("images");


QT工程pro文件模板变量（TEMPLATE）
subdirs - 这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。
app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。


tabwidget用法-------------与table widget不一样，这个是容器
setTabIcon(0,QIcon("E:\\Qt_Project\\QTabWidget\\1.ico"));//设置第1个选项卡的图标 
setTabPosition(QTabWidget::South);//设置选项卡的方位东南西北，默认在上方
//用stringlist给表格添加表头
QStringList m_Header;
m_Header<<QString("田径")<<QString("篮球")<<QString("足球")<<QString("乒乓球")<<QString("羽毛球")<<QString("游泳");
ui->tableWidget->setHorizontalHeaderLabels(m_Header);//添加横向表头，表头这行不算在数据行之内
可视化加了，显示没什么变化
ui->tableWidgetSports->verticalHeader()->setVisible(true);//纵向表头可视化
ui->tableWidgetSports->horizontalHeader()->setVisible(true);//横向表头可视化

给表格填数据的方法：6列10行
for(int rows=0;rows<10;rows++)//遍历行
{
	for(int columns=0;columns<6;columns++)//遍历列
	{
	ui->tableWidget->setItem(rows,columns,new QTableWidgetItem("刘翔"));给row行colums列增加数据new QTableWidgetItem("string变量")
	}
}

for(int rows=0;rows<10;rows++)//循环设置每个表格中文字属性，类似excel中的设置--得一个一个设置吗？太麻烦了吧
{
	for(int columns=0;columns<6;columns++)
	{
		ui->tableWidget->setColumnWidth(columns,125);
		ui->tableWidget->setRowHeight(rows,30);
		ui->tableWidget->item(rows,columns)->setTextAlignment(Qt::AlignCenter);//居中显示
		ui->tableWidget->item(rows,columns)->setBackgroundColor(QColor(85,170,255));//设置前景颜色
		ui->tableWidget->item(rows,columns)->setTextColor(QColor(0,0,0));//设置文本颜色
		ui->tableWidget->item(rows,columns)->setFont(QFont("Helvetica"));//设置字体为黑体
	}
}

qcustomplot库:
新建widget控件，然后提升控件为qcustomplot类
之后直接在文件中调用qcustomplot的方法去初始化控件即可

ui->qCustomPlotMusic->plotLayout()->insertRow(0);给控件增加row0行
ui->qCustomPlotMusic->plotLayout()->addElement(0, 0, new QCPTextElement(ui->qCustomPlotMusic, "网易云音乐播放和评论统计图", QFont("微软雅黑",12, QFont::Bold)));给row0行 colum0列 增加文本要素

渐变色控制QLinearGradient控件
QLinearGradient gradient(0, 0, 200, 400);    在x轴的0-200范围内实行渐变   在y轴的0-400实行渐变
gradient.setColorAt(0, QColor(200, 150, 220));共3段渐变色调整
gradient.setColorAt(0.56, QColor(15, 150, 200));
gradient.setColorAt(1, QColor(40, 49, 200));
ui->qCustomPlotMusic->setBackground(QBrush(gradient));  将渐变设置画到qCustomPlotMusic的bg中

mGraph2->setPen(QPen(QColor(0, 180, 60)));设置线条颜色
----------------------

listWidget:每行一个选项卡，additem增加选项
ui->listWidgetLanguage->addItem(tr("中文"));
//以下5行 设置滚动时可以用鼠标左键按下去滚动
//禁用横向滚动条
ui->listWidget->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//禁用纵向滚动条
ui->listWidget->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//设置横向按照像素值为单位滚动
ui->listWidget->setHorizontalScrollMode(QListWidget::ScrollPerPixel);
//设置纵向按照像素值为单位滚动
ui->listWidget->setVerticalScrollMode(QListWidget::ScrollPerPixel);
//设置滚动对象以及滚动方式为鼠标左键拉动滚动
QScroller::grabGesture(ui->listWidget, QScroller::LeftMouseButtonGesture);


groupbox里面可以放各种同类型控件,一次性放多个
radiobox checkbox  pushbutton  lineedit 


treeWidget：树状的listWidget
ui->treeWidgetDigital->setColumnCount(2); //设置列数
ui->treeWidgetDigital->setHeaderLabels(QStringList(tr("数码产品")));//设置头的标题
QTreeWidgetItem *items1 = new QTreeWidgetItem(ui->treeWidgetDigital,QStringList(QString("手机")));大项目分类
items1->setIcon(0,QIcon("E:\\Qt_Project\\QTabWidget\\1.ico"));设置icon
QTreeWidgetItem *items11 = new QTreeWidgetItem(items1,QStringList(QString("苹果")));//设置手机分类里面的子项目




QString 转换为 char *
1.QString 转换为 char *
将 QString 转 char *，需要用到 QByteArray 类，因为 char * 最后都有一个'\0'作为结束符，而采用 QString::toLatin1() 时会在字符串后面加上'\0'。
QString  str;
char*  ch;
QByteArray ba = str.toLatin1(); // must
ch=ba.data();
这样就完成了 QString 向 char * 的转化。经测试程序运行时不会出现 bug。注意第3行，一定要加上，不可以 str.toLatin1().data() 这样一步完成，否则可能会出错。
补充：以上方法当 QString 里不含中文时，没有问题，但是 QString 内含有中文时，转换为 char * 就是乱码，采用如下方法解决：

方法1：添加GBK支持
#include <QTextCodec>
QTextCodec::setCodecForTr(QTextCodec::codecForName("GBK"));
QTextCodec::setCodecForLocale(QTextCodec::codecForName("GBK"));
然后将上面的第3行修改为：

QByteArray ba = str.toLocal8Bit();  // toLocal8Bit 支持中文
方法2：先将 QString 转为标准库中的 string 类型，然后将 string 转为 char *。如下：
QString  filename;
std::string str = filename.toStdString();
const char* ch = str.c_str();
2.char * 转换为 QString
将 char * 转换为 QString 比较容易操作，我们可以使用 QString 的构造函数进行转换：
QLatin1String(const char *str);char*-->std::string
因此用下面这个语句就可以将 char * ch 转换为 QString str 了，如下：
str = QString(QLatin1String(ch));






-----------------------------------多线程
在主线程中结束之前调用
mythread.join();   意思就是等其他线程结束后，由主线程来回收进程资源----就是等别的子线程都执行完再退出主线程
std::thread  mythread(fun);mythread线程变量的初始化函数与执行函数就是fun


----------------------------内存回收机制
在 C++ Primer 中读到 new 是在堆里面申请一段内存资源，new 必须与 delete 成对使用，否则就会造成内存泄漏。但是在Qt中经常可以看见只 new 而不 delete 的情况，这并没有错，Qt 的内存管理机制允许这样的情况存在。
qt 对 c++ 的内存管理机制进行了扩充，所有继承自QObject的类new出来的成员都会自动delete，而手动delete反而会造成不必要的麻烦
但是在c++中如果不手动delete，new对象的内存在进程结束后才会被系统回收，在运行时占用内存越来越多，这就是内存泄露。

QByteArray的操作：
1、访问赋值：[]  at()  data[]   constData[],其中[]与data[]为可读可写
at()和constData[]仅为可读。如果只需要读用这两种方法运行快

2、数据转换
1)转化为hex QByteArray text = QByteArray::fromHex("517420697320677265617421");
	--字符串转QByteArray 51 74 20 69 73 20 67 72 65 61 74 21
2)转为不同进制数值并显示，如二进制、八进制、十进制和十六进制等；
	--QByteArray_var.toHex(); //return "303132"
	QByteArray::number(var,n);转化int类型的var变量，转化成n进制
3)转为整型、浮点型等数值类型；
	QByteArray string("1234.56");
	qDebug() << string.toInt();   // return 0, 小数均视为0
	qDebug() << string.toInt(&ok1,16);   // return 0, 小数均视为0
	qDebug() << string.toFloat();   // return 1234.56
4）转为字符串类型；
	QByteArray转为QString示例：
		QByteArray ba("abc123");
		QString str = ba; 
	QString转为QByteArray示例：
		QString str("abc123");
		QByteArray ba = str.toLatin1();
5)将QByteArray中的某个数据转化成16进制，然后转化成Qstring
QString("%1").arg((unsigned char)readtext.at(i), 2, 16, QLatin1Char('0'))
 
----------------------------------------------------------------------------
主窗口点击按钮 弹出另一个自定义窗口:	两个窗口之间的切换
界面1构造函数中：
界面2 = new Dialog();//得在这里就初始化，否则connect访问空指针了
connect(界面2,SIGNAL(sendsignal()),this,SLOT(reshow()));//界面1发出sendsignal时，自己要reshow

void 界面1::reshow()   这是槽函数
{
    this->show();
}

void Widget::on_pushButton_clicked()//界面1 按键按下  则将界面2显示出来--同时将界面1隐藏
{
    //d = new Dialog();//得在构造初始化，否则connect访问空指针了
    d->show();
    this->hide();
}
界面2操作：
void Dialog::on_buttonBox_accepted()
{
    emit sendsignal();//切换页面1的时候需要发sendsignal触发界面1的connect函数
    this->close();
}


调试：
在函数内部调试的时候默认局部变量会显示出来，全局变量不会
全局变量的查看方法：
	在变量窗口右键：add new expression .. 添加变量名称即可

QByteArray byte = serial->readAll();
QString qstr = byte.toHex();//收到的uart数据由16进制转成10进制

int x=63;
qDebug()<<QByteArray::number(x);  整数的10进制打印   16进制打印
qDebug()<<QByteArray::number(x,16);
qDebug()<<QByteArray::number(x,16).toUpper();

参考git上的qt uart工程 去处理收到的uart数据。


---------------------qt再学习
ui中放入控件后  点击主窗口  点击网格布局--->自动排列好 
如果想把某个页面中的控件 剪切到另一个页面 直接剪切 复制即可 
多个控件 想在某个控件内放东西  可以先在右边 控件栏 选中控件 再去左边操作
stackWidget-->类似c#的tabWidget-->ui->stackedWidget->setCurrentWidget(ui->calc);根据各个界面名字进行切换

mainWindow的菜单栏如何点击切换页面：
添加转到槽

槽函数也可以直接调用的，本质上只是一个函数而已，不一定非要触发才可以执行--构造函数中也可以执行
一个ui界面文件 对应一个.h .cpp文件 是一套的

安装mysql的链接：https://zhuanlan.zhihu.com/p/326439656


Qt5.9.2如果使用的是mingw编译器，Qt只有32位的。连接64位的MySQL，即使把mysql安装目录下的libmysql.dll放到qt安装目录bin路径下，也是无法连接数据库。网上给出的做法是下载Qt对应版本的源码，重新编译。这种方法复杂繁琐，且容易编译失败。先发现一种简便方法，就是mysql的官网给出了连接32位的驱动。


下拉框里面显示数据库内容
QSqlQueryModel * queryModel = new QSqlQueryModel(this);//依附主窗体 不用操心 释放问题
queryModel->setQuery("select * from table1");---只有1列数据
ui->combox->setModel(queryModel); 将模型获取的数据直接添加到combox中 setModel入参是抽象item  queryModel就是继承的抽象item类 所以可以直接传

下拉框改变槽函数：
combox_curIndexChanged(const String &arg1) //arg1就是下拉框更新后的数据
{
	if(arg1 == "n1")
	{
		更新对应控件内容
	}else if(arg1=="n2")//根据下拉框的内容 更新查询数据库 更新其他下拉框该显示的内容
	{
		//方法1：
		QSqlQueryModel * queryModel = new QSqlQueryModel(this);//依附主窗体 不用操心 释放问题
		queryModel->setQuery("select brand from table2 where fac='%1'").arg(arg1);
		ui->combox->setModel(queryModel); 将模型获取的数据直接添加到combox中 
		//方法2： 
		QSqlQuery query;
		//用sql 根据 当前 combox 内容 筛选数据 不要忘记这里有''
		QString sql=QString("select brand from table2 where fac='%1'").arg(arg1);
		query.exec(sql);
		//获取 查到的内容
		while(query.next())
		{
			QString name=query.value(0).toString();
			/*如果获取到 2个序列的数据 则需要一个一个根据字段名接收
			  int pri= query.value("price").toInt();
			  string var= query.value("var2").toString();
			*/
			ui->combox->addItem(name);//往这个下拉框加入数据
		}
	}
}

qt中普通的函数可以只声明 不定义，但是自己右键->转到槽的槽函数 必须定义与声明都在（或都删）
---如果只删掉定义不删掉声明 还是无法编译通过



Qclipboard   剪切内容的类
QGUIApplication::clipboard()->test()---返回的就是当前剪切板中的内容（如果先在windows中复制的东西，运行
qt程序后直接qDebug此表达式，返回的就是当前剪切板中的内容）
Qdir::currentpath()

多进程：
Qprocess * ptr=new QProcess(this);  必须定义成指针  否则函数完成的时候变量消失  进程就必须结束
用指针就需要考虑指针的释放--connect(ptr,SLOT(finished()),delete ptr);//自己释放自己
QStringList args;
args<<"/select"+QString("path");
ptr->start("explorer",args);开启进程 资源管理器


args<<"/xx"+"yy"  报错 “yy”是char * 无法直接+  需要转化成QString才能加
args<<"/xx"+QString("yy")<<"zz"   则args[0]="/xxyy"  args[1]="zz"



定义槽函数：
需要在.h文件中 加public slots: 修饰   直接定义函数，在.c文件调用时会报错  无此槽函数
public   slots:
    void load();

connect(ui->mypushButton,SIGNAL(clicked()),this,SLOT(load()));

获取当前线程ID 当前时间：年月日 时分秒 毫秒
str = QString("Subthread Id: %1, Time:%2").arg((unsigned)QThread::currentThreadId())
                .arg(QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss zzz"));

延时  或者异步 执行槽函数，都可以解决主界面还未初始化完调用load卡死的问题。
//异步执行load函数
QMetaObject::invokeMethod(this, "load", Qt::QueuedConnection);
//延时10毫秒执行load函数
QTimer::singleShot(10, this, SLOT(load()));

exp:
public slots:  头文件中必须将此，两个函数声明成槽函数 否则后面无法调用
    void timeSlot();
    void Load(qint32 nMsecs);

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    qDebug()<<"satart";
	//这里3种方法都可以解决主界面显示慢 问题
    QMetaObject::invokeMethod(this,"Load",Qt::QueuedConnection);//无参数，QueuedConnection表示异步调用，等主线程
    //QMetaObject::invokeMethod(this,"Load",Qt::QueuedConnection, Q_ARG(qint32, 5000));//异步调用，Q_ARG传参数
    //QTimer::singleShot(10,this,SLOT(timeSlot()));//启用单次计时器
}

void MainWindow::Load(qint32 nMsecs)
{
    QThread::msleep(nMsecs);
    this->setWindowState(Qt::WindowMaximized);
    ui->label->setText("执行invokeMethod之后");
}

void MainWindow::timeSlot()
{
    QThread::msleep(3000); //
    this->setWindowState(Qt::WindowMaximized);
    ui->label->setText("执行QTimer之后");
}

获取类的属性和方法 方便调用：
//拿到控件元对象--定义出来的控件对象--可以是widget界面，可以是按钮 标签控件
const QMetaObject *metaObject = widget->metaObject();

//所有属性的数量
int propertyCount = metaObject->propertyCount();
//propertyOffset是自定义的属性开始的位置
int propertyOffset = metaObject->propertyOffset();
//循环取出控件的自定义属性, int i = 0 表示所有属性
for (int i = 0; i < propertyCount; ++i) {
    QMetaProperty metaProperty = metaObject->property(i);
    const char *name = metaProperty.name();
    const char *type = metaProperty.typeName();
    QVariant value = widget->property(name);
    qDebug() << name << type << value;}

//所有方法的数量
int methodCount = metaObject->methodCount();
//methodOffset是自定义的方法开始的位置
int methodOffset = metaObject->methodOffset();
//循环取出控件的自定义方法, int i = 0 表示所有方法
for (int i = 0; i < methodCount; ++i) {
    QMetaMethod metaMethod = metaObject->method(i);
    const char *name = metaMethod.name();
    const char *type = metaMethod.typeName();
    qDebug() << name << type;}

Qt内置图标封装在QStyle中，大概七十多个图标，可以直接拿来用，相当于给label嵌入背景，改变label形状 颜色：
	/*
    SP_TitleBarMenuButton,    SP_TitleBarMinButton,    SP_TitleBarMaxButton,
    SP_TitleBarCloseButton,    SP_MessageBoxInformation,    SP_MessageBoxWarning,
    SP_MessageBoxCritical,    SP_MessageBoxQuestion,...
    */
    QPixmap pixmap = this->style()->standardPixmap(QStyle::SP_MessageBoxCritical);
    ui->label->setPixmap(pixmap);

多个控件重组到一起：
可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。将lineEdit设置到布局，然后给布局增加btn控件，实现控件组合
	QPushButton *btn = new QPushButton;
    btn->resize(30, ui->lineEdit->height());
    QHBoxLayout *layout = new QHBoxLayout(ui->lineEdit);
    layout->setMargin(0);
    layout->addStretch();
    layout->addWidget(btn);
	
巧妙的使用inherits判断是否属于某种类。
	QTimer *timer = new QTimer;         		  // QTimer inherits QObject
    qDebug()<<timer->inherits("QTimer");          // returns true
    qDebug()<<timer->inherits("QObject");         // returns true
    qDebug()<<timer->inherits("QAbstractButton"); // returns false

qt中的泛型数据类型：
struct MyClass{
    int id;
    QString name;
};
Q_DECLARE_METATYPE(MyClass)  //定义好数据类型，需要声明成内部类型 后面才可以直接与泛型转换
	QVariant data[4];
    //存储数据
    MyClass myClass;
    myClass.id=0;
    myClass.name=QString("LiMing");
    data[0]=QString("ddd");//泛型的数组 可以随意赋值不同类型的数据
    data[1]=123;
    data[3]=QVariant::fromValue(myClass);
    //获取数据
    QString str=data[0].toString();
    int val=data[1].toInt();
    if(data[3].canConvert<MyClass>())//如果data[3] 可以转化成MyClass类型
    {
        MyClass myClass=data[3].value<MyClass>();//则转化data[3] 为MyClass 类型的数据myClass
        int id=myClass.id;  获取data[3]中存的数值 
        QString name=myClass.name;
        qDebug()<<id<<" "<<name;
    }	
	
善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来。
特别注意的是第二个参数是QVariant类型，这就不要太灵活了，意味着可以附带万能的数据比如结构体，这样就可以带一堆数据了，而不是一个数据。
比如下拉框选择学号，对应元素可以附带该学生的姓名、班级、成绩等。很多人以为只能附带QString、int之类的数据，因为通常的用法也是那两种。
	QStringList listVideoOpenInterval, listVideoOpenIntervalx;
    listVideoOpenInterval << "0.0 秒" << "0.1 秒" << "0.3 秒" << "0.5 秒" << "1.0 秒" << "2.0 秒";
    listVideoOpenIntervalx << "0" << "100" << "300" << "500" << "1000" << "2000";
    for (int i = 0; i < listVideoOpenInterval.count(); ++i) {
        ui->cboxVideoOpenInterval->addItem(listVideoOpenInterval.at(i), listVideoOpenIntervalx.at(i));
    }//cbox显示的是listVideoOpenInterval的值，实际对应的listVideoOpenIntervalx数值

    //取出对应的值
    int indexVideoOpenInterval = ui->cboxVideoOpenInterval->currentIndex();
    indexVideoOpenInterval = ui->cboxVideoOpenInterval->itemData(indexVideoOpenInterval).toInt();
	
	------------复杂数据类型
	QVariant data[4];
    QStringList listVideoOpenInterval;
    listVideoOpenInterval << "xiaoming" << "xiaohong" << "xiaoli" ;
    MyClass myClass;
    myClass.id=0;     myClass.name=QString("LiMing");
    data[0]=QVariant::fromValue(myClass);
    myClass.id=1;     myClass.name=QString("Lihong");
    data[1]=QVariant::fromValue(myClass);
    myClass.id=2;     myClass.name=QString("Lili");
    data[2]=QVariant::fromValue(myClass);//制作3个struct数据 以QVariantList添加到combox中
    QVariantList listVideoOpenIntervalx;
    listVideoOpenIntervalx << data[0]<<data[1]<<data[2];
    for (int i = 0; i < listVideoOpenInterval.count(); ++i) {
        ui->cboxVideoOpenInterval->addItem(listVideoOpenInterval.at(i), listVideoOpenIntervalx.at(i));
	}
	//当combox索引发生改变时  可以通过index获取到当前索引中隐含的数据信息
	void Widget::on_cboxVideoOpenInterval_currentIndexChanged(const QString &arg1)
	int indexVideoOpenInterval = ui->cboxVideoOpenInterval->currentIndex();
	QVariant testval = ui->cboxVideoOpenInterval->itemData(indexVideoOpenInterval);//根据currentIndex获取itemdata
	if(testval.canConvert<MyClass>())//如果 testval 可以转化成MyClass类型
	{
		MyClass myClass=testval.value<MyClass>();//则转化testval 为MyClass 类型的数据myClass
		int id=myClass.id;  //获取testval中存的数值
		QString name=myClass.name;
		qDebug()<<id<<" "<<name;
	}
	
在pro中判断Qt版本及构建套件位数:打印的信息在QT下面的"概要信息"中  不在"应用程序输出"里面
message(qt version: $$QT_VERSION)
message($$QT_ARCH)

Project MESSAGE: qt version: 5.14.0
Project MESSAGE: i386

设置样式表：
setStyleSheet("QPushButton{text-align:right}");  设置当前项目种所有button中的数据 右对齐
ui->mypushButton->setStyleSheet("text-align:right");  设置某个btn的数据右对齐

Qlabel 3种设置文本的方法：
//常规办法
ui->label->setText("hello");
//取巧办法
ui->label->setProperty("text", "hello");  设置label的text文本，内容为hello
//属性大法 
ui->label->setStyleSheet("qproperty-text:hello;");  设置样式表 qproperty-text 为 hello
setStyleSheet("QLabel{qproperty-text:hello}");     设置当前项目所有label的text都是hello

QEventLoop的使用:在程序运行到某个位置时 将程序卡5s，5s之后loop退出 程序继续运行
用法1：
QEventLoop loop;//定义一个事件循环
QTimer::singleShot(5000, &loop, SLOT(quit()));//创建单次定时器，槽函数为事件循环的退出函数
loop.exec();//事件循环开始执行，程序会卡在这里，直到定时时间到，本循环被退出

用法2：pushButton的clicked事件中 loop阻塞，直到mypushButton按键按下，quit loop循环才能打印出来fun end
void Widget::on_pushButton_clicked()
{
    qDebug()<<"fun start";
    QEventLoop loop;
    connect(ui->mypushButton, SIGNAL(clicked()), &loop, SLOT(quit()));
    loop.exec();
    qDebug()<<"fun end";
}


很多人Qt和Qt Creator傻傻分不清楚
Qt Creator是使用Qt编写的集成开发环境IDE，和宇宙第一的Visual Studio一样;
	他可以是msvc编译器的（WIN对应的Qt集成安装环境中自带的Qt Cerator是msvc的），
	也可以是mingw编译的，还可以是gcc的。
如果是自定义控件插件，需要集成到Qt Creator中，必须保证
该插件的动态库文件（dll或者so等文件）对应的编译器和
Qt版本以及位数和Qt Creator的版本完全一致才行，否则基本不大可能集成进去。
特别注意的是Qt集成环境安装包中的Qt版本和Qt Creator版本未必完全一致，必须擦亮眼睛看清楚，有些是完全一致的。

很多人在绘制的时候，设置画笔以为就只可以设置个单调的颜色，其实QPen还可以设置brush比如设置QPen的brush以后，可以使用各种渐变，比如绘制渐变颜色的进度条和文字等，而不再是单调的一种颜色。

很多控件都带有 viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，
需要对其 viewport()设置才行
ui->scrollArea->viewport()->setStyleSheet("background-color:yellow;");
ui->scrollArea->setStyleSheet("background-color:yellow;");


QDateTime dateTime;时间的各种转换
QString dateTime_str = dateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss");
//从字符串转换为毫秒（需完整的年月日时分秒）
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toMSecsSinceEpoch();
//从字符串转换为秒（需完整的年月日时分秒）
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toTime_t();
//从毫秒转换到年月日时分秒
datetime.fromMSecsSinceEpoch(1315193829218).toString("yyyy-MM-dd hh:mm:ss:zzz");
//从秒转换到年月日时分秒（若有zzz，则为000）
datetime.fromTime_t(1315193829).toString("yyyy-MM-dd hh:mm:ss[:zzz]");


在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，强烈建议使用 at() 取值而不是[] 操作符
因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，
而 at() 函数则不被允许出现在一个赋值的左边。使用at保证不会修改原值

安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，
因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。
如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns);


很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色。
	ui->label->setStyleSheet("background-color:black;");  设置label的背景颜色
    sleep(1000);   颜色等待label的颜色固定住  
	QPalette pal = ui->label->palette();
	QBrush brush = pal.background();
	QColor color = brush.color();  获取label的背景色
	
	double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255;
	QColor textColor = gray > 0.5 ? Qt::black : Qt::white;  计算一个合适的显示颜色

	ui->label->setText("test");
	QPalette pe;
	pe.setColor(QPalette::WindowText,textColor); 设置字体颜色到label上
	ui->label->setPalette(pe);

    QColor testcolor(255, 0, 0, 100);//设置透明颜色
    qDebug() << testcolor.name() << testcolor.name(QColor::HexArgb);
	//输出 #ff0000 #64ff0000
	setStyleSheet("color:#ff6600;");   更改#ff6600为testcolor.name() 更加灵活
    ui->label->setStyleSheet(QString("color:%1").arg(testcolor.name()));//设置样式表  直接修改背景色

Qt中的QString和const char *之间转换，最好用toStdString().c_str(),支持中文直接显示
	const char * ptr=mystr.toStdString().c_str();  必须是const char*

用QFile读写文件的时候，推荐用QTextStream文件流的方式来读写文件，速度快很多，基本上会有30%的提升，文件越大性能区别越大。
经过测试 有的文件第一种 速度更快
	QFile file("E:\\jl\\02-qt\\build-widgettest-Desktop_Qt_5_14_0_MinGW_32_bit-Debug\\2023_01_03_19_03_51_id=1.csv");
    qDebug()<<QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss zzz");
    if (file.open(QFile::ReadOnly)) {
    #if 1
        while(!file.atEnd()) {
            QString line = file.readLine();
            ui->textEdit->append(line);
        }
    #else
        QTextStream in(&file);
        while (!in.atEnd()) {
            QString line = in.readLine();
            ui->textEdit->append(line);
        }
    #endif
        file.close();
    }
    qDebug()<<QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss zzz");


setPixmap是最糟糕的贴图方式，一般只用来简单的不是很频繁的贴图，频繁的建议painter绘制，默认双缓冲，在高级点用opengl绘制，利用GPU。

QString的replace函数会改变原字符串，他在返回替换后的新字符串的同时也会改变原字符串，我的乖乖！

在不同的平台上文件路径的斜杠也是不一样的，比如linux系统一般都是 / 斜杠，而在windows上都是 \\ 两个反斜杠，
Qt本身程序内部无论在win还是linux都支持 / 斜杠的路径，但是一些第三方库的话可能需要转换成对应系统的路径，这就需要用到斜杠转换，Qt当然内置类方法。
	QString path = "C:/temp/test.txt";  以后原串都写成/ 即可
	path = QDir::toNativeSeparators(path);
	//输出 C:\\temp\\test.txt  在windows中会自动转换成\\
	//输出 C:/temp/test.txt		在linux中会转换成/
	

测试下来发现只能执行signals或者slots标识的方法,Q_INVOKABLE 关键字修饰也可以被 invokeMethod 执行
invokeMethod函数不仅支持槽函数还支持信号，而且这逼居然是线程安全的，可以在线程中放心使用，牛逼！

	//头文件声明信号和槽函数
	signals:
		void sig_test(int type,double value);  sig函数不需要实现  可以直接调用，只是用来传递参数的
	private slots:
		void slot_test(int type, double value);
	private:
		Q_INVOKABLE void fun_test(int type, double value);

	//构造函数关联信号槽---发sig_test信号就会自动调用slot_test，而且会将sig中的入参传给slot中作入参。
	connect(this, SIGNAL(sig_test(int, double)), this, SLOT(slot_test(int, double)));

	//单击按钮触发信号和槽，这里是同时举例信号槽都可以
	void MainWindow::on_pushButton_clicked()
	{
		QMetaObject::invokeMethod(this, "sig_test", Q_ARG(int, 66), Q_ARG(double, 66.66));//执行sig函数，sig又将自己的入参传过去调用槽函数
		//相当于  emit sig_test(66,88); 发信号
		QMetaObject::invokeMethod(this, "slot_test", Q_ARG(int, 88), Q_ARG(double, 88.88));
		QMetaObject::invokeMethod(this, "fun_test", Q_ARG(int, 99), Q_ARG(double, 99.99));
	}

	//会打印 66 66.66、88 88.88
	void MainWindow::slot_test(int type, double value)
	{
		qDebug() << type << value;
	}

	//会打印 99 99.99
	void MainWindow::fun_test(int type, double value)
	{
		qDebug() << type << value;
	}
	

Qt5中的信号是public的，可以在需要的地方直接emit即可，而在Qt4中信号是protected的，不能直接使用，需要定义一个public函数来emit。

Qt5.15版本开始官方不再提供安装包，只提供源码，可以自行编译或者在线安装，估计每次编译各种版本太麻烦，更多的是为了统计收集用户使用信息比如通过在线安装，后期可能会逐步加大商业化力度。


在pro文件中可以利用此命令查看当前工程是否支持xxx模块，若不支持，则可以通过QT   +=  network来增加XX模块插件
!qtHaveModule(webenginewidgets) {
message("当前Qt库有找到 webenginewidgets 模块")
}
!qtHaveModule(webkit) {
message("当前Qt库没有找到 webkit 模块")
}
contains(QT, network) {
message("当前项目已经引入 network 模块")
}
contains(QT, widgets) {
message("当前项目引入 widgets 模块")
}


在pro文件可以一次性禁用所有打印，修改pro文件需要重新构建项目 ，否则新修改内容不生效
#禁用qdebug打印输出
DEFINES += QT_NO_DEBUG_OUTPUT XXX YYY

pro文件可以添加各种处理来使得配置更方便，比如指定输出文件路径等，这样就不会全部在一堆编译生成的临时文件中找来找去。

#自定义define变量  可以在整个项目中使用
#pro文件可以这样判断 contains(DEFINES, XXX) { message("pro中有定义XXX") }
#代码文件可以这样判断 #ifdef XXX
DEFINES     += XXX YYY

#关闭编译警告提示 眼不见为净
CONFIG      += warn_off

#指定编译生成的文件到 temp目录 分门别类存储
MOC_DIR     = temp/moc
RCC_DIR     = temp/rcc
UI_DIR      = temp/ui
OBJECTS_DIR = temp/obj

#指定编译生成的可执行文件到bin目录
DESTDIR     = bin

QString类内置了各种进制数据的转换，比如
将数据转成10进制、16进制显示，
或者将10进制、16进制数据转成字符串显示。这里很容易忽略的一点就是，很多人以为就是支持2进制、10进制、16进制之类的，
其实不是的，里面实现了 2-36 之间的任意进制转换

char data[2];
data[0] = 0x10;
data[1] = 25;

//输出 2进制显示 "10000" "11001"
qDebug() << "2进制显示" << QString::number(data[0], 2) << QString::number(data[1], 2);
//输出 5进制显示 "31" "100"
qDebug() << "5进制显示" << QString::number(data[0], 5) << QString::number(data[1], 5);
//输出 10进制显示 "16" "25"
qDebug() << "10进制显示" << QString::number(data[0]) << QString::number(data[1]);
//输出 16进制显示 "10" "19"
qDebug() << "16进制显示" << QString::number(data[0], 16) << QString::number(data[1], 16);




QtSql模块封装了各种数据库操作，使得Qt操作各种数据库非常的简单，支持各种各样的数据库，最基础的ODBC方式也支持连接到各种数据库。有个很容易忽视的要点就是在连接sqlserver数据库的时候，你会发现第三方的数据库工具也没有配置数据库，但是可以连接成功，而在Qt中的常规数据库连接写法却不行，那是因为你代码写错了，要用另外一种写法。
//连接sqlite数据库
QSqlDatabase database = QSqlDatabase::addDatabase("QSQLITE");
//只需要指定数据库文件的绝对路径即可
database.setDatabaseName("d:/test.db");

//连接mysql数据库
QSqlDatabase database = QSqlDatabase::addDatabase("QMYSQL");
database.setDatabaseName("test");
database.setHostName("127.0.0.1");
database.setPort(3306);
database.setUserName("root");
database.setPassword("root");

//连接到sqlserver数据库
//方式一通过odbc数据源，前提是必须配置好数据源。
QSqlDatabase database = QSqlDatabase::addDatabase("QODBC");
database.setDatabaseName("数据源名称");
database.setUserName("sa");
database.setPassword("123456");

//方式二通过驱动字符串，无需配置数据源。设置数据库名称就带了主机地址端口和用户信息所有后面这些设置不需要，强烈建议推荐此方法。
QSqlDatabase database = QSqlDatabase::addDatabase("QODBC");
QStringList list;
list << QString("DRIVER={%1}").arg("SQL SERVER");
list << QString("SERVER=%1,%2").arg("127.0.0.1").arg(1433);
list << QString("DATABASE=%1").arg("test");
list << QString("UID=%1").arg("sa");
list << QString("PWD=%1").arg("123456");
database.setDatabaseName(list.join(";"));

//连接到postgresql数据库
QSqlDatabase database = QSqlDatabase::addDatabase("QPSQL");
database.setDatabaseName("test");
database.setHostName("127.0.0.1");
database.setPort(5432);
database.setUserName("postgres");
database.setPassword("123456");

//连接到oracle数据库
QSqlDatabase database = QSqlDatabase::addDatabase("QOCI");
database.setDatabaseName("test");
database.setHostName("127.0.0.1");
database.setPort(1521);
database.setUserName("system");
database.setPassword("123456");

//连接到人大金仓kingbase数据库（内核就是postgresql）
QSqlDatabase database = QSqlDatabase::addDatabase("QPSQL");
database.setDatabaseName("test");
database.setHostName("127.0.0.1");
database.setPort(54321);
database.setUserName("SYSTEM");
database.setPassword("123456");

//通过odbc数据源连接到各种数据库，前提是必须配置好数据源，只需要设置数据库名称为数据源的名称，填写用户名和密码就行，其他的主机地址和端口不需要。
QSqlDatabase database = QSqlDatabase::addDatabase("QODBC");
database.setDatabaseName("数据源名称");
database.setUserName("system");
database.setPassword("123456");


如果信号槽关联函数 connect(obj, SIGNAL(), this, SLOT()); 执行多次则会重复关联（意味着会执行多次），
而取消信号槽关联函数 disconnect(obj, SIGNAL(), this, SLOT()); 只需要执行一次就可以将之前关联的（哪怕是重复关联过）全部清除。
很多初学者会遇到为什么点一下居然执行多次的原因就在这里，很可能代码中写了 on_objName_clicked(); 这种Qt内置自动生成关联的槽函数，然后自己又在代码中调用 connect 绑定了一次，导致重复绑定。
提个建议：其实Qt可以过滤下如果是完全一样的绑定则认为是一个而不是多个。
//为了保证永远只有一个关联可以在关联前面执行一次取消关联
disconnect(obj, SIGNAL(), this, SLOT());
connect(obj, SIGNAL(), this, SLOT());

//经过群里大佬提示，原来connect第五个参数填 UniqueConnection 就可以避免这个问题，按照官方文档说明这个参数会过滤重复的信号。
connect(obj, SIGNAL(), this, SLOT(), Qt::UniqueConnection);


通过对Qt自带Examples的源码研究你会发现，越往后的版本，越喜欢用智能指针QScopedPointer来定义对象，
这样有个好处就是用的地方只管new就行，一直new下去，不用担心资源释放问题，智能指针会给你在合适的时机释放，
相当于可以少些一行代码 xxx->deleteLater(); ，而且避免不必要的麻烦，不然很多地方你要判断 if (!xxx) 看下对象是否ok。
QWidget *widget;
//用的地方先new
widget = new QWidget;
//用完释放对象
widget->deleteLater();  
    
//智能指针写法
QScopedPointer<QWidget> widget;
//只管new尽管new不用管释放
widget.reset(new QWidget);


在编写类中有时候需要对变量进行赋值和取值，这时候一般用 setxxx、getxxx 之类的函数进行处理，而且往往里面就一行代码，这时候你可能会思考为何不直接将变量改成public暴露出来使用，还可以省两个函数几行代码。其实用set get这样处理主要还是为了拓展性，比如后期如果需要对赋值进行过滤处理，或者该变量只允许读写中的一个，如果之前是直接使用的变量外，则使用的地方都要去修改规则，反而变得很糟糕。 参考文章 https://blog.csdn.net/ChineseSoftware/article/details/122923485 。


关于如何快速结束线程，调用terminate暴力结束容易出问题。
一般来说在run中msleep休息的时间过久，容易导致要很长一段时间才能正确停止，此时可以考虑一个策略就是分割线程执行体，
如果是函数体耗时可以在耗时的函数体中增加停止标志位的判断，使其快速跳出；
如果是延时时间过久可以将延时时间拆分成多个小的时间轮片，每个小的休息间隔都判断停止标志位，这样也可以大大加快线程
正常退出的速度而不用等待太久。
while (!stopped) {
        doTask();

        //下面这个延时太久导致退出很慢
        //msleep(3000);

        //特意每次做个小延时每次都去判断标志位等可以大大加快关闭速度，一旦stopped为true了 ，此线程就会快速停止下来
        int count = 0;
        while (!stopped) {
            msleep(100);
            count++;
            //如果到了30次=30*100=3000毫秒也跳出
            if (count == 30) {
                break;
            }
        }  
    }     


窗口关闭的时候会产生closeEvent事件，直接重写此事件即可在里面加入关闭的操作
protected:
    void closeEvent(QCloseEvent *);

void MainWindow::closeEvent(QCloseEvent *)
{
    //先把子窗体释放
    lab->deleteLater();
}

有一个场景经常遇到，那就是在符合某个条件下，延时一段时间去执行一段代码，如果短时间内触发多次又不需要频繁执行，只需要执行一次就行。如果选择用QTimer::singleShot无法终止已经触发的，这个时候就要主动实例化一个单次定时器，每次调用前都停止之前的（只要是还没执行都会取消），完美解决。
//QTimer::singleShot(1000, thread, SLOT(xxx()));  一旦开启无法取消

static QTimer *timer = NULL;  下面的方法每次执行都会停止之前的SingleShot，重新开始计时
if (!timer) {
    timer = new QTimer;
    QObject::connect(timer, SIGNAL(timeout()), thread, SLOT(xxx()));
    timer->setSingleShot(true);
    timer->setInterval(1000);
}
timer->stop();
timer->start();


Qt中的事件过滤器相当于万能大法（终极秘密武器），尤其是对整个应用程序安装事件过滤器，则可以拿到所有的事件。
比如可以拿到系统标题栏鼠标按下松开，对所有需要移动的无边框窗体统一拦截进行移动处理。
个人建议不到万不得已不建议使用，有一定性能损耗，毕竟这个是从最初源头拦截事件，意味着所有的事件都会到这里过一遍。
如果你在收到对应事件后还做了一定耗时的处理，很容易就卡主了UI主线程。
installEventFilter(this);  先安装事件探测器
重新事件处理函数
bool Widget::eventFilter(QObject *watched, QEvent *event)
{
    if (event->type() == QEvent::NonClientAreaMouseButtonPress) {
        qDebug() << "系统标题栏按下";
    } else if (event->type() == QEvent::NonClientAreaMouseButtonRelease) {
        qDebug() << "系统标题栏松开";
    }

    if (event->type() == QEvent::MouseButtonPress) {
        qDebug() << "shubiao按下";
    } else if (event->type() == QEvent::MouseButtonRelease) {
        qDebug() << "shubiao松开";
    }

    if (event->type() == QEvent::MouseMove) {
        qDebug() << "鼠标呗移动";
    }
    
    return QObject::eventFilter(watched, event);
}


关于c++中继承多态virtual和override的几点总结：
1.子类可以直接使用基类中的protected下的变量和函数。
2.基类函数没加virtual，子类有相同函数，实现的是覆盖。用基类指针调用时，调用到的是基类的函数；用子类指针调用时，调用到的是子类的函数。
  基类函数加了virtual时，实现的时重写。用基类指针或子类指针调用时，调用到的都是子类的函数。
3.函数加上override，强制要求子类相同函数需要是虚函数，而且必须重新实现，否则会编译报错。
4.基类中的纯虚函数（virtual void play() = 0;）在基类中无需在cpp中实现，但是必须在子类实现，否则编译报错。
5.继承多态最大的好处就是提炼共性，将通用的变量和方法信号等，全部放在基类，子类负责实现自己需要的特殊的部分即可。


Qt内置了数据压缩和解压的功能，如果遇到图片、音频数据、文件等转base64传输这种，采用qCompress压缩后大概可以节省30%的数据传输量，压缩性能可观。前提是双方都是Qt程序，因为收到数据的时候还要用qUncompress解压出来，成对出现的。
//发送的时候压缩下数据
QByteArray buffer = "...";
buffer = qCompress(buffer);
socket->write(buffer);

//收到数据后务必记得先解压再使用
QByteArray data = socket->readAll();
data = qUncompress(data);








1.qt核心：元对象系统，属性系统，对象模型，对象树，信号槽
2.如果在当前类没找到对应的函数，去父类 爷爷类查找

3.出现崩溃和段错误，80%都是因为要么越界，要么未初始化，死扣这两点，80%的问题解决了
4.Qt5选用5.12.3，Qt4选用4.8.7，Qt6选用6.5.x。

5.包含了Qt头文件之后再包含非Qt头文件，由于Qt（为编译器和预处理器）定义了许多符号，这使得避免名称冲突变得更容易，也更容易找到文件。

6.一种好的编程实践是在代码中使用const实体而不是嵌入数字型常量（有时称他们为“幻数”）。
如果以后需要修改他的值时，就可以获得这种灵活性。一般而言，将常量“孤立”出来，可提高程序的可维护性。
//不推荐写法
for (int i = 0; i < 100; ++i) {
    ...
}
//推荐下面的写法
const int count = 100;
for (int i = 0; i < count; ++i) {
    ...
}
7.只要有可能，就应当使用列表而不是数组，比如应该使用 QList 代替 int [] ，在c++中数组被看成是“邪恶的”


qml 写法：
查看官方提供的demo就是最完美的，qt-》欢迎--》示例--寻找想了解的控件用法 点进去看示例demo


=======






qml：
qml与qt quick的关系 就像C++与C++标准库的关系
风车寻转：
Window {
	后台界面属性
    visible: true
    width: 500   //uiname.width   	//640  可以直接填数字，也可以直接根据Imag中图片的宽高去设置
    height: 300  //uiname.height  	//480
    title: qsTr("circle cirlce")

	//加入图片 风车
    Image {
        //anchors.fill: parent;  //图片填充 界面
        anchors.verticalCenter: parent.verticalCenter
        anchors.horizontalCenter: parent.horizontalCenter
        id: uiname
        source: "../images/windcar.png"
		
		//描述 风车转的 属性 每次转500ms  转360°
        Behavior on rotation{
            NumberAnimation {
                duration: 500   //单位ms  500ms内 转360°
            }
        }
		
		//放到这里只有点击风车 才会转
//        MouseArea{
//            anchors.fill: parent
//            onClicked: uiname.rotation+=60
//        }
    }

    Image {
        //设置杆的位置
        anchors.bottom: parent.bottom
        anchors.horizontalCenter: parent.horizontalCenter
        id: gan
        source: "../images/gan.png"

    }

//    放到这里随便在屏幕中点击风车都会转
    MouseArea{
        anchors.fill: parent
        onClicked: uiname.rotation+=360
    }
}


demo2:
Rectangle {
    id:root  //一般根起个名字
    visible: true
    width: 500;height: 300
    color:"#4a4a4a"

    //往root添加 类型Image + 属性{}中的内容
    Image {
        id: fengche
        source: "../images/windcar.png"
        x:(root.width-width)/2;//居中显示，这里的root也可以写成parent root是父节点名称 parent表示当前fengche的父亲
        y:(root.height-height)/2
    }
    //往root添加 类型Image + 属性{}中的内容
    Text {
        text: qsTr("大风车 转呀转")
        color:"white"
        //x:(root.width)/2-80;//居中显示
        //y:(root.height)/2+80

        //下面利用属性的方式对齐
        horizontalAlignment: Text.AlignHCenter
        verticalAlignment: Text.AlignVCenter
        width: root.width
        height: root.height
    }
}

demo3:
Text {
	id:thatlabel
	//自定义属性 空格按了多少次 初始为0
	property int spacePress: 0
	text:"thatlabel "+spacePress+" times"
	color:"white"
	//文本改变调用
	onTextChanged: function(text){console.log("text change to:",text)}

	focus:true //只有focus为true 才能收到Keys的事件
	Keys.onSpacePressed : {increment()}
	这句一执行就解除了之前tet的绑定，并不是focus变成了false，只是=是赋值，会解除绑定
	Keys.onEscapePressed: {thatlabel.text=""}  
	function increment(){  //定义函数
		spacePress++;
	}
}


MouseArea{
	width:parent.width
	heigth:parent.height
	onClicked: rec.visible=!rec.visible   鼠标在父窗口 被按下 则rec显示/隐藏
}


demo4：引用qml文件：
