qmainwindow（菜单栏，工具栏）与qdialog（对话框）都是继承qwidget，
qwidget的父类是所有对象的祖宗QOBJECT
QApplication a(argc, argv);//应用程序对象，有且只有一个
myWidget w; //实例化窗口对象
ctrl+shift+↑/↓ 将当前行移动到上方或者下方
同名的.h与.cpp切换，按键F4
选中多行，按ctrl+i自动对齐多行
查看帮助文档：打开bin文件夹下的assistant.exe 可以直接打开帮助文档
Qdialog：对话框（里面一般按钮较少，登陆页面啦、出错界面、下一步界面）
.pro中的target=test生成的exe的名称就是text.exe
Q_OBJECT 有这个宏表示允许使用信号和槽机制
函数声明与定义中只有1个里面允许有默认参数=0...
	btn的op：settext（“设置文本”）；
			setparent（this）；-------直接Qpushbutten * btn = new Qpushbutten（“文本”，this）；设置到对象树中
			move（100,100）；坐标从左上角开始数
			resize（100,100）；

	qt里面私有属性里面一般都是qpushubutten * btn；然后在构造函数中new出来的
	也可以在类里面直接QPushButton btn;在构造函数中settext，setparent

	窗口设置标题直接：setwindowtitle（“窗口标题”）；
	设置固定的窗口大小：setfixedsize（600,400）；
	调整窗口大小。直接resize（600,400）；其实可以this->resize()。也可以默认直接resize就可以。

	qDebug（）<<“sadasd”；
	或者qDebug（“sadasdd”）；自动换行的
对象树，创建的时候由上至下，析构的时候由下至上，只要是下级属于上级的对象，析构的时候父对象会帮你析构
子对象的析构函数自己还是得去实现，只是这个函数的调用是父对象去管理的，并不是它帮忙实现的。

                也可以写成&Mybut::clicked,this,&Mybut::close，必须是类名，如果子类继承父类自然信号函数也继承了。
				不可以直接写对象或者对象地址，必须写类::信号
	connect(&btn,&QPushButton::clicked,this,&QPushButton::close);
			信号发出对象地址				信号接收对象地址
			信号类型地址					槽函数地址
	connect(sock,SIGNAL(connected()),this,SLOT(on_connected()));
			SIGNAL（默认会选择sock的父类里面的信号，不用再加作用域了括号中的函数要加参数类型
	connect(sock,SIGNAL(error(QAbstractSocket::SocketError)),this,SLOT(on_error()));
								这是error信号的参数类型，不用加形参名		

	connect(sock,SIGNAL(error(QAbstractSocket::SocketError)),this,SLOT(on_error()));
	connect连接中信号只写类型不写形参，slot可以参数比signal少。
				槽函数声明的时候信号也可以只写类型，不写形参，在定义的时候再写形参。
	注意自定义的类才可以自定义信号和槽函数&&&&&&：自定义槽函数时要在头文件中加：
	public slots:   信号加到signals：下。自定义的信号只需要头文件声明一下就好了,不需要实现
	返回值是void，可以有参数，可以重载。
    								 void btn_deal();
	槽函数直接写到public中即可，类似普通的函数
	返回值void，需要声明，也需要实现，可以有参数，也可以重载
	
	信号与槽都写完之后只需要connect即可，然后等着触发此信号即可。
	exp:在widget中connect(t1,&Teachar::hungry,st,&Student::eat);
	
   	自定义的信号怎么触发这个信号呢？？	
   	可以在widget中定义一个普通的函数，调用这个函数就会emit signal
   	{
   		emit t1->hungry();		//通过在widget的构造函数中调用这个函数去发信号。构造函数在创建mywidget的时候就会执行内部所有的东西
   	}

    如果自定义的类不属于任何别控件，应该让他继承与QObject-----这样他就不用管自己的内存释放了。这个类会管理内存的...

    connect信号可以连接信号的***，触发信号1则触发信号2
	
    QString转char*；s.toutf8().data(); qstring->qbytearray->char*
	QString str = QString("abc %1 ^_^ %2").arg(123).arg("mike");  格式化字符串
	qstring打印时默认带“”，char *打印时不带“”

	对于重载的signal函数与slot函数调用的时候函数名字都一样怎么区分呀？
	通过制定函数类型：
	void (Teacher::var)(QString) = &Teachar::hungry;  定义的(sig或者slot一样)函数指针变量var就是&Teachar::hungry，
	而且这个变量指向，返回值void，参数是qstring的hungry，而不是空入参的hungry。

    1个新号怎么调用多个槽函数呢？用lambda表达式
    lambda表达式：定义并创建匿名函数对象  
    [=](){		[]中放：	=等号用的最多  	&
    	btn->settext("12");
    };中括号小括号大括号
	connect(btn,&QPushubutton::clicked,this,[=]()
	{
		this->close();
		emit 另一个信号()；
		...外面的变量函数都能在这里面调用。。。
	})
	如何新建另一个窗口？？connect按钮按下则调用lambda表达式【=】（）{
		QDialog dlg；
		dlg。exec（）；就ok了
	}
	qt资源文件：添加文件->resource file->open in edit->设置路径名，以后用资源的时候复制路径就可以

	qt样式表：控件的样式
		设置按键，label，主窗口的样子-背景字体...
	qt的lable还可以显示图片，gif，可跳转的域名
		

	事件类似一个个的软件中断*****	
	qt中所有的事件类都继承与qevent	，bool event（QEvent*）ev）函数不直接处理事件，而是按照事件类型分派给
	特定的事件处理函数。在函数体内把自己想处理的事处理一下，其他事件交给父类处理，你不可能处理所有的事件。
	qwidget中定义了很多事件处理函数都是虚的，可以在子类重新实现的。
	protected ：
	***事件不用connect，写好了发生就可以触发事件函数。	
	QString str = QString("abc %1 ^_^ %2").arg(123).arg("mike");
		str = abc 123 ^_^ mike  类似sprintf
	鼠标按下事件：在一个mylabel的类中实现的
	但是键盘按下的键得在mywidget中实现，因为键盘按下的事件只有主窗口才能收到，但是鼠标的按下事件是按在了label中，mylabel可以接收到
	定时器也一种事件：timerevent。可以在mywidget中重写虚函数
					同时定时器需要在mtwidget中去starttimer

	图片：绘图看例子，很详细
		QPmixmap pix；pix.load("路径")。设置参数
		p.draw(0,0,pix);

	
	主窗口控制事件分发：
			在mainwindow中：重定义event（）将传进来的实体化的QEvent *e事件，根据类型选择对应的处理函数
								{
									switch事件（e->type（））
									 == xxx    mousemove事件；
									 == xxx    closeevent事件；
								}
	连接sqlite：
	messageBox:：warning（this，“wrong”）出错弹出对话框用到。


	qt的静态库要自己编译所以一般使用动态库。
	将写好的qt程序编译成release版本，copy生成的app.exe到一个新目录，qtshell，Qt命令行(左下角)
			然后用windeployqt.exe ./app.exe操作，会将它需要的动态库文件都放到此文件夹
			或者：cd /d D:\现在新建的存app.exe的目录   F:as\d\d\d\windeployqt.exe .\自己的.exe
	代码编译不一定非要用qt软件内点击鼠标：
			1.直接使用qmake.exe进行qmake，然后使用mingw32-make.exe进行make就会生成app.exe。 
	qt中函数alt+enter自动补全
	
易错点：定义变量放在.h文件中，不然.c中其他函数无法访问。
     在当前类的.cpp文件中访问当前类的成员，可以通过this->shuxing（fun）或者直接调用成员属性（方法），不加this都可以。

串口收发参考连接：https://blog.csdn.net/qq_39017187/article/details/88935705

定时器：
1.QTimer * timer=new QTimer(this);
    timer->start(500);
    connect(timer,&QTimer::timeout,this,[=](){
        qDebug()<<"shijiandao";
    });
2.监听timerEvent();事件，不推荐哦

ctrl+i：全选后，所有行自动对齐
QT_CHARTS_USE_NAMESPACE：首行需要加命名空间	
直接参考example文件中的c文件。

QLineSeries定义的变量series要add到QChart定义的变量chart中去，charts最后要加到QChartView chartView变量中去，
最后chartView又要加到QMainWindow  window.setCentralWidget(chartView)中去。

可以参考QT左上角的欢迎->示例

绘制各种图形举例：https://blog.csdn.net/lwbeyond/article/details/41479809?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.control


qt：编译报错  Error while building/deploying project all-class-in-one (kit: Desktop Qt 5.10.1 …
When executing step “qmake”
改工程所在的路径不能有中文出现，改完后重新打开工程编译即可
-------------------------------老贺发的资料----------------------------各种对话框
QGridLayout* gridLayout = new QGridLayout;布局管理器
可以通过gridLayout对象去布局当前界面中各个控件的位置：
gridLayout->addWidget(colorPushBtn, 0, 0, 1, 1);
setLayout(gridLayout);最后通过setlayout启用设置结果

不同的按钮按下可以调用同一个槽函数：
connect(colorPushBtn, SIGNAL(clicked()), this, SLOT(doPushBtn()));
void CBuiltinDlg::doPushBtn()
{
#当QPushButton发出一个信号时就记录发出这个信号的对象，sender获取发出信号的对象；
#当有多个OBject发出信号时可根据sender()函数判断是哪个对象发出的；然后qobject_cast类型转换为QPushButton类型
    QPushButton* btn = qobject_cast<QPushButton*>(sender());
    if(btn == colorPushBtn) {// 如果被按下的是颜色对话框.
        QPalette palette = displayTextEdit->palette();//创建textedit对象的调色板
        const QColor& color = QColorDialog::getColor(palette.color(QPalette::Base), this);//获取选择的颜色
        if(color.isValid()) {
            palette.setColor(QPalette::Base, color);//设置调色板颜色
            displayTextEdit->setPalette(palette);//将调色板颜色设置到textedit
        }
    }
    else if(btn == errorPushBtn) {//如果被按下的是错误信息框.
        QErrorMessage box(this);//创建qerrormessage对象
        box.setWindowTitle(tr("错误信息框"));//设置标题
        box.showMessage(tr("错误信息框实例xx。"));//错误内容
        box.exec();//对话框不退出
    }
    else if(btn == filePushBtn) {// 文件对话框.
        QFileDialog *fileDialog = new QFileDialog(this);
        fileDialog->setWindowTitle(tr("Open Image"));
        fileDialog->setDirectory(".");//设置当前目录

		QStringList filter;//文件过滤器
		filter << "*.jpg" << "*.png" << "*.bmp" << "*.gif";//过滤的文件名后缀
		fileDialog->setNameFilters(filter);//设置过滤器生效
        if(fileDialog->exec() == QDialog::Accepted) {
            QString path = fileDialog->selectedFiles()[0];//获取路径
            displayTextEdit->setText(path);//显示路径
        }
    }
    else if(btn == fontPushBtn) {// 字体对话框.
        bool ok;
        const QFont& font = QFontDialog::getFont(&ok,//给ok变量赋值
                                    displayTextEdit->font(),//获取当前textedit字体
                                    this,
                                    tr("字体对话框"));
        if(ok) {// 如果<确定>,设置字体.
            displayTextEdit->setFont(font);//给textedit设置字体
        }
    }
    else if(btn == inputPushBtn){// 输入对话框.
        bool ok;
        QString text = QInputDialog::getText(this,
                                            tr("输入对话框"),
                                            tr("输入文本："),
                                            QLineEdit::Normal,
                                            QDir::home().dirName(),
                                            &ok);
        if (ok && !text.isEmpty())
           displayTextEdit->setText(text);
    }
    else if(btn == pagePushBtn) {// 页设置对话框.
        QPrinter printer;
        QPageSetupDialog dlg(&printer, this);
        dlg.setWindowTitle(tr("页设置对话框"));
        if (dlg.exec() == QDialog::Accepted) {
            // 进行下一步的处理。
        }
    }
    else if(btn == progressPushBtn) {// 进度对话框.
        QProgressDialog progress(tr("正在复制文件..."), tr("取消"), 0, 1000, this);
        QFont font("ZYSong18030",10);
        progress.setFont(font);

        progress.setWindowModality(Qt::WindowModal);
        progress.setWindowTitle(tr("进度对话框"));
        progress.show();
        for (int i = 0; i < 1000; i++) {
            progress.setValue(i);
            qApp->processEvents();
            if (progress.wasCanceled())
                break;
            QTest::qWait(1);
            //... 复制文件处理。
        }
        progress.setValue(1000);
    }
    else if(btn == printPushBtn) {// 打印对话框.
        QPrinter printer;
        QPrintDialog dlg(&printer, this);
        dlg.setWindowTitle(tr("打印对话框"));
        if (dlg.exec() == QDialog::Accepted) {
            // 进行下一步的处理。
        }
    }
}

同时打开多个文件的对话框：
void CBuiltinDlg::MultiOpenFile()
{
    QStringList files = QFileDialog::getOpenFileNames(
                                    this, tr("Select one or more files to open"),//弹框标题
                                    "/",
                                    tr("All Files (*);;Text Files (*.txt)"));//过滤设置
    if (files.count()) {//如果选中的文件不是0个
      displayTextEdit->setText(QString("[%1]").arg(files.join(", ")));//将所有选中文件的路径显示到edit
    }
}
向导对话框：
void CBuiltinDlg::slotWizard()
{
    QWizard wizard;//创建向导
    wizard.addPage(createFirstPage());//对话框有2页
    wizard.addPage(createSecondPage());

    wizard.setWindowTitle(tr("向导对话框"));
    wizard.exec();
}
QWizardPage* CBuiltinDlg::createFirstPage()
{
    QWizardPage *page = new QWizardPage;//向导对话框中的页内容
    page->setTitle(tr("简介"));
    QLabel *label = new QLabel(tr("第一页"));
    label->setWordWrap(true);有没有好像没啥变化
	
    QVBoxLayout *layout = new QVBoxLayout;//布局器
    layout->addWidget(label);
    page->setLayout(layout);
    return page;
}
QWizardPage* CBuiltinDlg::createSecondPage()
{
     QWizardPage *page = new QWizardPage;
     page->setTitle(tr("正文"));
     QLabel *label = new QLabel(tr("第二页"));
     label->setWordWrap(true);
	 
     QVBoxLayout *layout = new QVBoxLayout;//布局器
     layout->addWidget(label);
     page->setLayout(layout);让布局器去布局
     return page;
}

错误信息框：
QMessageBox::critical(this, tr("错误"),tr("告诉用户一个严重的错误!"));

告警信息对话框：
void CBuiltinDlg::slotWarning()
{
    switch(QMessageBox::warning(this,tr("警告"),tr("是否要保存文档?"),
            QMessageBox::Save|QMessageBox::Discard|QMessageBox::Cancel,QMessageBox::Save))
    {
    case QMessageBox::Save:
        displayTextEdit->setText(tr("警告对话框 / 保存"));
        break;
    case QMessageBox::Discard:
        displayTextEdit->setText(tr("警告对话框 / 不保存"));
        break;
    case QMessageBox::Cancel:
        displayTextEdit->setText(tr("警告对话框 / 取消"));
        break;
    default:
        break;
    }
}
询问消息框：
void CBuiltinDlg::slotQuestion()
{//tr("询问")是标题    tr("重新开始?")是内容   下面是多个按钮
    switch(QMessageBox::question(this,tr("询问"),tr("重新开始?"),
            QMessageBox::Ok|QMessageBox::Cancel,QMessageBox::Ok))
    {
    case QMessageBox::Ok:
        displayTextEdit->setText(tr("询问按钮 / 确定"));
        break;
    case QMessageBox::Cancel:
        displayTextEdit->setText(tr("询问按钮 / 取消"));
        break;
    default:
        break;
    }
}

函数 tr()全名是QObject::tr(),被它处理的 字符串可以 使用工具提 取出来翻译 成其他语言, 也就是做国际化使用。
只要记住,Qt 的最佳实践:如果你想让你的程序国际化的话,那么,所有用户可见的字符串都要使用 QObject::tr()!
但是,为什么我们没有写 QObject::tr(),而仅仅是 tr()呢?原来,tr()函数是定义在 Object里面的,所有使用了 Q_OBJECT 宏的类都自动具有 tr()函数。

qcustomplot库
QTimer mDataTimer;
connect(&mDataTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));  得先connect再start，每40ms执行timerslot函数。
mDataTimer.start(40);

我们可以根据qt代码目录编译后生成的buildxx目录看到之前编译此工程的qt是哪个版本。
正则表达式控制textedit的输入值：
QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");regExp可接收数据被确定
ui->lineEdit->setValidator(new QRegExpValidator(regExp, this));只有有效的数据才能被写到lineedit
//lineedit文本发生改变才进入slot函数
connect(ui->lineEdit, SIGNAL(textChanged(const QString&)), this, SLOT(on_lineEdit_textChanged()));
void GoToCellDialog::on_lineEdit_textChanged()//只有lineedit满足要求ok按钮才能被点击
{
	ui->okButton->setEnabled(ui->lineEdit->hasAcceptableInput());
}
-------------目录操作
m_appFolder = QDir(QApplication::applicationDirPath());获取当前工程目录路径

QDir imageFolder = m_appFolder;
imageFolder.cdUp();//进入上层目录
imageFolder.cdUp();
imageFolder.cd("src");//进入src目录
imageFolder.cd("charts");//再进入charts目录
imageFolder.cd("doc");
imageFolder.cd("images");


QT工程pro文件模板变量（TEMPLATE）
subdirs - 这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。
app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。


tabwidget用法-------------与table widget不一样，这个是容器
setTabIcon(0,QIcon("E:\\Qt_Project\\QTabWidget\\1.ico"));//设置第1个选项卡的图标 
setTabPosition(QTabWidget::South);//设置选项卡的方位东南西北，默认在上方
//用stringlist给表格添加表头
QStringList m_Header;
m_Header<<QString("田径")<<QString("篮球")<<QString("足球")<<QString("乒乓球")<<QString("羽毛球")<<QString("游泳");
ui->tableWidget->setHorizontalHeaderLabels(m_Header);//添加横向表头，表头这行不算在数据行之内
可视化加了，显示没什么变化
ui->tableWidgetSports->verticalHeader()->setVisible(true);//纵向表头可视化
ui->tableWidgetSports->horizontalHeader()->setVisible(true);//横向表头可视化

给表格填数据的方法：6列10行
for(int rows=0;rows<10;rows++)//遍历行
{
	for(int columns=0;columns<6;columns++)//遍历列
	{
	ui->tableWidget->setItem(rows,columns,new QTableWidgetItem("刘翔"));给row行colums列增加数据new QTableWidgetItem("string变量")
	}
}

for(int rows=0;rows<10;rows++)//循环设置每个表格中文字属性，类似excel中的设置--得一个一个设置吗？太麻烦了吧
{
	for(int columns=0;columns<6;columns++)
	{
		ui->tableWidget->setColumnWidth(columns,125);
		ui->tableWidget->setRowHeight(rows,30);
		ui->tableWidget->item(rows,columns)->setTextAlignment(Qt::AlignCenter);//居中显示
		ui->tableWidget->item(rows,columns)->setBackgroundColor(QColor(85,170,255));//设置前景颜色
		ui->tableWidget->item(rows,columns)->setTextColor(QColor(0,0,0));//设置文本颜色
		ui->tableWidget->item(rows,columns)->setFont(QFont("Helvetica"));//设置字体为黑体
	}
}