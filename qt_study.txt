qmainwindow（菜单栏，工具栏）与qdialog（对话框）都是继承qwidget，
qwidget的父类是所有对象的祖宗QOBJECT
QApplication a(argc, argv);//应用程序对象，有且只有一个
myWidget w; //实例化窗口对象
ctrl+shift+↑/↓ 将当前行移动到上方或者下方
同名的.h与.cpp切换，按键F4
选中多行，按ctrl+i自动对齐多行
查看帮助文档：打开bin文件夹下的assistant.exe 可以直接打开帮助文档
Qdialog：对话框（里面一般按钮较少，一般用于设计登陆页面啦、出错界面、下一步界面）
.pro中的target=test生成的exe的名称就是text.exe
Q_OBJECT 有这个宏表示允许使用信号和槽机制
函数声明与定义中只有1个里面允许有默认参数=0...
	btn的op：settext（“设置文本”）；
			setparent（this）；-------直接Qpushbutten * btn = new Qpushbutten（“文本”，this）；设置到对象树中
			move（100,100）；坐标从左上角开始数
			resize（100,100）；

	qt里面私有属性里面一般都是qpushubutten * btn；然后在构造函数中new出来的
	也可以在类里面直接QPushButton btn;在构造函数中settext，setparent

	窗口设置标题直接：setwindowtitle（“窗口标题”）；
	设置固定的窗口大小：setfixedsize（600,400）；
	调整窗口大小。直接resize（600,400）；其实可以this->resize()。也可以默认直接resize就可以。

	qDebug（）<<“sadasd”；
	或者qDebug（“sadasdd”）；自动换行的
对象树，创建的时候由上至下，析构的时候由下至上，只要是下级属于上级的对象，析构的时候父对象会帮你析构
子对象的析构函数自己还是得去实现，只是这个函数的调用是父对象去管理的，并不是它帮忙实现的。

                也可以写成&Mybut::clicked,this,&Mybut::close，必须是类名，如果子类继承父类自然信号函数也继承了。
				不可以直接写对象或者对象地址，必须写类::信号
	connect(&btn,&QPushButton::clicked,this,&QPushButton::close);
			信号发出对象地址				信号接收对象地址
			信号类型地址					槽函数地址
	connect(sock,SIGNAL(connected()),this,SLOT(on_connected()));
			SIGNAL（默认会选择sock的父类里面的信号，不用再加作用域了括号中的函数要加参数类型
	connect(sock,SIGNAL(error(QAbstractSocket::SocketError)),this,SLOT(on_error()));
								这是error信号的参数类型，不用加形参名		

	connect(sock,SIGNAL(error(QAbstractSocket::SocketError)),this,SLOT(on_error()));
	connect连接中信号只写类型不写形参，slot可以参数比signal少。
				槽函数声明的时候信号也可以只写类型，不写形参，在定义的时候再写形参。
	注意自定义的类才可以自定义信号和槽函数&&&&&&：自定义槽函数时要在头文件中加：
	public slots:   信号加到signals：下。自定义的信号只需要头文件声明一下就好了,不需要实现
	返回值是void，可以有参数，可以重载。
    								 void btn_deal();
	槽函数直接写到public中即可，类似普通的函数
	返回值void，需要声明，也需要实现，可以有参数，也可以重载
	
	信号与槽都写完之后只需要connect即可，然后等着触发此信号即可。
	exp:在widget中connect(t1,&Teachar::hungry,st,&Student::eat);
	
   	自定义的信号怎么触发这个信号呢？？	
   	可以在widget中定义一个普通的函数，调用这个函数就会emit signal
   	{
   		emit t1->hungry();		//通过在widget的构造函数中调用这个函数去发信号。构造函数在创建mywidget的时候就会执行内部所有的东西
   	}

    如果自定义的类不属于任何别控件，应该让他继承与QObject-----这样他就不用管自己的内存释放了。这个类会管理内存的...

    connect信号可以连接信号的***，触发信号1则触发信号2
	
    QString转char*；s.toutf8().data(); qstring->qbytearray->char*
	QString str = QString("abc %1 ^_^ %2").arg(123).arg("mike");  格式化字符串
	qstring打印时默认带“”，char *打印时不带“”

	对于重载的signal函数与slot函数调用的时候函数名字都一样怎么区分呀？
	通过制定函数类型：
	void (Teacher::var)(QString) = &Teachar::hungry;  定义的(sig或者slot一样)函数指针变量var就是&Teachar::hungry，
	而且这个变量指向，返回值void，参数是qstring的hungry，而不是空入参的hungry。

    1个新号怎么调用多个槽函数呢？用lambda表达式
    lambda表达式：定义并创建匿名函数对象  
    [=](){		[]中放：	=等号用的最多  	&
    	btn->settext("12");
    };中括号小括号大括号
	connect(btn,&QPushubutton::clicked,this,[=]()
	{
		this->close();
		emit 另一个信号()；
		...外面的变量函数都能在这里面调用。。。
	})
	如何新建另一个窗口？？connect按钮按下则调用lambda表达式【=】（）{
		QDialog dlg；
		dlg。exec（）；就ok了
	}
	qt资源文件：添加文件->resource file->open in edit->设置路径名，以后用资源的时候复制路径就可以

	qt样式表：控件的样式
		设置按键，label，主窗口的样子-背景字体...
	qt的lable还可以显示图片，gif，可跳转的域名
		
---------------------事件 
	事件类似一个个的软件中断*****	
	qt中所有的事件类都继承与qevent	，bool event（QEvent*）ev）函数不直接处理事件，而是按照事件类型分派给
	特定的事件处理函数。在函数体内把自己想处理的事处理一下，其他事件交给父类处理，你不可能处理所有的事件。
	qwidget中定义了很多事件处理函数都是虚的，可以在子类重新实现的。
	protected ：
	***事件不用connect，写好了发生就可以触发事件函数。	
	QString str = QString("abc %1 ^_^ %2").arg(123).arg("mike");
		str = abc 123 ^_^ mike  类似sprintf
	鼠标按下事件：在一个mylabel的类中实现的
	但是键盘按下的键得在mywidget中实现，因为键盘按下的事件只有主窗口才能收到，但是鼠标的按下事件是按在了label中，mylabel可以接收到
	定时器也一种事件：timerevent。可以在mywidget中重写虚函数
					同时定时器需要在mtwidget中去starttimer
	图片：绘图看例子，很详细
		QPmixmap pix；pix.load("路径")。设置参数
		p.draw(0,0,pix);

	
	主窗口控制事件分发：
			在mainwindow中：重定义event（）将传进来的实体化的QEvent *e事件，根据类型选择对应的处理函数
								{
									switch事件（e->type（））
									 == xxx    mousemove事件；
									 == xxx    closeevent事件；
								}
	连接sqlite：
	messageBox:：warning（this，“wrong”）出错弹出对话框用到。
	
	
关于QT事件(event)的简单介绍
　　　事件(event)是有系统或者Qt本身在不同的时刻发出的。当用户按下鼠标，敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件是在对用户操作做出响应的时候发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。
　　一般来说，使用Qt编程时，我们并不会把主要精力放在事件上，因为在Qt中，需要我们关心的事件总会发出一个信号。比如，我们关心的 QPushButton的鼠标点击，但我们不需要关心这个鼠标点击事件，而是关心它的clicked()信号。

　　Qt的事件很容易和信号槽混淆。这里简单的说明一下，signal由具体对象发出，然后会马上交给由connect函数连接的slot进行处理；
	而对于事件，Qt使用一个事件队列对所有发出的事件进行维护，当新的事件产生时，会被追加到事件队列的尾部，前一个事件完成后，取出后面的事件进行处理。但是，必要的时候，Qt的事件也是可以不进入事件队列，而是直接处理的。并且，事件还可以使用“事件过滤器”进行过滤。
	总的来说，如果我们使用组件，我们关心的是信号槽；如果我们自定义组件，我们关心的是事件。因为我们可以通过事件来改变组件的默认操作。比如，如果我们要自定义一个QPushButton，那么我们就需要重写它的鼠标点击事件和键盘处理事件，并且在恰当的时候发出clicked()信号。
　　还记得我们在main函数里面创建了一个QApplication对象，然后调用了它的exec()函数吗？其实，这个函数就是开始Qt的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt将创建一个事件对象。Qt的所有事件都继承于 QEvent类。在事件对象创建完毕后，Qt将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数(event handler)。
　　在所有组件的父类QWidget中，定义了很多事件处理函数，如keyPressEvent()、keyReleaseEvent()、mouseDoubleClickEvent()、mouseMoveEvent ()、mousePressEvent()、mouseReleaseEvent()等。这些函数都是protected virtual的，也就是说，我们应该在子类中重定义这些函数


class　EventLabel　:　public　QLabel
{
protected:
　　　　void　mouseMoveEvent(QMouseEvent　*event);
　　　　void　mousePressEvent(QMouseEvent　*event);
　　　  void　mouseReleaseEvent(QMouseEvent　*event);
};
void　EventLabel::mouseMoveEvent(QMouseEvent　*event)
{
this->setText(QString("Move:　(%1,　%2)").arg(QString::number(event->x()).arg(QString::number(event->y())));
}
void　EventLabel::mousePressEvent(QMouseEvent　*event)
{
　this->setText(QString("Press:　(%1,　%2)").arg(QString::number(event->x()).arg(QString::number(event->y())));
}
void　EventLabel::mouseReleaseEvent(QMouseEvent　*event)
{
　　　QString　msg;
　　　msg.sprintf("Release:　(%d,　%d)",event->x(),　event->y());//与上面的显示不一样的语法
　　　this->setText(msg);
}
int　main(int　argc,　char　*argv[])//事件不需要connect slot函数就可以触发，只需要重载事件处理函数即可，这些处理函数在父类种不做处理
{
　　　QApplication　app(argc,　argv);
　　　EventLabel　*label　=　new　EventLabel;
　　　label->setWindowTitle("MouseEvent　Demo");
　　　label->resize(300,　200);
　　　label->show();
　　　return　app.exec();
}
　　这里我们继承了QLabel类，重写了mousePressEvent、mouseMoveEvent和MouseReleaseEvent三个函数。我们并没有添加什么功能，只是在鼠标按下(press)、鼠标移动(move)和鼠标释放(release)时把坐标显示在这个Label上面。
注意我们在mouseReleaseEvent函数里面有关QString的构造。我们没有使用arg参数的方式，而是使用C语言风格的sprintf来构造QString对象

----------------------------------------------------------------------------

	qt的静态库要自己编译所以一般使用动态库。
	将写好的qt程序编译成release版本，copy生成的app.exe到一个新目录，qtshell，Qt命令行(左下角)
			然后用windeployqt.exe ./app.exe操作，会将它需要的动态库文件都放到此文件夹
			或者：cd /d D:\现在新建的存app.exe的目录   F:as\d\d\d\windeployqt.exe .\自己的.exe
	代码编译不一定非要用qt软件内点击鼠标：
			1.直接使用qmake.exe进行qmake，然后使用mingw32-make.exe进行make就会生成app.exe。 
	qt中函数alt+enter自动补全
	
易错点：定义变量放在.h文件中，不然.c中其他函数无法访问。
     在当前类的.cpp文件中访问当前类的成员，可以通过this->shuxing（fun）或者直接调用成员属性（方法），不加this都可以。

串口收发参考连接：https://blog.csdn.net/qq_39017187/article/details/88935705

定时器：
1.QTimer * timer=new QTimer(this);
    timer->start(500);
    connect(timer,&QTimer::timeout,this,[=](){
        qDebug()<<"shijiandao";
    });
2.监听timerEvent();事件，不推荐哦

ctrl+i：全选后，所有行自动对齐
QT_CHARTS_USE_NAMESPACE：首行需要加命名空间	
直接参考example文件中的c文件。

QLineSeries定义的变量series要add到QChart定义的变量chart中去，charts最后要加到QChartView chartView变量中去，
最后chartView又要加到QMainWindow  window.setCentralWidget(chartView)中去。

可以参考QT左上角的欢迎->示例

绘制各种图形举例：https://blog.csdn.net/lwbeyond/article/details/41479809?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.control


qt：编译报错  Error while building/deploying project all-class-in-one (kit: Desktop Qt 5.10.1 …
When executing step “qmake”
改工程所在的路径不能有中文出现，改完后重新打开工程编译即可
-------------------------------老贺发的资料----------------------------各种对话框
QGridLayout* gridLayout = new QGridLayout;布局管理器
可以通过gridLayout对象去布局当前界面中各个控件的位置：
gridLayout->addWidget(colorPushBtn, 0, 0, 1, 1);
setLayout(gridLayout);最后通过setlayout启用设置结果

QGridLayout* layout = new QGridLayout();
/这里create几个控件，设置好属性/
layout->setSpacing(10);//设置控件之间的间距
layout->addWidget(&TestBtn1, 0, 0);//往网格的不同坐标添加不同的组件
layout->addWidget(&TestBtn2, 0, 1);
layout->addWidget(&TestBtn3, 1, 0);
layout->addWidget(&TestBtn4, 1, 1);
layout->setRowStretch(0, 1);//设置行列比例系数
layout->setRowStretch(1, 3);// 
layout->setColumnStretch(0, 1);
layout->setColumnStretch(1, 3);
layout->addWidget(&TestBtn1, 0, 0, 2, 1);//坐标（0，0）的组件占用两行一列
layout->addWidget(&TestBtn2, 0, 1, 2, 1);//坐标（0，1）的组件占用两行一列
layout->addWidget(&TestBtn3, 2, 0, 1, 2);//坐标（2，0）的组件占用一行两列
layout->addWidget(&TestBtn4, 3, 0, 1, 2);//坐标（3，0）的组件占用一行两列
setLayout(layout);//最后通过setlayout启用设置结果

-----------槽函数集成-----------
不同的按钮按下可以调用同一个槽函数：
connect(colorPushBtn, SIGNAL(clicked()), this, SLOT(doPushBtn()));
void CBuiltinDlg::doPushBtn()
{
#当QPushButton发出一个信号时就记录发出这个信号的对象，sender获取发出信号的对象；
#当有多个OBject发出信号时可根据sender()函数判断是哪个对象发出的；然后qobject_cast类型转换为QPushButton类型
    QPushButton* btn = qobject_cast<QPushButton*>(sender());
    if(btn == colorPushBtn) {// 如果被按下的是颜色对话框.
        QPalette palette = displayTextEdit->palette();//创建textedit对象的调色板
        const QColor& color = QColorDialog::getColor(palette.color(QPalette::Base), this);//获取选择的颜色
        if(color.isValid()) {
            palette.setColor(QPalette::Base, color);//设置调色板颜色
            displayTextEdit->setPalette(palette);//将调色板颜色设置到textedit
        }
    }
    else if(btn == errorPushBtn) {//如果被按下的是错误信息框.
        QErrorMessage box(this);//创建qerrormessage对象
        box.setWindowTitle(tr("错误信息框"));//设置标题
        box.showMessage(tr("错误信息框实例xx。"));//错误内容
        box.exec();//对话框不退出
    }
    else if(btn == filePushBtn) {// 文件对话框.
        QFileDialog *fileDialog = new QFileDialog(this);
        fileDialog->setWindowTitle(tr("Open Image"));
        fileDialog->setDirectory(".");//设置当前目录

		QStringList filter;//文件过滤器
		filter << "*.jpg" << "*.png" << "*.bmp" << "*.gif";//过滤的文件名后缀
		fileDialog->setNameFilters(filter);//设置过滤器生效
        if(fileDialog->exec() == QDialog::Accepted) {
            QString path = fileDialog->selectedFiles()[0];//获取路径
            displayTextEdit->setText(path);//显示路径
        }
    }
    else if(btn == fontPushBtn) {// 字体对话框.
        bool ok;
        const QFont& font = QFontDialog::getFont(&ok,//给ok变量赋值
                                    displayTextEdit->font(),//获取当前textedit字体
                                    this,
                                    tr("字体对话框"));
        if(ok) {// 如果<确定>,设置字体.
            displayTextEdit->setFont(font);//给textedit设置字体
        }
    }
    else if(btn == inputPushBtn){// 输入对话框.
        bool ok;
        QString text = QInputDialog::getText(this,
                                            tr("输入对话框"),
                                            tr("输入文本："),
                                            QLineEdit::Normal,
                                            QDir::home().dirName(),
                                            &ok);
        if (ok && !text.isEmpty())
           displayTextEdit->setText(text);
    }
    else if(btn == pagePushBtn) {// 页设置对话框.
        QPrinter printer;
        QPageSetupDialog dlg(&printer, this);
        dlg.setWindowTitle(tr("页设置对话框"));
        if (dlg.exec() == QDialog::Accepted) {
            // 进行下一步的处理。
        }
    }
    else if(btn == progressPushBtn) {// 进度对话框.
        QProgressDialog progress(tr("正在复制文件..."), tr("取消"), 0, 1000, this);
        QFont font("ZYSong18030",10);
        progress.setFont(font);

        progress.setWindowModality(Qt::WindowModal);
        progress.setWindowTitle(tr("进度对话框"));
        progress.show();
        for (int i = 0; i < 1000; i++) {
            progress.setValue(i);
            qApp->processEvents();
            if (progress.wasCanceled())
                break;
            QTest::qWait(1);
            //... 复制文件处理。
        }
        progress.setValue(1000);
    }
    else if(btn == printPushBtn) {// 打印对话框.
        QPrinter printer;
        QPrintDialog dlg(&printer, this);
        dlg.setWindowTitle(tr("打印对话框"));
        if (dlg.exec() == QDialog::Accepted) {
            // 进行下一步的处理。
        }
    }
}

同时打开多个文件的对话框：
void CBuiltinDlg::MultiOpenFile()
{
    QStringList files = QFileDialog::getOpenFileNames(
                                    this, tr("Select one or more files to open"),//弹框标题
                                    "/",
                                    tr("All Files (*);;Text Files (*.txt)"));//过滤设置
    if (files.count()) {//如果选中的文件不是0个
      displayTextEdit->setText(QString("[%1]").arg(files.join(", ")));//将所有选中文件的路径显示到edit
    }
}
向导对话框：
void CBuiltinDlg::slotWizard()
{
    QWizard wizard;//创建向导
    wizard.addPage(createFirstPage());//对话框有2页
    wizard.addPage(createSecondPage());

    wizard.setWindowTitle(tr("向导对话框"));
    wizard.exec();
}
QWizardPage* CBuiltinDlg::createFirstPage()
{
    QWizardPage *page = new QWizardPage;//向导对话框中的页内容
    page->setTitle(tr("简介"));
    QLabel *label = new QLabel(tr("第一页"));
    label->setWordWrap(true);有没有好像没啥变化
	
    QVBoxLayout *layout = new QVBoxLayout;//布局器
    layout->addWidget(label);
    page->setLayout(layout);
    return page;
}
QWizardPage* CBuiltinDlg::createSecondPage()
{
     QWizardPage *page = new QWizardPage;
     page->setTitle(tr("正文"));
     QLabel *label = new QLabel(tr("第二页"));
     label->setWordWrap(true);
	 
     QVBoxLayout *layout = new QVBoxLayout;//布局器
     layout->addWidget(label);
     page->setLayout(layout);让布局器去布局
     return page;
}

错误信息框：
QMessageBox::critical(this, tr("错误"),tr("告诉用户一个严重的错误!"));

告警信息对话框：
void CBuiltinDlg::slotWarning()
{
    switch(QMessageBox::warning(this,tr("警告"),tr("是否要保存文档?"),
            QMessageBox::Save|QMessageBox::Discard|QMessageBox::Cancel,QMessageBox::Save))
    {
    case QMessageBox::Save:
        displayTextEdit->setText(tr("警告对话框 / 保存"));
        break;
    case QMessageBox::Discard:
        displayTextEdit->setText(tr("警告对话框 / 不保存"));
        break;
    case QMessageBox::Cancel:
        displayTextEdit->setText(tr("警告对话框 / 取消"));
        break;
    default:
        break;
    }
}
询问消息框：
void CBuiltinDlg::slotQuestion()
{//tr("询问")是标题    tr("重新开始?")是内容   下面是多个按钮
    switch(QMessageBox::question(this,tr("询问"),tr("重新开始?"),
            QMessageBox::Ok|QMessageBox::Cancel,QMessageBox::Ok))
    {
    case QMessageBox::Ok:
        displayTextEdit->setText(tr("询问按钮 / 确定"));
        break;
    case QMessageBox::Cancel:
        displayTextEdit->setText(tr("询问按钮 / 取消"));
        break;
    default:
        break;
    }
}

函数 tr()全名是QObject::tr(),被它处理的 字符串可以 使用工具提 取出来翻译 成其他语言, 也就是做国际化使用。
只要记住,Qt 的最佳实践:如果你想让你的程序国际化的话,那么,所有用户可见的字符串都要使用 QObject::tr()!
但是,为什么我们没有写 QObject::tr(),而仅仅是 tr()呢?原来,tr()函数是定义在 Object里面的,所有使用了 Q_OBJECT 宏的类都自动具有 tr()函数。

qcustomplot库
QTimer mDataTimer;
connect(&mDataTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));  得先connect再start，每40ms执行timerslot函数。
mDataTimer.start(40);

我们可以根据qt代码目录编译后生成的buildxx目录看到之前编译此工程的qt是哪个版本。
正则表达式控制textedit的输入值：
QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");regExp可接收数据被确定
ui->lineEdit->setValidator(new QRegExpValidator(regExp, this));只有有效的数据才能被写到lineedit
//lineedit文本发生改变才进入slot函数
connect(ui->lineEdit, SIGNAL(textChanged(const QString&)), this, SLOT(on_lineEdit_textChanged()));
void GoToCellDialog::on_lineEdit_textChanged()//只有lineedit满足要求ok按钮才能被点击
{
	ui->okButton->setEnabled(ui->lineEdit->hasAcceptableInput());
}
-------------目录操作
m_appFolder = QDir(QApplication::applicationDirPath());获取当前工程目录路径

QDir imageFolder = m_appFolder;
imageFolder.cdUp();//进入上层目录
imageFolder.cdUp();
imageFolder.cd("src");//进入src目录
imageFolder.cd("charts");//再进入charts目录
imageFolder.cd("doc");
imageFolder.cd("images");


QT工程pro文件模板变量（TEMPLATE）
subdirs - 这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。
app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。


tabwidget用法-------------与table widget不一样，这个是容器
setTabIcon(0,QIcon("E:\\Qt_Project\\QTabWidget\\1.ico"));//设置第1个选项卡的图标 
setTabPosition(QTabWidget::South);//设置选项卡的方位东南西北，默认在上方
//用stringlist给表格添加表头
QStringList m_Header;
m_Header<<QString("田径")<<QString("篮球")<<QString("足球")<<QString("乒乓球")<<QString("羽毛球")<<QString("游泳");
ui->tableWidget->setHorizontalHeaderLabels(m_Header);//添加横向表头，表头这行不算在数据行之内
可视化加了，显示没什么变化
ui->tableWidgetSports->verticalHeader()->setVisible(true);//纵向表头可视化
ui->tableWidgetSports->horizontalHeader()->setVisible(true);//横向表头可视化

给表格填数据的方法：6列10行
for(int rows=0;rows<10;rows++)//遍历行
{
	for(int columns=0;columns<6;columns++)//遍历列
	{
	ui->tableWidget->setItem(rows,columns,new QTableWidgetItem("刘翔"));给row行colums列增加数据new QTableWidgetItem("string变量")
	}
}

for(int rows=0;rows<10;rows++)//循环设置每个表格中文字属性，类似excel中的设置--得一个一个设置吗？太麻烦了吧
{
	for(int columns=0;columns<6;columns++)
	{
		ui->tableWidget->setColumnWidth(columns,125);
		ui->tableWidget->setRowHeight(rows,30);
		ui->tableWidget->item(rows,columns)->setTextAlignment(Qt::AlignCenter);//居中显示
		ui->tableWidget->item(rows,columns)->setBackgroundColor(QColor(85,170,255));//设置前景颜色
		ui->tableWidget->item(rows,columns)->setTextColor(QColor(0,0,0));//设置文本颜色
		ui->tableWidget->item(rows,columns)->setFont(QFont("Helvetica"));//设置字体为黑体
	}
}

qcustomplot库:
新建widget控件，然后提升控件为qcustomplot类
之后直接在文件中调用qcustomplot的方法去初始化控件即可

ui->qCustomPlotMusic->plotLayout()->insertRow(0);给控件增加row0行
ui->qCustomPlotMusic->plotLayout()->addElement(0, 0, new QCPTextElement(ui->qCustomPlotMusic, "网易云音乐播放和评论统计图", QFont("微软雅黑",12, QFont::Bold)));给row0行 colum0列 增加文本要素

渐变色控制QLinearGradient控件
QLinearGradient gradient(0, 0, 200, 400);    在x轴的0-200范围内实行渐变   在y轴的0-400实行渐变
gradient.setColorAt(0, QColor(200, 150, 220));共3段渐变色调整
gradient.setColorAt(0.56, QColor(15, 150, 200));
gradient.setColorAt(1, QColor(40, 49, 200));
ui->qCustomPlotMusic->setBackground(QBrush(gradient));  将渐变设置画到qCustomPlotMusic的bg中

mGraph2->setPen(QPen(QColor(0, 180, 60)));设置线条颜色
----------------------

listWidget:每行一个选项卡，additem增加选项
ui->listWidgetLanguage->addItem(tr("中文"));
//以下5行 设置滚动时可以用鼠标左键按下去滚动
//禁用横向滚动条
ui->listWidget->setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//禁用纵向滚动条
ui->listWidget->setVerticalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
//设置横向按照像素值为单位滚动
ui->listWidget->setHorizontalScrollMode(QListWidget::ScrollPerPixel);
//设置纵向按照像素值为单位滚动
ui->listWidget->setVerticalScrollMode(QListWidget::ScrollPerPixel);
//设置滚动对象以及滚动方式为鼠标左键拉动滚动
QScroller::grabGesture(ui->listWidget, QScroller::LeftMouseButtonGesture);


groupbox里面可以放各种同类型控件,一次性放多个
radiobox checkbox  pushbutton  lineedit 


treeWidget：树状的listWidget
ui->treeWidgetDigital->setColumnCount(2); //设置列数
ui->treeWidgetDigital->setHeaderLabels(QStringList(tr("数码产品")));//设置头的标题
QTreeWidgetItem *items1 = new QTreeWidgetItem(ui->treeWidgetDigital,QStringList(QString("手机")));大项目分类
items1->setIcon(0,QIcon("E:\\Qt_Project\\QTabWidget\\1.ico"));设置icon
QTreeWidgetItem *items11 = new QTreeWidgetItem(items1,QStringList(QString("苹果")));//设置手机分类里面的子项目




QString 转换为 char *
1.QString 转换为 char *
将 QString 转 char *，需要用到 QByteArray 类，因为 char * 最后都有一个'\0'作为结束符，而采用 QString::toLatin1() 时会在字符串后面加上'\0'。
QString  str;
char*  ch;
QByteArray ba = str.toLatin1(); // must
ch=ba.data();
这样就完成了 QString 向 char * 的转化。经测试程序运行时不会出现 bug。注意第3行，一定要加上，不可以 str.toLatin1().data() 这样一步完成，否则可能会出错。
补充：以上方法当 QString 里不含中文时，没有问题，但是 QString 内含有中文时，转换为 char * 就是乱码，采用如下方法解决：

方法1：添加GBK支持
#include <QTextCodec>
QTextCodec::setCodecForTr(QTextCodec::codecForName("GBK"));
QTextCodec::setCodecForLocale(QTextCodec::codecForName("GBK"));
然后将上面的第3行修改为：

QByteArray ba = str.toLocal8Bit();  // toLocal8Bit 支持中文
方法2：先将 QString 转为标准库中的 string 类型，然后将 string 转为 char *。如下：
QString  filename;
std::string str = filename.toStdString();
const char* ch = str.c_str();
2.char * 转换为 QString
将 char * 转换为 QString 比较容易操作，我们可以使用 QString 的构造函数进行转换：
QLatin1String(const char *str);char*-->std::string
因此用下面这个语句就可以将 char * ch 转换为 QString str 了，如下：
str = QString(QLatin1String(ch));






-----------------------------------多线程
在主线程中结束之前调用
mythread.join();   意思就是等其他线程结束后，由主线程来回收进程资源----就是等别的子线程都执行完再退出主线程
std::thread  mythread(fun);mythread线程变量的初始化函数与执行函数就是fun


----------------------------内存回收机制
在 C++ Primer 中读到 new 是在堆里面申请一段内存资源，new 必须与 delete 成对使用，否则就会造成内存泄漏。但是在Qt中经常可以看见只 new 而不 delete 的情况，这并没有错，Qt 的内存管理机制允许这样的情况存在。
qt 对 c++ 的内存管理机制进行了扩充，所有继承自QObject的类new出来的成员都会自动delete，而手动delete反而会造成不必要的麻烦
但是在c++中如果不手动delete，new对象的内存在进程结束后才会被系统回收，在运行时占用内存越来越多，这就是内存泄露。

QByteArray的操作：
1、访问赋值：[]  at()  data[]   constData[],其中[]与data[]为可读可写
at()和constData[]仅为可读。如果只需要读用这两种方法运行快

2、数据转换
1)转化为hex QByteArray text = QByteArray::fromHex("517420697320677265617421");
	--字符串转QByteArray 51 74 20 69 73 20 67 72 65 61 74 21
2)转为不同进制数值并显示，如二进制、八进制、十进制和十六进制等；
	--QByteArray_var.toHex(); //return "303132"
	QByteArray::number(var,n);转化int类型的var变量，转化成n进制
3)转为整型、浮点型等数值类型；
	QByteArray string("1234.56");
	qDebug() << string.toInt();   // return 0, 小数均视为0
	qDebug() << string.toInt(&ok1,16);   // return 0, 小数均视为0
	qDebug() << string.toFloat();   // return 1234.56
4）转为字符串类型；
	QByteArray转为QString示例：
		QByteArray ba("abc123");
		QString str = ba; 
	QString转为QByteArray示例：
		QString str("abc123");
		QByteArray ba = str.toLatin1();
5)将QByteArray中的某个数据转化成16进制，然后转化成Qstring
QString("%1").arg((unsigned char)readtext.at(i), 2, 16, QLatin1Char('0'))
 
----------------------------------------------------------------------------
主窗口点击按钮 弹出另一个自定义窗口:	两个窗口之间的切换
界面1构造函数中：
界面2 = new Dialog();//得在这里就初始化，否则connect访问空指针了
connect(界面2,SIGNAL(sendsignal()),this,SLOT(reshow()));//界面1发出sendsignal时，自己要reshow

void 界面1::reshow()   这是槽函数
{
    this->show();
}

void Widget::on_pushButton_clicked()//界面1 按键按下  则将界面2显示出来--同时将界面1隐藏
{
    //d = new Dialog();//得在构造初始化，否则connect访问空指针了
    d->show();
    this->hide();
}
界面2操作：
void Dialog::on_buttonBox_accepted()
{
    emit sendsignal();//切换页面1的时候需要发sendsignal触发界面1的connect函数
    this->close();
}


调试：
在函数内部调试的时候默认局部变量会显示出来，全局变量不会
全局变量的查看方法：
	在变量窗口右键：add new expression .. 添加变量名称即可

QByteArray byte = serial->readAll();
QString qstr = byte.toHex();//收到的uart数据由16进制转成10进制

int x=63;
qDebug()<<QByteArray::number(x);  整数的10进制打印   16进制打印
qDebug()<<QByteArray::number(x,16);
qDebug()<<QByteArray::number(x,16).toUpper();

参考git上的qt uart工程 去处理收到的uart数据。


---------------------qt再学习
ui中放入控件后  点击主窗口  点击网格布局--->自动排列好 
如果想把某个页面中的控件 剪切到另一个页面 直接剪切 复制即可 
多个控件 想在某个控件内放东西  可以先在右边 控件栏 选中控件 再去左边操作
stackWidget-->类似c#的tabWidget-->ui->stackedWidget->setCurrentWidget(ui->calc);根据各个界面名字进行切换

mainWindow的菜单栏如何点击切换页面：
添加转到槽

槽函数也可以直接调用的，本质上只是一个函数而已，不一定非要触发才可以执行--构造函数中也可以执行
一个ui界面文件 对应一个.h .cpp文件 是一套的

安装mysql的链接：https://zhuanlan.zhihu.com/p/326439656


Qt5.9.2如果使用的是mingw编译器，Qt只有32位的。连接64位的MySQL，即使把mysql安装目录下的libmysql.dll放到qt安装目录bin路径下，也是无法连接数据库。网上给出的做法是下载Qt对应版本的源码，重新编译。这种方法复杂繁琐，且容易编译失败。先发现一种简便方法，就是mysql的官网给出了连接32位的驱动。


下拉框里面显示数据库内容
QSqlQueryModel * queryModel = new QSqlQueryModel(this);//依附主窗体 不用操心 释放问题
queryModel->setQuery("select * from table1");---只有1列数据
ui->combox->setModel(queryModel); 将模型获取的数据直接添加到combox中 setModel入参是抽象item  queryModel就是继承的抽象item类 所以可以直接传

下拉框改变槽函数：
combox_curIndexChanged(const String &arg1) //arg1就是下拉框更新后的数据
{
	if(arg1 == "n1")
	{
		更新对应控件内容
	}else if(arg1=="n2")//根据下拉框的内容 更新查询数据库 更新其他下拉框该显示的内容
	{
		//方法1：
		QSqlQueryModel * queryModel = new QSqlQueryModel(this);//依附主窗体 不用操心 释放问题
		queryModel->setQuery("select brand from table2 where fac='%1'").arg(arg1);
		ui->combox->setModel(queryModel); 将模型获取的数据直接添加到combox中 
		//方法2： 
		QSqlQuery query;
		//用sql 根据 当前 combox 内容 筛选数据 不要忘记这里有''
		QString sql=QString("select brand from table2 where fac='%1'").arg(arg1);
		query.exec(sql);
		//获取 查到的内容
		while(query.next())
		{
			QString name=query.value(0).toString();
			/*如果获取到 2个序列的数据 则需要一个一个根据字段名接收
			  int pri= query.value("price").toInt();
			  string var= query.value("var2").toString();
			*/
			ui->combox->addItem(name);//往这个下拉框加入数据
		}
	}
}

qt中普通的函数可以只声明 不定义，但是自己右键->转到槽的槽函数 必须定义与声明都在（或都删）
---如果只删掉定义不删掉声明 还是无法编译通过



Qclipboard   剪切内容的类
QGUIApplication::clipboard()->test()---返回的就是当前剪切板中的内容（如果先在windows中复制的东西，运行
qt程序后直接qDebug此表达式，返回的就是当前剪切板中的内容）
Qdir::currentpath()

多进程：
Qprocess * ptr=new QProcess(this);  必须定义成指针  否则函数完成的时候变量消失  进程就必须结束
用指针就需要考虑指针的释放--connect(ptr,SLOT(finished()),delete ptr);//自己释放自己
QStringList args;
args<<"/select"+QString("path");
ptr->start("explorer",args);开启进程 资源管理器


args<<"/xx"+"yy"  报错 “yy”是char * 无法直接+  需要转化成QString才能加
args<<"/xx"+QString("yy")<<"zz"   则args[0]="/xxyy"  args[1]="zz"



定义槽函数：
需要在.h文件中 加public slots: 修饰   直接定义函数，在.c文件调用时会报错  无此槽函数
public   slots:
    void load();

connect(ui->mypushButton,SIGNAL(clicked()),this,SLOT(load()));

获取当前线程ID 当前时间：年月日 时分秒 毫秒
str = QString("Subthread Id: %1, Time:%2").arg((unsigned)QThread::currentThreadId())
                .arg(QDateTime::currentDateTime().toString("yyyy-MM-dd hh:mm:ss zzz"));

延时  或者异步 执行槽函数，都可以解决主界面还未初始化完调用load卡死的问题。
//异步执行load函数
QMetaObject::invokeMethod(this, "load", Qt::QueuedConnection);
//延时10毫秒执行load函数
QTimer::singleShot(10, this, SLOT(load()));

exp:
public slots:  头文件中必须将此，两个函数声明成槽函数 否则后面无法调用
    void timeSlot();
    void Load(qint32 nMsecs);

MainWindow::MainWindow(QWidget *parent)
    : QMainWindow(parent)
    , ui(new Ui::MainWindow)
{
    ui->setupUi(this);
    qDebug()<<"satart";
	//这里3种方法都可以解决主界面显示慢 问题
    QMetaObject::invokeMethod(this,"Load",Qt::QueuedConnection);//无参数，QueuedConnection表示异步调用，等主线程
    //QMetaObject::invokeMethod(this,"Load",Qt::QueuedConnection, Q_ARG(qint32, 5000));//异步调用，Q_ARG传参数
    //QTimer::singleShot(10,this,SLOT(timeSlot()));//启用单次计时器
}

void MainWindow::Load(qint32 nMsecs)
{
    QThread::msleep(nMsecs);
    this->setWindowState(Qt::WindowMaximized);
    ui->label->setText("执行invokeMethod之后");
}

void MainWindow::timeSlot()
{
    QThread::msleep(3000); //
    this->setWindowState(Qt::WindowMaximized);
    ui->label->setText("执行QTimer之后");
}

获取类的属性和方法 方便调用：
//拿到控件元对象--定义出来的控件对象--可以是widget界面，可以是按钮 标签控件
const QMetaObject *metaObject = widget->metaObject();

//所有属性的数量
int propertyCount = metaObject->propertyCount();
//propertyOffset是自定义的属性开始的位置
int propertyOffset = metaObject->propertyOffset();
//循环取出控件的自定义属性, int i = 0 表示所有属性
for (int i = 0; i < propertyCount; ++i) {
    QMetaProperty metaProperty = metaObject->property(i);
    const char *name = metaProperty.name();
    const char *type = metaProperty.typeName();
    QVariant value = widget->property(name);
    qDebug() << name << type << value;}

//所有方法的数量
int methodCount = metaObject->methodCount();
//methodOffset是自定义的方法开始的位置
int methodOffset = metaObject->methodOffset();
//循环取出控件的自定义方法, int i = 0 表示所有方法
for (int i = 0; i < methodCount; ++i) {
    QMetaMethod metaMethod = metaObject->method(i);
    const char *name = metaMethod.name();
    const char *type = metaMethod.typeName();
    qDebug() << name << type;}

Qt内置图标封装在QStyle中，大概七十多个图标，可以直接拿来用，相当于给label嵌入背景，改变label形状 颜色：
	/*
    SP_TitleBarMenuButton,    SP_TitleBarMinButton,    SP_TitleBarMaxButton,
    SP_TitleBarCloseButton,    SP_MessageBoxInformation,    SP_MessageBoxWarning,
    SP_MessageBoxCritical,    SP_MessageBoxQuestion,...
    */
    QPixmap pixmap = this->style()->standardPixmap(QStyle::SP_MessageBoxCritical);
    ui->label->setPixmap(pixmap);

多个控件重组到一起：
可以将控件A添加到布局，然后控件B设置该布局，这种灵活性提高了控件的组合度，比如可以在文本框左侧右侧增加一个搜索按钮，按钮设置图标即可。将lineEdit设置到布局，然后给布局增加btn控件，实现控件组合
	QPushButton *btn = new QPushButton;
    btn->resize(30, ui->lineEdit->height());
    QHBoxLayout *layout = new QHBoxLayout(ui->lineEdit);
    layout->setMargin(0);
    layout->addStretch();
    layout->addWidget(btn);
	
巧妙的使用inherits判断是否属于某种类。
	QTimer *timer = new QTimer;         		  // QTimer inherits QObject
    qDebug()<<timer->inherits("QTimer");          // returns true
    qDebug()<<timer->inherits("QObject");         // returns true
    qDebug()<<timer->inherits("QAbstractButton"); // returns false

qt中的泛型数据类型：
struct MyClass{
    int id;
    QString name;
};
Q_DECLARE_METATYPE(MyClass)  //定义好数据类型，需要声明成内部类型 后面才可以直接与泛型转换
	QVariant data[4];
    //存储数据
    MyClass myClass;
    myClass.id=0;
    myClass.name=QString("LiMing");
    data[0]=QString("ddd");//泛型的数组 可以随意赋值不同类型的数据
    data[1]=123;
    data[3]=QVariant::fromValue(myClass);
    //获取数据
    QString str=data[0].toString();
    int val=data[1].toInt();
    if(data[3].canConvert<MyClass>())//如果data[3] 可以转化成MyClass类型
    {
        MyClass myClass=data[3].value<MyClass>();//则转化data[3] 为MyClass 类型的数据myClass
        int id=myClass.id;  获取data[3]中存的数值 
        QString name=myClass.name;
        qDebug()<<id<<" "<<name;
    }	
	
善于利用QComboBox的addItem的第二个参数设置用户数据，可以实现很多效果，使用itemData取出来。
特别注意的是第二个参数是QVariant类型，这就不要太灵活了，意味着可以附带万能的数据比如结构体，这样就可以带一堆数据了，而不是一个数据。
比如下拉框选择学号，对应元素可以附带该学生的姓名、班级、成绩等。很多人以为只能附带QString、int之类的数据，因为通常的用法也是那两种。
	QStringList listVideoOpenInterval, listVideoOpenIntervalx;
    listVideoOpenInterval << "0.0 秒" << "0.1 秒" << "0.3 秒" << "0.5 秒" << "1.0 秒" << "2.0 秒";
    listVideoOpenIntervalx << "0" << "100" << "300" << "500" << "1000" << "2000";
    for (int i = 0; i < listVideoOpenInterval.count(); ++i) {
        ui->cboxVideoOpenInterval->addItem(listVideoOpenInterval.at(i), listVideoOpenIntervalx.at(i));
    }//cbox显示的是listVideoOpenInterval的值，实际对应的listVideoOpenIntervalx数值

    //取出对应的值
    int indexVideoOpenInterval = ui->cboxVideoOpenInterval->currentIndex();
    indexVideoOpenInterval = ui->cboxVideoOpenInterval->itemData(indexVideoOpenInterval).toInt();
	
	------------复杂数据类型
	QVariant data[4];
    QStringList listVideoOpenInterval;
    listVideoOpenInterval << "xiaoming" << "xiaohong" << "xiaoli" ;
    MyClass myClass;
    myClass.id=0;     myClass.name=QString("LiMing");
    data[0]=QVariant::fromValue(myClass);
    myClass.id=1;     myClass.name=QString("Lihong");
    data[1]=QVariant::fromValue(myClass);
    myClass.id=2;     myClass.name=QString("Lili");
    data[2]=QVariant::fromValue(myClass);//制作3个struct数据 以QVariantList添加到combox中
    QVariantList listVideoOpenIntervalx;
    listVideoOpenIntervalx << data[0]<<data[1]<<data[2];
    for (int i = 0; i < listVideoOpenInterval.count(); ++i) {
        ui->cboxVideoOpenInterval->addItem(listVideoOpenInterval.at(i), listVideoOpenIntervalx.at(i));
	}
	//当combox索引发生改变时  可以通过index获取到当前索引中隐含的数据信息
	void Widget::on_cboxVideoOpenInterval_currentIndexChanged(const QString &arg1)
	int indexVideoOpenInterval = ui->cboxVideoOpenInterval->currentIndex();
	QVariant testval = ui->cboxVideoOpenInterval->itemData(indexVideoOpenInterval);//根据currentIndex获取itemdata
	if(testval.canConvert<MyClass>())//如果 testval 可以转化成MyClass类型
	{
		MyClass myClass=testval.value<MyClass>();//则转化testval 为MyClass 类型的数据myClass
		int id=myClass.id;  //获取testval中存的数值
		QString name=myClass.name;
		qDebug()<<id<<" "<<name;
	}
	
在pro中判断Qt版本及构建套件位数:打印的信息在QT下面的"概要信息"中  不在"应用程序输出"里面
message(qt version: $$QT_VERSION)
message($$QT_ARCH)

Project MESSAGE: qt version: 5.14.0
Project MESSAGE: i386

设置样式表：
setStyleSheet("QPushButton{text-align:right}");  设置当前项目种所有button中的数据 右对齐
ui->mypushButton->setStyleSheet("text-align:right");  设置某个btn的数据右对齐

Qlabel 3种设置文本的方法：
//常规办法
ui->label->setText("hello");
//取巧办法
ui->label->setProperty("text", "hello");  设置label的text文本，内容为hello
//属性大法 
ui->label->setStyleSheet("qproperty-text:hello;");  设置样式表 qproperty-text 为 hello
setStyleSheet("QLabel{qproperty-text:hello}");     设置当前项目所有label的text都是hello

QEventLoop的使用:在程序运行到某个位置时 将程序卡5s，5s之后loop退出 程序继续运行
用法1：
QEventLoop loop;//定义一个事件循环
QTimer::singleShot(5000, &loop, SLOT(quit()));//创建单次定时器，槽函数为事件循环的退出函数
loop.exec();//事件循环开始执行，程序会卡在这里，直到定时时间到，本循环被退出

用法2：pushButton的clicked事件中 loop阻塞，直到mypushButton按键按下，quit loop循环才能打印出来fun end
void Widget::on_pushButton_clicked()
{
    qDebug()<<"fun start";
    QEventLoop loop;
    connect(ui->mypushButton, SIGNAL(clicked()), &loop, SLOT(quit()));
    loop.exec();
    qDebug()<<"fun end";
}


很多人Qt和Qt Creator傻傻分不清楚
Qt Creator是使用Qt编写的集成开发环境IDE，和宇宙第一的Visual Studio一样;
	他可以是msvc编译器的（WIN对应的Qt集成安装环境中自带的Qt Cerator是msvc的），
	也可以是mingw编译的，还可以是gcc的。
如果是自定义控件插件，需要集成到Qt Creator中，必须保证
该插件的动态库文件（dll或者so等文件）对应的编译器和
Qt版本以及位数和Qt Creator的版本完全一致才行，否则基本不大可能集成进去。
特别注意的是Qt集成环境安装包中的Qt版本和Qt Creator版本未必完全一致，必须擦亮眼睛看清楚，有些是完全一致的。

很多人在绘制的时候，设置画笔以为就只可以设置个单调的颜色，其实QPen还可以设置brush比如设置QPen的brush以后，可以使用各种渐变，比如绘制渐变颜色的进度条和文字等，而不再是单调的一种颜色。

很多控件都带有 viewport，比如QTextEdit/QTableWidget/QScrollArea，有时候对这些控件直接处理的时候发现不起作用，
需要对其 viewport()设置才行
ui->scrollArea->viewport()->setStyleSheet("background-color:yellow;");
ui->scrollArea->setStyleSheet("background-color:yellow;");


QDateTime dateTime;时间的各种转换
QString dateTime_str = dateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss");
//从字符串转换为毫秒（需完整的年月日时分秒）
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toMSecsSinceEpoch();
//从字符串转换为秒（需完整的年月日时分秒）
datetime.fromString("2011-09-10 12:07:50:541", "yyyy-MM-dd hh:mm:ss:zzz").toTime_t();
//从毫秒转换到年月日时分秒
datetime.fromMSecsSinceEpoch(1315193829218).toString("yyyy-MM-dd hh:mm:ss:zzz");
//从秒转换到年月日时分秒（若有zzz，则为000）
datetime.fromTime_t(1315193829).toString("yyyy-MM-dd hh:mm:ss[:zzz]");


在我们使用QList、QStringList、QByteArray等链表或者数组的过程中，如果只需要取值，强烈建议使用 at() 取值而不是[] 操作符
因为Qt的容器类不能辨别 [] 操作符是否将出现在一个赋值的左边还是右边，他假设最坏的情况出现并且强制执行深层赋值，
而 at() 函数则不被允许出现在一个赋值的左边。使用at保证不会修改原值

安全的删除Qt的对象类，强烈建议使用deleteLater而不是delete，
因为deleteLater会选择在合适的时机进行释放，而delete会立即释放，很可能会出错崩溃。
如果要批量删除对象集合，可以用qDeleteAll，比如 qDeleteAll(btns);


很多时候需要在已知背景色的情况下，能够清晰的绘制文字，这个时候需要计算对应的文字颜色。
	ui->label->setStyleSheet("background-color:black;");  设置label的背景颜色
    sleep(1000);   颜色等待label的颜色固定住  
	QPalette pal = ui->label->palette();
	QBrush brush = pal.background();
	QColor color = brush.color();  获取label的背景色
	
	double gray = (0.299 * color.red() + 0.587 * color.green() + 0.114 * color.blue()) / 255;
	QColor textColor = gray > 0.5 ? Qt::black : Qt::white;  计算一个合适的显示颜色

	ui->label->setText("test");
	QPalette pe;
	pe.setColor(QPalette::WindowText,textColor); 设置字体颜色到label上
	ui->label->setPalette(pe);
