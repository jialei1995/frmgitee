qmainwindow（菜单栏，工具栏）与qdialog（对话框）都是继承qwidget，
qwidget的父类是所有对象的祖宗QOBJECT
QApplication a(argc, argv);//应用程序对象，有且只有一个
myWidget w; //实例化窗口对象
ctrl+shift+↑/↓ 将当前行移动到上方或者下方
同名的.h与.cpp切换，按键F4
选中多行，按ctrl+i自动对齐多行
查看帮助文档：打开bin文件夹下的assistant.exe 可以直接打开帮助文档
Qdialog：对话框（里面一般按钮较少，登陆页面啦、出错界面、下一步界面）
.pro中的target=test生成的exe的名称就是text.exe
Q_OBJECT 有这个宏表示允许使用信号和槽机制
函数声明与定义中只有1个里面允许有默认参数=0...
	btn的op：settext（“设置文本”）；
			setparent（this）；-------直接Qpushbutten * btn = new Qpushbutten（“文本”，this）；设置到对象树中
			move（100,100）；坐标从左上角开始数
			resize（100,100）；

	qt里面私有属性里面一般都是qpushubutten * btn；然后在构造函数中new出来的
	也可以在类里面直接QPushButton btn;在构造函数中settext，setparent

	窗口设置标题直接：setwindowtitle（“窗口标题”）；
	设置固定的窗口大小：setfixedsize（600,400）；
	调整窗口大小。直接resize（600,400）；其实可以this->resize()。也可以默认直接resize就可以。

	qDebug（）<<“sadasd”；
	或者qDebug（“sadasdd”）；自动换行的
对象树，创建的时候由上至下，析构的时候由下至上，只要是下级属于上级的对象，析构的时候父对象会帮你析构
子对象的析构函数自己还是得去实现，只是这个函数的调用是父对象去管理的，并不是它帮忙实现的。

                也可以写成&Mybut::clicked,this,&Mybut::close，必须是类名，如果子类继承父类自然信号函数也继承了。
				不可以直接写对象或者对象地址，必须写类::信号
	connect(&btn,&QPushButton::clicked,this,&QPushButton::close);
			信号发出对象地址				信号接收对象地址
			信号类型地址					槽函数地址
	connect(sock,SIGNAL(connected()),this,SLOT(on_connected()));
			SIGNAL（默认会选择sock的父类里面的信号，不用再加作用域了括号中的函数要加参数类型
	connect(sock,SIGNAL(error(QAbstractSocket::SocketError)),this,SLOT(on_error()));
								这是error信号的参数类型，不用加形参名		

	connect(sock,SIGNAL(error(QAbstractSocket::SocketError)),this,SLOT(on_error()));
	connect连接中信号只写类型不写形参，slot可以参数比signal少。
				槽函数声明的时候信号也可以只写类型，不写形参，在定义的时候再写形参。
	注意自定义的类才可以自定义信号和槽函数&&&&&&：自定义槽函数时要在头文件中加：
	public slots:   信号加到signals：下。自定义的信号只需要头文件声明一下就好了,不需要实现
	返回值是void，可以有参数，可以重载。
    								 void btn_deal();
	槽函数直接写到public中即可，类似普通的函数
	返回值void，需要声明，也需要实现，可以有参数，也可以重载
	
	信号与槽都写完之后只需要connect即可，然后等着触发此信号即可。
	exp:在widget中connect(t1,&Teachar::hungry,st,&Student::eat);
	
   	自定义的信号怎么触发这个信号呢？？	
   	可以在widget中定义一个普通的函数，调用这个函数就会emit signal
   	{
   		emit t1->hungry();		//通过在widget的构造函数中调用这个函数去发信号。构造函数在创建mywidget的时候就会执行内部所有的东西
   	}

    如果自定义的类不属于任何别控件，应该让他继承与QObject-----这样他就不用管自己的内存释放了。这个类会管理内存的...

    connect信号可以连接信号的***，触发信号1则触发信号2
	
    QString转char*；s.toutf8().data(); qstring->qbytearray->char*
	QString str = QString("abc %1 ^_^ %2").arg(123).arg("mike");  格式化字符串
	qstring打印时默认带“”，char *打印时不带“”

	对于重载的signal函数与slot函数调用的时候函数名字都一样怎么区分呀？
	通过制定函数类型：
	void (Teacher::var)(QString) = &Teachar::hungry;  定义的(sig或者slot一样)函数指针变量var就是&Teachar::hungry，
	而且这个变量指向，返回值void，参数是qstring的hungry，而不是空入参的hungry。

    1个新号怎么调用多个槽函数呢？用lambda表达式
    lambda表达式：定义并创建匿名函数对象  
    [=](){		[]中放：	=等号用的最多  	&
    	btn->settext("12");
    };中括号小括号大括号
	connect(btn,&QPushubutton::clicked,this,[=]()
	{
		this->close();
		emit 另一个信号()；
		...外面的变量函数都能在这里面调用。。。
	})
	如何新建另一个窗口？？connect按钮按下则调用lambda表达式【=】（）{
		QDialog dlg；
		dlg。exec（）；就ok了
	}
	qt资源文件：添加文件->resource file->open in edit->设置路径名，以后用资源的时候复制路径就可以

	qt样式表：控件的样式
		设置按键，label，主窗口的样子-背景字体...
	qt的lable还可以显示图片，gif，可跳转的域名
		
---------------------事件 
	事件类似一个个的软件中断*****	
	qt中所有的事件类都继承与qevent	，bool event（QEvent*）ev）函数不直接处理事件，而是按照事件类型分派给
	特定的事件处理函数。在函数体内把自己想处理的事处理一下，其他事件交给父类处理，你不可能处理所有的事件。
	qwidget中定义了很多事件处理函数都是虚的，可以在子类重新实现的。
	protected ：
	***事件不用connect，写好了发生就可以触发事件函数。	
	QString str = QString("abc %1 ^_^ %2").arg(123).arg("mike");
		str = abc 123 ^_^ mike  类似sprintf
	鼠标按下事件：在一个mylabel的类中实现的
	但是键盘按下的键得在mywidget中实现，因为键盘按下的事件只有主窗口才能收到，但是鼠标的按下事件是按在了label中，mylabel可以接收到
	定时器也一种事件：timerevent。可以在mywidget中重写虚函数
					同时定时器需要在mtwidget中去starttimer
	图片：绘图看例子，很详细
		QPmixmap pix；pix.load("路径")。设置参数
		p.draw(0,0,pix);

	
	主窗口控制事件分发：
			在mainwindow中：重定义event（）将传进来的实体化的QEvent *e事件，根据类型选择对应的处理函数
								{
									switch事件（e->type（））
									 == xxx    mousemove事件；
									 == xxx    closeevent事件；
								}
	连接sqlite：
	messageBox:：warning（this，“wrong”）出错弹出对话框用到。
	
	
关于QT事件(event)的简单介绍
　　　事件(event)是有系统或者Qt本身在不同的时刻发出的。当用户按下鼠标，敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件是在对用户操作做出响应的时候发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。
　　一般来说，使用Qt编程时，我们并不会把主要精力放在事件上，因为在Qt中，需要我们关心的事件总会发出一个信号。比如，我们关心的 QPushButton的鼠标点击，但我们不需要关心这个鼠标点击事件，而是关心它的clicked()信号。

　　Qt的事件很容易和信号槽混淆。这里简单的说明一下，signal由具体对象发出，然后会马上交给由connect函数连接的slot进行处理；
	而对于事件，Qt使用一个事件队列对所有发出的事件进行维护，当新的事件产生时，会被追加到事件队列的尾部，前一个事件完成后，取出后面的事件进行处理。但是，必要的时候，Qt的事件也是可以不进入事件队列，而是直接处理的。并且，事件还可以使用“事件过滤器”进行过滤。
	总的来说，如果我们使用组件，我们关心的是信号槽；如果我们自定义组件，我们关心的是事件。因为我们可以通过事件来改变组件的默认操作。比如，如果我们要自定义一个QPushButton，那么我们就需要重写它的鼠标点击事件和键盘处理事件，并且在恰当的时候发出clicked()信号。
　　还记得我们在main函数里面创建了一个QApplication对象，然后调用了它的exec()函数吗？其实，这个函数就是开始Qt的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt将创建一个事件对象。Qt的所有事件都继承于 QEvent类。在事件对象创建完毕后，Qt将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数(event handler)。
　　在所有组件的父类QWidget中，定义了很多事件处理函数，如keyPressEvent()、keyReleaseEvent()、mouseDoubleClickEvent()、mouseMoveEvent ()、mousePressEvent()、mouseReleaseEvent()等。这些函数都是protected virtual的，也就是说，我们应该在子类中重定义这些函数


class　EventLabel　:　public　QLabel
{
protected:
　　　　void　mouseMoveEvent(QMouseEvent　*event);
　　　　void　mousePressEvent(QMouseEvent　*event);
　　　  void　mouseReleaseEvent(QMouseEvent　*event);
};
void　EventLabel::mouseMoveEvent(QMouseEvent　*event)
{
this->setText(QString("Move:　(%1,　%2)").arg(QString::number(event->x()),　QString::number(event->y())));
}
void　EventLabel::mousePressEvent(QMouseEvent　*event)
{
　this->setText(QString("Press:　(%1,　%2)").arg(QString::number(event->x()),　QString::number(event->y())));
}
void　EventLabel::mouseReleaseEvent(QMouseEvent　*event)
{
　　　QString　msg;
　　　msg.sprintf("Release:　(%d,　%d)",event->x(),　event->y());//与上面的显示不一样的语法
　　　this->setText(msg);
}
int　main(int　argc,　char　*argv[])//事件不需要connect slot函数就可以触发，只需要重载事件处理函数即可，这些处理函数在父类种不做处理
{
　　　QApplication　app(argc,　argv);
　　　EventLabel　*label　=　new　EventLabel;
　　　label->setWindowTitle("MouseEvent　Demo");
　　　label->resize(300,　200);
　　　label->show();
　　　return　app.exec();
}
　　这里我们继承了QLabel类，重写了mousePressEvent、mouseMoveEvent和MouseReleaseEvent三个函数。我们并没有添加什么功能，只是在鼠标按下(press)、鼠标移动(move)和鼠标释放(release)时把坐标显示在这个Label上面。
注意我们在mouseReleaseEvent函数里面有关QString的构造。我们没有使用arg参数的方式，而是使用C语言风格的sprintf来构造QString对象

----------------------------------------------------------------------------

	qt的静态库要自己编译所以一般使用动态库。
	将写好的qt程序编译成release版本，copy生成的app.exe到一个新目录，qtshell，Qt命令行(左下角)
			然后用windeployqt.exe ./app.exe操作，会将它需要的动态库文件都放到此文件夹
			或者：cd /d D:\现在新建的存app.exe的目录   F:as\d\d\d\windeployqt.exe .\自己的.exe
	代码编译不一定非要用qt软件内点击鼠标：
			1.直接使用qmake.exe进行qmake，然后使用mingw32-make.exe进行make就会生成app.exe。 
	qt中函数alt+enter自动补全
	
易错点：定义变量放在.h文件中，不然.c中其他函数无法访问。
     在当前类的.cpp文件中访问当前类的成员，可以通过this->shuxing（fun）或者直接调用成员属性（方法），不加this都可以。

串口收发参考连接：https://blog.csdn.net/qq_39017187/article/details/88935705

定时器：
1.QTimer * timer=new QTimer(this);
    timer->start(500);
    connect(timer,&QTimer::timeout,this,[=](){
        qDebug()<<"shijiandao";
    });
2.监听timerEvent();事件，不推荐哦

ctrl+i：全选后，所有行自动对齐
QT_CHARTS_USE_NAMESPACE：首行需要加命名空间	
直接参考example文件中的c文件。

QLineSeries定义的变量series要add到QChart定义的变量chart中去，charts最后要加到QChartView chartView变量中去，
最后chartView又要加到QMainWindow  window.setCentralWidget(chartView)中去。

可以参考QT左上角的欢迎->示例

绘制各种图形举例：https://blog.csdn.net/lwbeyond/article/details/41479809?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-16.control


qt：编译报错  Error while building/deploying project all-class-in-one (kit: Desktop Qt 5.10.1 …
When executing step “qmake”
改工程所在的路径不能有中文出现，改完后重新打开工程编译即可
-------------------------------老贺发的资料----------------------------各种对话框
QGridLayout* gridLayout = new QGridLayout;布局管理器
可以通过gridLayout对象去布局当前界面中各个控件的位置：
gridLayout->addWidget(colorPushBtn, 0, 0, 1, 1);
setLayout(gridLayout);最后通过setlayout启用设置结果

不同的按钮按下可以调用同一个槽函数：
connect(colorPushBtn, SIGNAL(clicked()), this, SLOT(doPushBtn()));
void CBuiltinDlg::doPushBtn()
{
#当QPushButton发出一个信号时就记录发出这个信号的对象，sender获取发出信号的对象；
#当有多个OBject发出信号时可根据sender()函数判断是哪个对象发出的；然后qobject_cast类型转换为QPushButton类型
    QPushButton* btn = qobject_cast<QPushButton*>(sender());
    if(btn == colorPushBtn) {// 如果被按下的是颜色对话框.
        QPalette palette = displayTextEdit->palette();//创建textedit对象的调色板
        const QColor& color = QColorDialog::getColor(palette.color(QPalette::Base), this);//获取选择的颜色
        if(color.isValid()) {
            palette.setColor(QPalette::Base, color);//设置调色板颜色
            displayTextEdit->setPalette(palette);//将调色板颜色设置到textedit
        }
    }
    else if(btn == errorPushBtn) {//如果被按下的是错误信息框.
        QErrorMessage box(this);//创建qerrormessage对象
        box.setWindowTitle(tr("错误信息框"));//设置标题
        box.showMessage(tr("错误信息框实例xx。"));//错误内容
        box.exec();//对话框不退出
    }
    else if(btn == filePushBtn) {// 文件对话框.
        QFileDialog *fileDialog = new QFileDialog(this);
        fileDialog->setWindowTitle(tr("Open Image"));
        fileDialog->setDirectory(".");//设置当前目录

		QStringList filter;//文件过滤器
		filter << "*.jpg" << "*.png" << "*.bmp" << "*.gif";//过滤的文件名后缀
		fileDialog->setNameFilters(filter);//设置过滤器生效
        if(fileDialog->exec() == QDialog::Accepted) {
            QString path = fileDialog->selectedFiles()[0];//获取路径
            displayTextEdit->setText(path);//显示路径
        }
    }
    else if(btn == fontPushBtn) {// 字体对话框.
        bool ok;
        const QFont& font = QFontDialog::getFont(&ok,//给ok变量赋值
                                    displayTextEdit->font(),//获取当前textedit字体
                                    this,
                                    tr("字体对话框"));
        if(ok) {// 如果<确定>,设置字体.
            displayTextEdit->setFont(font);//给textedit设置字体
        }
    }
    else if(btn == inputPushBtn){// 输入对话框.
        bool ok;
        QString text = QInputDialog::getText(this,
                                            tr("输入对话框"),
                                            tr("输入文本："),
                                            QLineEdit::Normal,
                                            QDir::home().dirName(),
                                            &ok);
        if (ok && !text.isEmpty())
           displayTextEdit->setText(text);
    }
    else if(btn == pagePushBtn) {// 页设置对话框.
        QPrinter printer;
        QPageSetupDialog dlg(&printer, this);
        dlg.setWindowTitle(tr("页设置对话框"));
        if (dlg.exec() == QDialog::Accepted) {
            // 进行下一步的处理。
        }
    }
    else if(btn == progressPushBtn) {// 进度对话框.
        QProgressDialog progress(tr("正在复制文件..."), tr("取消"), 0, 1000, this);
        QFont font("ZYSong18030",10);
        progress.setFont(font);

        progress.setWindowModality(Qt::WindowModal);
        progress.setWindowTitle(tr("进度对话框"));
        progress.show();
        for (int i = 0; i < 1000; i++) {
            progress.setValue(i);
            qApp->processEvents();
            if (progress.wasCanceled())
                break;
            QTest::qWait(1);
            //... 复制文件处理。
        }
        progress.setValue(1000);
    }
    else if(btn == printPushBtn) {// 打印对话框.
        QPrinter printer;
        QPrintDialog dlg(&printer, this);
        dlg.setWindowTitle(tr("打印对话框"));
        if (dlg.exec() == QDialog::Accepted) {
            // 进行下一步的处理。
        }
    }
}

同时打开多个文件的对话框：
void CBuiltinDlg::MultiOpenFile()
{
    QStringList files = QFileDialog::getOpenFileNames(
                                    this, tr("Select one or more files to open"),//弹框标题
                                    "/",
                                    tr("All Files (*);;Text Files (*.txt)"));//过滤设置
    if (files.count()) {//如果选中的文件不是0个
      displayTextEdit->setText(QString("[%1]").arg(files.join(", ")));//将所有选中文件的路径显示到edit
    }
}
向导对话框：
void CBuiltinDlg::slotWizard()
{
    QWizard wizard;//创建向导
    wizard.addPage(createFirstPage());//对话框有2页
    wizard.addPage(createSecondPage());

    wizard.setWindowTitle(tr("向导对话框"));
    wizard.exec();
}
QWizardPage* CBuiltinDlg::createFirstPage()
{
    QWizardPage *page = new QWizardPage;//向导对话框中的页内容
    page->setTitle(tr("简介"));
    QLabel *label = new QLabel(tr("第一页"));
    label->setWordWrap(true);有没有好像没啥变化
	
    QVBoxLayout *layout = new QVBoxLayout;//布局器
    layout->addWidget(label);
    page->setLayout(layout);
    return page;
}
QWizardPage* CBuiltinDlg::createSecondPage()
{
     QWizardPage *page = new QWizardPage;
     page->setTitle(tr("正文"));
     QLabel *label = new QLabel(tr("第二页"));
     label->setWordWrap(true);
	 
     QVBoxLayout *layout = new QVBoxLayout;//布局器
     layout->addWidget(label);
     page->setLayout(layout);让布局器去布局
     return page;
}

错误信息框：
QMessageBox::critical(this, tr("错误"),tr("告诉用户一个严重的错误!"));

告警信息对话框：
void CBuiltinDlg::slotWarning()
{
    switch(QMessageBox::warning(this,tr("警告"),tr("是否要保存文档?"),
            QMessageBox::Save|QMessageBox::Discard|QMessageBox::Cancel,QMessageBox::Save))
    {
    case QMessageBox::Save:
        displayTextEdit->setText(tr("警告对话框 / 保存"));
        break;
    case QMessageBox::Discard:
        displayTextEdit->setText(tr("警告对话框 / 不保存"));
        break;
    case QMessageBox::Cancel:
        displayTextEdit->setText(tr("警告对话框 / 取消"));
        break;
    default:
        break;
    }
}
询问消息框：
void CBuiltinDlg::slotQuestion()
{//tr("询问")是标题    tr("重新开始?")是内容   下面是多个按钮
    switch(QMessageBox::question(this,tr("询问"),tr("重新开始?"),
            QMessageBox::Ok|QMessageBox::Cancel,QMessageBox::Ok))
    {
    case QMessageBox::Ok:
        displayTextEdit->setText(tr("询问按钮 / 确定"));
        break;
    case QMessageBox::Cancel:
        displayTextEdit->setText(tr("询问按钮 / 取消"));
        break;
    default:
        break;
    }
}

函数 tr()全名是QObject::tr(),被它处理的 字符串可以 使用工具提 取出来翻译 成其他语言, 也就是做国际化使用。
只要记住,Qt 的最佳实践:如果你想让你的程序国际化的话,那么,所有用户可见的字符串都要使用 QObject::tr()!
但是,为什么我们没有写 QObject::tr(),而仅仅是 tr()呢?原来,tr()函数是定义在 Object里面的,所有使用了 Q_OBJECT 宏的类都自动具有 tr()函数。

qcustomplot库
QTimer mDataTimer;
connect(&mDataTimer, SIGNAL(timeout()), this, SLOT(timerSlot()));  得先connect再start，每40ms执行timerslot函数。
mDataTimer.start(40);

我们可以根据qt代码目录编译后生成的buildxx目录看到之前编译此工程的qt是哪个版本。
正则表达式控制textedit的输入值：
QRegExp regExp("[A-Za-z][1-9][0-9]{0,2}");regExp可接收数据被确定
ui->lineEdit->setValidator(new QRegExpValidator(regExp, this));只有有效的数据才能被写到lineedit
//lineedit文本发生改变才进入slot函数
connect(ui->lineEdit, SIGNAL(textChanged(const QString&)), this, SLOT(on_lineEdit_textChanged()));
void GoToCellDialog::on_lineEdit_textChanged()//只有lineedit满足要求ok按钮才能被点击
{
	ui->okButton->setEnabled(ui->lineEdit->hasAcceptableInput());
}
-------------目录操作
m_appFolder = QDir(QApplication::applicationDirPath());获取当前工程目录路径

QDir imageFolder = m_appFolder;
imageFolder.cdUp();//进入上层目录
imageFolder.cdUp();
imageFolder.cd("src");//进入src目录
imageFolder.cd("charts");//再进入charts目录
imageFolder.cd("doc");
imageFolder.cd("images");


QT工程pro文件模板变量（TEMPLATE）
subdirs - 这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。
app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。


tabwidget用法-------------与table widget不一样，这个是容器
setTabIcon(0,QIcon("E:\\Qt_Project\\QTabWidget\\1.ico"));//设置第1个选项卡的图标 
setTabPosition(QTabWidget::South);//设置选项卡的方位东南西北，默认在上方
//用stringlist给表格添加表头
QStringList m_Header;
m_Header<<QString("田径")<<QString("篮球")<<QString("足球")<<QString("乒乓球")<<QString("羽毛球")<<QString("游泳");
ui->tableWidget->setHorizontalHeaderLabels(m_Header);//添加横向表头，表头这行不算在数据行之内
可视化加了，显示没什么变化
ui->tableWidgetSports->verticalHeader()->setVisible(true);//纵向表头可视化
ui->tableWidgetSports->horizontalHeader()->setVisible(true);//横向表头可视化

给表格填数据的方法：6列10行
for(int rows=0;rows<10;rows++)//遍历行
{
	for(int columns=0;columns<6;columns++)//遍历列
	{
	ui->tableWidget->setItem(rows,columns,new QTableWidgetItem("刘翔"));给row行colums列增加数据new QTableWidgetItem("string变量")
	}
}

for(int rows=0;rows<10;rows++)//循环设置每个表格中文字属性，类似excel中的设置--得一个一个设置吗？太麻烦了吧
{
	for(int columns=0;columns<6;columns++)
	{
		ui->tableWidget->setColumnWidth(columns,125);
		ui->tableWidget->setRowHeight(rows,30);
		ui->tableWidget->item(rows,columns)->setTextAlignment(Qt::AlignCenter);//居中显示
		ui->tableWidget->item(rows,columns)->setBackgroundColor(QColor(85,170,255));//设置前景颜色
		ui->tableWidget->item(rows,columns)->setTextColor(QColor(0,0,0));//设置文本颜色
		ui->tableWidget->item(rows,columns)->setFont(QFont("Helvetica"));//设置字体为黑体
	}
}

qcustomplot库:
新建widget控件，然后提升控件为qcustomplot类
之后直接在文件中调用qcustomplot的方法去初始化控件即可

ui->qCustomPlotMusic->plotLayout()->insertRow(0);给控件增加row0行
ui->qCustomPlotMusic->plotLayout()->addElement(0, 0, new QCPTextElement(ui->qCustomPlotMusic, "网易云音乐播放和评论统计图", QFont("微软雅黑",12, QFont::Bold)));给row0行 colum0列 增加文本要素

渐变色控制QLinearGradient控件
QLinearGradient gradient(0, 0, 200, 400);    在x轴的0-200范围内实行渐变   在y轴的0-400实行渐变
gradient.setColorAt(0, QColor(200, 150, 220));共3段渐变色调整
gradient.setColorAt(0.56, QColor(15, 150, 200));
gradient.setColorAt(1, QColor(40, 49, 200));
ui->qCustomPlotMusic->setBackground(QBrush(gradient));  将渐变设置画到qCustomPlotMusic的bg中

mGraph2->setPen(QPen(QColor(0, 180, 60)));设置线条颜色
----------------------

listWidget:每行一个选项卡，additem增加选项
ui->listWidgetLanguage->addItem(tr("中文"));


groupbox里面可以放各种同类型控件,一次性放多个
radiobox checkbox  pushbutton  lineedit 


treeWidget：树状的listWidget
ui->treeWidgetDigital->setColumnCount(2); //设置列数
ui->treeWidgetDigital->setHeaderLabels(QStringList(tr("数码产品")));//设置头的标题
QTreeWidgetItem *items1 = new QTreeWidgetItem(ui->treeWidgetDigital,QStringList(QString("手机")));大项目分类
items1->setIcon(0,QIcon("E:\\Qt_Project\\QTabWidget\\1.ico"));设置icon
QTreeWidgetItem *items11 = new QTreeWidgetItem(items1,QStringList(QString("苹果")));//设置手机分类里面的子项目




QString 转换为 char *
1.QString 转换为 char *
将 QString 转 char *，需要用到 QByteArray 类，因为 char * 最后都有一个'\0'作为结束符，而采用 QString::toLatin1() 时会在字符串后面加上'\0'。
QString  str;
char*  ch;
QByteArray ba = str.toLatin1(); // must
ch=ba.data();
这样就完成了 QString 向 char * 的转化。经测试程序运行时不会出现 bug。注意第3行，一定要加上，不可以 str.toLatin1().data() 这样一步完成，否则可能会出错。
补充：以上方法当 QString 里不含中文时，没有问题，但是 QString 内含有中文时，转换为 char * 就是乱码，采用如下方法解决：

方法1：添加GBK支持
#include <QTextCodec>
QTextCodec::setCodecForTr(QTextCodec::codecForName("GBK"));
QTextCodec::setCodecForLocale(QTextCodec::codecForName("GBK"));
然后将上面的第3行修改为：

QByteArray ba = str.toLocal8Bit();  // toLocal8Bit 支持中文
方法2：先将 QString 转为标准库中的 string 类型，然后将 string 转为 char *。如下：
QString  filename;
std::string str = filename.toStdString();
const char* ch = str.c_str();
2.char * 转换为 QString
将 char * 转换为 QString 比较容易操作，我们可以使用 QString 的构造函数进行转换：
QLatin1String(const char *str);char*-->std::string
因此用下面这个语句就可以将 char * ch 转换为 QString str 了，如下：
str = QString(QLatin1String(ch));






-----------------------------------多线程
在主线程中结束之前调用
mythread.join();   意思就是等其他线程结束后，由主线程来回收进程资源----就是等别的子线程都执行完再退出主线程
std::thread  mythread(fun);mythread线程变量的初始化函数与执行函数就是fun


----------------------------内存回收机制
在 C++ Primer 中读到 new 是在堆里面申请一段内存资源，new 必须与 delete 成对使用，否则就会造成内存泄漏。但是在Qt中经常可以看见只 new 而不 delete 的情况，这并没有错，Qt 的内存管理机制允许这样的情况存在。
qt 对 c++ 的内存管理机制进行了扩充，所有继承自QObject的类new出来的成员都会自动delete，而手动delete反而会造成不必要的麻烦
但是在c++中如果不手动delete，new对象的内存在进程结束后才会被系统回收，在运行时占用内存越来越多，这就是内存泄露。