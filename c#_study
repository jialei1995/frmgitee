
C#:
ctrl+k+d   自动对齐，注意k弹起来再按d ctrl是一直按下的
ctrl+k+c   选中注释，先k再c
#region (注释)+ #endregion  将需要折叠的代码放到region中间，然后点击小-，即可折叠。

数据类型：
字符串 string var="nihao 你好";  可以为空
字符   char  c = 'x'; 不能为空
int  整数
double  小数
float   小数
decimal  金钱（小数）   decimal money=100m;   最后面有个m
String  与 string  一样的都能定义数据
String：.net平台的类  string：c#的关键字

符号：
+ ：连接字符串   当+两边有一边是字符串，则+的作用就是连接
+：两边都是数字  则+作用是连接
占位符： {0} {1} {n}
Console.WriteLine("第一个数字是{0},第二个数字是{1}",n1,n2); 先挖坑，再填坑
控制台输入的数据只能用string去存储,不能说输入的是数字就用int去存
string  var = Console.ReadLine();
怎么截取控制台输入的多个数据？不会的时候就分3次从控制台读取
在表示路径的字符串前加个@，则路径只需要一个\即可。ps：
string path=@"F:\a\b\c\d\e\1.txt"  如果没有@,则需要
string path="F:\\A\\B\\C\\D\\1.TXT"  
@：取消\在”“中的转义作用
@：将”“中的字符串按照原格式输出

除了类型兼容的类型转换：double--int
类型不兼容的类型强制转换用convert。
Convert.toDouble(var);  转换工厂
枚举类型与int类型是相互兼容的，可以直接转换，
Enum.parse();  Enum.TryParse(); 类型转换 将str转换成enum类型
(要转换的枚举类型)Enum.parse(typeof(要转换的枚举类型)，”要转换的字符串“);
枚举：  声明在命名空间之内，class之外，以供此命名空间内的其他方法调用
[public] enum ENUM_NAME
{
	值1，
	值2，
	。。。
	值n
}
使用 ENUM_NAME var=ENUM_NAME.值1;定义变量并赋值，枚举类型的值是通过枚举名点出来的。
所有类型的数据都可以.ToString();转换成string

结构：
[public可省略] struct STRUCT_NAME
{
	public 类型 mem1;  如果前面不加public，则这些成员外部无法访问
	public	类型 mem2
}

捕获错误：
try	{convert.toint32(xx)}
catch {提示输入错误}
如果try里面的程序能成功执行则不会跳到catch，如果try里面不能成功执行则会跳到catch


获取当前sys时间：
Datetime.Now 格式是时间的格式，需要转换成字符串 Tostring()；
Datetime.Now.Hour()  获取小时
Datetime.Now.Second()  获取秒




构造函数可以重载。
类当中有一个默认的无参数的构造函数，当写一个新的构造函数后，不管有没有，之前的默认的无参数的构造函数都会被干掉。

----------------------PATH类
alt+shift+f10：查看类在哪个命名空间中
Path.getfilename(); 获取路径下的文件名
获取字符串中某个字符最后一次出现的索引：获取路径最后一个\后的名称
int index = str.lastindexof("\\"); 
str=str.substring(index+1); 获取str中的子串
--


静态类如果我们想使用类里面的方法需要
Class.way();去调用
普通的类可以定义一个对象，通过对象调用方法。
-----FILE
-创建文件
FILE.create(@"c:\a\b\c.txt");
-删除
FILE.delete(@"c:\a\b\c.txt");
-复制
FILE.copy(@"c:\a\b\old.txt",@"c:\a\b\new.txt");

--winform 界面
静态类里面的字段全局可以访问。
Test._mem = this;  将当前窗体赋值给Test的mem成员---此成员是静态类的成员，全局可以访问。

-------------
SoundPlayer 创建对象sp
sp.SoundLocation=@"wav格式的音乐路径";
sp.Play()  播放音乐

------------获得焦点
label.Focus();让文本框获得焦点
	
------------自动换行
btnword.WordWrap = true/false;  设置文本框中的内容是否自动换行
MessageBox.Show(str);  打印提示

---------------单选框  多选框
checkBox   多选框控件
radiobutton    单选控件
GroupbOX   容器，将多个单选控件放进去，则只能单选了.常用属性：visible:设置为true则分组框中的所有对象都一起被隐藏
panel：类似groupbox，区分控件组
checkedlistbox:带复选框的列表框控件
combox：

int.Parse(string):将str转换为int

-----pictureBox
创建对应的对象x
x.Image = Image.FromFile() 文件路径 ，则对应的图片会自动显示到picturebox中

Directory.GetFiles(文件加路径);获取文件加中所有文件的全路径名



-------------
直接下载网页为html格式，下载后会附带当前网页的所有图片出来，在一个文件夹中。
界面中的分类都用的groupbox
阿里巴巴ICON下载，可以挑选图片的背景颜色。下载png格式即可
直接改FORM1的backgroundImage,可以设置图片进去
OpenFileDialog ofd = new OpenFileDialog()：点击按钮之后弹出选择文件的对话框
ofd.Title="请选择文件";设置此dialog的标题
ofd.InitialDiretory = @"路径"; 设置初始化路径
ofd.Multiselect=true;  设置可以多选，一次性选择多个文件
ofd.ShowDialog();  显示窗口
ofd.Filter=""
string[] path = ofd.Filenames  获取最后选择的全部文件的全路径

Path.GetFileName(path[i]);根据全路径获取文件名

listbox.Items.Add(string);  listbox增加新项，
listbox.SelectedIndex;  获取选中的条目的索引
listbox.Items.Count  listbox中的项个数
----------------------随机数产生
Random r = new Random();  产生随机数
str = r.Next(0,10).tostring();产生0-10的随机数转换成string

----------------------进程线程
--通过进程打开应用程序
Process.getprocess
Process.Start("notepad");  打开记事本
Process.Start("iexplore"，”https://xx“);  打开浏览器
----通过进程打开指定的文件
Process p = new Process(); create new process
ProcessStartInfo psi = new ProcessStartInfo("文件路径");
p.StartInfo = psi;
p.start();     
---线程
Thead th = new Thread(Test);  Test是个函数，新建线程，执行的是Test，这里的Test入参在下面传
th.IsbackGround = true;  设置线程后台运行
th.start(arg：给Test传参数在这里传)   开启线程

Control.CheckForIlegalCrossThreadCalls = false；取消跨线程对象检查
-----------------------关键字
---new
创建对象。
关键字new还可以用来隐藏从父类继承的同名函数：在子类的函数定义时需要 public new void t(){} 加new
---访问修饰符修饰类内成员
public:
private:私有的，只能在当前类内部访问。类中的成员如果不加访问修饰符默认都是private
protected:可以类内访问，继承的子类中也可以访问
internal:当前项目中可以访问----public所有项目都可以访问
protected internal:
---访问修饰符修饰类
public
internal 

public partial class Uart  在另一个文件也可以定义相同的类
public sealed class Teacher:Person{}  可以继承于别的类，但是不能被别的类继承

选中图片或文字，直接按住ctrl挪动鼠标，就可以复制，不需要ctrl+c+v

----不可见控件
timer


serialport 控件如果放到页面1，则页面2无法访问，需要将页面1中的控件赋值给静态类中
更好的做法是声明变量，则在页面2的cs文件中可以直接


textbox.appendtext(str) == textbox.text += str;
serialport.readexisting();以字符串方式读

byte data = (byte)serialport.readbyte();  以int方式读，需要类型转换成byte才能给byte赋值
str= convert.tostring(data,16).toupper();  转换成byte才能继续转换成str，不能直接int转换成str
因为textbox里面放的是string


发生le.exe退出，需要将当前文件夹中的licence文件删除再去运行，不然licence的存在有问题。



---invoke与begininvoke
在多线程编程中，我们经常要在工作线程中去更新界面显示，而在多线程中直接调用界面控件的方法是错误的做法，
Invoke 和 BeginInvoke 就是为了解决这个问题而出现的，使你在多线程中安全的更新界面显示。
正确的做法是将工作线程中涉及更新界面的代码封装为一个方法，通过 Invoke 或者 BeginInvoke 去调用，
两者的区别就是一个导致工作线程等待，而另外一个则不会。
使用方法：
//定义一个委托 ，像是一个数据类型一样的东西。是函数的数据类型：入参是string返回值是void的函数类型
public delegate void MyInvoke(string str); delegate就是委托
//更新界面的方法 
private void UpdateTextBox(string str); 
{  
this.TextBox1.Text=str; //更新
} 
//启动一个线程 
Thread thread=new Thread(new ThreadStart(DoWork)); 
thread.Start();  
private void DoWork() //线程函数中不直接操作控件，而是通过委托变量mi去操作
{ 
//比如将界面的TextBox内容设置一下 
MyInvoke mi=new MyInvoke(UpdateTextBox); //定义此委托变量mi的时候需要传进去一个函数（此函数就是入参string，返回值void）
this.BeginInvoke(mi,new object[]{"我是一个文本框"}); //需要传入委托变量与入参，入参是new出来的string。
}  