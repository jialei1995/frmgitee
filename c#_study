
C#:
ctrl+k+d   自动对齐，注意k弹起来再按d ctrl是一直按下的
ctrl+k+c   选中注释，先k再c
#region (注释)+ #endregion  将需要折叠的代码放到region中间，然后点击小-，即可折叠。

数据类型：
字符串 string var="nihao 你好";  可以为空
字符   char  c = 'x'; 不能为空
int  整数
double  小数
float   小数
decimal  金钱（小数）   decimal money=100m;   最后面有个m
String  与 string  一样的都能定义数据
String：.net平台的类  string：c#的关键字

符号：
+ ：连接字符串   当+两边有一边是字符串，则+的作用就是连接
+：两边都是数字  则+作用是连接
占位符： {0} {1} {n}
Console.WriteLine("第一个数字是{0},第二个数字是{1}",n1,n2); 先挖坑，再填坑
控制台输入的数据只能用string去存储,不能说输入的是数字就用int去存
string  var = Console.ReadLine();
怎么截取控制台输入的多个数据？不会的时候就分3次从控制台读取
在表示路径的字符串前加个@，则路径只需要一个\即可。ps：
string path=@"F:\a\b\c\d\e\1.txt"  如果没有@,则需要
string path="F:\\A\\B\\C\\D\\1.TXT"  
@：取消\在”“中的转义作用
@：将”“中的字符串按照原格式输出

除了类型兼容的类型转换：double--int
类型不兼容的类型强制转换用convert。
Convert.toDouble(var);  转换工厂
Convert.tobyte(var)  转换成字节
枚举类型与int类型是相互兼容的，可以直接转换，
Enum.parse();  Enum.TryParse(); 类型转换 将str转换成enum类型
(要转换的枚举类型)Enum.parse(typeof(要转换的枚举类型)，”要转换的字符串“);
枚举：  声明在命名空间之内，class之外，以供此命名空间内的其他方法调用
[public] enum ENUM_NAME
{
	值1，
	值2，
	。。。
	值n
}
使用 ENUM_NAME var=ENUM_NAME.值1;定义变量并赋值，枚举类型的值是通过枚举名点出来的。
所有类型的数据都可以.ToString();转换成string

结构：
[public可省略] struct STRUCT_NAME
{
	public 类型 mem1;  如果前面不加public，则这些成员外部无法访问
	public	类型 mem2
}

捕获错误：
try	{convert.toint32(xx)}
catch {提示输入错误}
如果try里面的程序能成功执行则不会跳到catch，如果try里面不能成功执行则会跳到catch


获取当前sys时间：
Datetime.Now 格式是时间的格式，需要转换成字符串 Tostring()；
Datetime.Now.Hour()  获取小时
Datetime.Now.Second()  获取秒




构造函数可以重载。
类当中有一个默认的无参数的构造函数，当写一个新的构造函数后，不管有没有，之前的默认的无参数的构造函数都会被干掉。

----------------------PATH类
alt+shift+f10：查看类在哪个命名空间中
Path.getfilename(); 获取路径下的文件名
获取字符串中某个字符最后一次出现的索引：获取路径最后一个\后的名称
int index = str.lastindexof("\\"); 
str=str.substring(index+1); 获取str中的子串
--


静态类如果我们想使用类里面的方法需要
Class.way();去调用
普通的类可以定义一个对象，通过对象调用方法。
-----FILE
-创建文件
FILE.create(@"c:\a\b\c.txt");
-删除
FILE.delete(@"c:\a\b\c.txt");
-复制
FILE.copy(@"c:\a\b\old.txt",@"c:\a\b\new.txt");

--winform 界面
静态类里面的字段全局可以访问。
Test._mem = this;  将当前窗体赋值给Test的mem成员---此成员是静态类的成员，全局可以访问。

-------------
SoundPlayer 创建对象sp
sp.SoundLocation=@"wav格式的音乐路径";
sp.Play()  播放音乐

------------获得焦点
label.Focus();让文本框获得焦点
	
------------自动换行
btnword.WordWrap = true/false;  设置文本框中的内容是否自动换行
MessageBox.Show(str);  打印提示

---------------单选框  多选框
checkBox   多选框控件
radiobutton    单选控件
GroupbOX   容器，将多个单选控件放进去，则只能单选了.常用属性：visible:设置为true则分组框中的所有对象都一起被隐藏
panel：类似groupbox，区分控件组
checkedlistbox:带复选框的列表框控件
combox：

int.Parse(string):将str转换为int

-----pictureBox
创建对应的对象x
x.Image = Image.FromFile() 文件路径 ，则对应的图片会自动显示到picturebox中

Directory.GetFiles(文件加路径);获取文件加中所有文件的全路径名



-------------
直接下载网页为html格式，下载后会附带当前网页的所有图片出来，在一个文件夹中。
界面中的分类都用的groupbox
阿里巴巴ICON下载，可以挑选图片的背景颜色。下载png格式即可
直接改FORM1的backgroundImage,可以设置图片进去
OpenFileDialog ofd = new OpenFileDialog()：点击按钮之后弹出选择文件的对话框
ofd.Title="请选择文件";设置此dialog的标题
ofd.InitialDiretory = @"路径"; 设置初始化路径
ofd.Multiselect=true;  设置可以多选，一次性选择多个文件
ofd.ShowDialog();  显示窗口
ofd.Filter=""
string[] path = ofd.Filenames  获取最后选择的全部文件的全路径

Path.GetFileName(path[i]);根据全路径获取文件名

listbox.Items.Add(string);  listbox增加新项，
listbox.SelectedIndex;  获取选中的条目的索引
listbox.Items.Count  listbox中的项个数
----------------------随机数产生
Random r = new Random();  产生随机数
str = r.Next(0,10).tostring();产生0-10的随机数转换成string

----------------------进程线程
--通过进程打开应用程序
Process.getprocess
Process.Start("notepad");  打开记事本
Process.Start("iexplore"，”https://xx“);  打开浏览器
----通过进程打开指定的文件
Process p = new Process(); create new process
ProcessStartInfo psi = new ProcessStartInfo("文件路径");
p.StartInfo = psi;
p.start();     
---线程
Thead th = new Thread(Test);  Test是个函数，新建线程，执行的是Test，这里的Test入参在下面传
th.IsbackGround = true;  设置线程后台运行
th.start(arg：给Test传参数在这里传)   开启线程

Control.CheckForIlegalCrossThreadCalls = false；取消跨线程对象检查
-----------------------关键字
---new
创建对象。
关键字new还可以用来隐藏从父类继承的同名函数：在子类的函数定义时需要 public new void t(){} 加new
---访问修饰符修饰类内成员
public:
private:私有的，只能在当前类内部访问。类中的成员如果不加访问修饰符默认都是private
protected:可以类内访问，继承的子类中也可以访问
internal:当前项目中可以访问----public所有项目都可以访问
protected internal:
---访问修饰符修饰类
public
internal 

public partial class Uart  在另一个文件也可以定义相同的类
public sealed class Teacher:Person{}  可以继承于别的类，但是不能被别的类继承

选中图片或文字，直接按住ctrl挪动鼠标，就可以复制，不需要ctrl+c+v

----不可见控件
timer


serialport 控件如果放到页面1，则页面2无法访问，需要将页面1中的控件赋值给静态类中
更好的做法是声明变量，则在页面2的cs文件中可以直接


textbox.appendtext(str) == textbox.text += str;
serialport.readexisting();以字符串方式读

byte data = (byte)serialport.readbyte();  以int方式读，需要类型转换成byte才能给byte赋值
str= convert.tostring(data,16).toupper();  转换成byte才能继续转换成str，不能直接int转换成str
因为textbox里面放的是string


发生le.exe退出，需要将当前文件夹中的licence文件删除再去运行，不然licence的存在有问题。



---invoke与begininvoke
在多线程编程中，我们经常要在工作线程中去更新界面显示，而在多线程中直接调用界面控件的方法是错误的做法，
Invoke 和 BeginInvoke 就是为了解决这个问题而出现的，使你在多线程中安全的更新界面显示。
正确的做法是将工作线程中涉及更新界面的代码封装为一个方法，通过 Invoke 或者 BeginInvoke 去调用，
两者的区别就是一个导致工作线程等待，而另外一个则不会。
使用方法：
//定义一个委托 ，像是一个数据类型一样的东西。是函数的数据类型：入参是string返回值是void的函数类型
public delegate void MyInvoke(string str); delegate就是委托
//更新界面的方法 
private void UpdateTextBox(string str); 
{  
this.TextBox1.Text=str; //更新
} 
//启动一个线程 
Thread thread=new Thread(new ThreadStart(DoWork)); 
thread.Start();  
private void DoWork() //线程函数中不直接操作控件，而是通过委托变量mi去操作
{ 
//比如将界面的TextBox内容设置一下 
MyInvoke mi=new MyInvoke(UpdateTextBox); //定义此委托变量mi的时候需要传进去一个函数（此函数就是入参string，返回值void）
this.BeginInvoke(mi,new object[]{"我是一个文本框"}); //需要传入委托变量与入参，入参是new出来的string。
}  





疑问：C#中界面一中的uart与界面2中的uart之前的关系是什么，为啥有2个界面都创建了port_DataReceivedds中断函数
界面1中的中断函数只处理了crc校验，与vol的显示
界面2中的uart中断中进行了复杂的uart协议的处理
界面3中的uart负责保护值的显示与设置
当前是界面x，则其他的uart就是死的，只有界面x中的uart是处于链接状态的，当前界面的uart才可以进行uart的通信呢

form1.cs中的117行crc校验，后面的数据不是应该-4的<<，-3的不左移吗？为啥啊

(Uart.RcvBuf.ReDataBuf[Uart.RcvBuf.ReDataBuf.Length - 3] << 8 | Uart.RcvBuf.ReDataBuf[Uart.RcvBuf.ReDataBuf.Length - 4]).ToString("X"))

FORM2.CS中a2的回复直接开始回复bin数据了？？不是先是长度+帧数量吗？
pc         bms
a0--------》
<<----------a1
----------->>a2
<<----------a2
----------->>a3
<<----------a3
...
----------->>a4
<<----------a4

sByte是C#中的带符号的byte（signed char）。Byte本身是unsigned char

byte[] firmWareBuf = new byte[] { };数组具体有多长，看你放进去多少数据，他是会变化的。

C#:
ctrl+k+d   自动对齐，注意k弹起来再按d ctrl是一直按下的
ctrl+k+c   选中注释，先k再c
#region (注释)+ #endregion  将需要折叠的代码放到region中间，然后点击小-，即可折叠。

数据类型：
字符串 string var="nihao 你好";  可以为空
字符   char  c = 'x'; 不能为空
int  整数
double  小数
float   小数
decimal  金钱（小数）   decimal money=100m;   最后面有个m
String  与 string  一样的都能定义数据
String：.net平台的类  string：c#的关键字

符号：
+ ：连接字符串   当+两边有一边是字符串，则+的作用就是连接
+：两边都是数字  则+作用是连接
占位符： {0} {1} {n}
Console.WriteLine("第一个数字是{0},第二个数字是{1}",n1,n2); 先挖坑，再填坑
控制台输入的数据只能用string去存储,不能说输入的是数字就用int去存
string  var = Console.ReadLine();
怎么截取控制台输入的多个数据？不会的时候就分3次从控制台读取
在表示路径的字符串前加个@，则路径只需要一个\即可。ps：
string path=@"F:\a\b\c\d\e\1.txt"  如果没有@,则需要
string path="F:\\A\\B\\C\\D\\1.TXT"  
@：取消\在”“中的转义作用
@：将”“中的字符串按照原格式输出

除了类型兼容的类型转换：double--int
类型不兼容的类型强制转换用convert。
Convert.toDouble(var);  转换工厂
枚举类型与int类型是相互兼容的，可以直接转换，
Enum.parse();  Enum.TryParse(); 类型转换 将str转换成enum类型
(要转换的枚举类型)Enum.parse(typeof(要转换的枚举类型)，”要转换的字符串“);
枚举：  声明在命名空间之内，class之外，以供此命名空间内的其他方法调用
[public] enum ENUM_NAME
{
	值1，
	值2，
	。。。
	值n
}
使用 ENUM_NAME var=ENUM_NAME.值1;定义变量并赋值，枚举类型的值是通过枚举名点出来的。
所有类型的数据都可以.ToString();转换成string

结构：
[public可省略] struct STRUCT_NAME
{
	public 类型 mem1;  如果前面不加public，则这些成员外部无法访问
	public	类型 mem2
}

以下两者都类似C语言传地址区别就是
out:要求在函数内部必须给传出参数x赋值，在函数外部x可以没值。
ref：要求在函数外部必须给参数x赋值，函数内部可以修改也可以不修改

params:函数传参数要求是数组,加上params参数后可以直接传数组中每个数据
注意这个params可变参数必须是形参列表中的最后一个参数;一个形参列表中最多只能出现一个可变参数。
int []s = {1,2,3};
void test(params int[] score)
调用：test(1,2,3);  直接传数组中各个参数即可。

求数组长度：arr.Length() 内置方法


重载：函数名称相同，参数不同。
参数不同分为：如果参数个数相同，则类型不能相同
如果参数类型相同则个数不能相同。
方法的重载跟返回值没关系---

命名空间：可以理解为类的文件夹，命名空间有很多类
怎么在项目2中用项目一里面的类：
在项目2的开始:using 项目一的名称，则项目1里面的类在项目2都能用了
-----------------------------泛型集合
List:
List<int> l = new List<int>();
l.removeat(0);删除0上面的元素后，再次访问l的时候0位置就是删除之前1位置的数据

ArrayList:
ArrayList list=new ArrayList();更优越的数组
（长度可变，存放类型不单一）
Add(任意类型);Add(new int[]{1,2,3});直接添加数组
ArrayList.Count();相当于数组中的length
AddRange(集合); 添加集合
clear();清空
remove(x);传入谁就删除谁
removeat(0);删除下标是0的元素。
reverse();反转
sort();排序--类型差不多才能比较，要不然不能比较
removerange(0,4);删除0-4的元素
insert(1,"元素"); 在下标前插入。
insertrange(0,new string[] {"xx","yy"}); 插入集合
contains(1); 判断集合是否包含1这个数据


----------------
HashTable:键值对集合（键是唯一的）
增：
add(键，值);键与值都可以是任意object类型
th[x] = y;也是添加数据的方法,如果原key存在直接覆盖对应的值
包含：
th.contains() == th.containskey()
删：
clear();清空
remove(key);根据key删

键值对集合怎么遍历：
foreach(var item in ht.Keys()){Console.WriteLine(ht[item])}
--------------var
var.GetType();获取var的数据类型--c#每个数据有自己的类型，强类型语言。

var关键字，可以定义任意类型数据，可以根据值自己推断类型。
var n=12,"str",3.24,111m
var缺点，声明变量的时候必须初始化。
-------------------stopwatch
stopwatch st = new Stopwatch();
st.start();(运行代码) st.stop();  运行结束打印st.Elapsed可以查到耗时时长。

(int[])x; 将x转化为数组类型
int[] n = new int[100];新建长度为100的数组。
if(x is Persion) (i is int[]) 判断x是什么类型，Persion类，数组
int[] n = new int[]{};  新建长度不固定的数组，数组的实际长度根据你添加进去的值去变化。

-------注意事项
头文件只能声明，不能直接定义。ps:头文件中只能extern int x;   .c文件中int x=10;

一、字符串转换为字符数组
char[] tempChar = sourceString.ToCharArray();

二、字符数组转换为字符串
//方法一
string str = string.Join("", tempChar);

//方法二
string str = string.Concat<char>(tempChar);

//方法三
string str = new string(tempChar);



c# string转int
Convert.ToInt16(st)；
int.Parse(st)


foreach (var item in data); 可以直接遍历二维数组，会默认一行一行的去遍历

--------------imagelist与picturebox的关系：
imagelist是存放图片的列表属于后台控件
picture是显示图片的box，前台控件，我们可以在picturebox中去显示图片
常用：picturebox.Image = imagelist.Image[x];通过给x赋值不同让box中显示不同的图片

string path=Application.StartupPath;  这个路径对应某个目录


-------------关闭窗口提示
private void Form1_FormClosing(object sender, FormClosingEventArgs e)
{
	//DialogResult接收dialog的选择结果  			标题	是否两个按钮			是否关闭前面显示warning图标
    DialogResult dr = MessageBox.Show("是否关闭", "t提示", MessageBoxButtons.YesNo, MessageBoxIcon.Warning);
    if (dr == DialogResult.Yes)
    {
        e.Cancel = false;//FormClosingEventArgs.cancel窗口的关闭事件=false就是不关闭
    }
    else
    { 
        e.Cancel=true;//=true就是关闭
    }



----------------listview单位是ITEM
listView1.Items.Add(textBox1.Text.Trim());往listview中增加项
listView1.Items.RemoveAt(listView1.SelectedItems[0].Index);//删除listview中的选中项

---------------treeview单位是NODE

设置窗体图标：左上角的ICON  需要放置.ico文件到属性中的icon里面即可。

字符串转char数组，char数组转字符串
字符串转换成Char数组
string str="abcdefghijklmnopqretuvwxyz";
char[] chars=str.ToCharArray();

char数组转换成字符串
char[] chars=new char[]{'a','b','c','d'};
string str=new string(chars);

string转byte[]:
byte[] byteArray = System.Text.Encoding.Default.GetBytes ( str );
byte[]转string：
string str = System.Text.Encoding.Default.GetString ( byteArray );
string转ASCII byte[]:
byte[] byteArray = System.Text.Encoding.ASCII.GetBytes ( str );
ASCII byte[]转string:
string str = System.Text.Encoding.ASCII.GetString ( byteArray );


调试：逐过程-不进入函数内部
跳出：不执行函数内部的剩余代码，直接点击跳出就会回到本函数执行完的下一行。
不设置断点，直接右键有个运行到光标处，可以直接运行到光标处停止，这样就不需要打断点了。

委托与匿名方法：
委托：存放对方法的引用，内部包含一个指向某个方法的指针
[修饰符，范围，可有可无]  delegate  [返回类型] [委托名称] [参数列表]
委托的作用：在类B中使用类A中的方法，通常需要定义类A对象，然后A对象.fun() 调用
委托类型  委托对象 = 函数---这里的函数不带括号，因为不是函数的调用，只是将函数地址赋给委托。
之后调用的时候可以委托对象（入参）;
匿名方法-加委托
委托类型  委托变量 = delegate (int x,int y)
{
	return x+y;
};必须有分号，这相当于一行代码将函数赋值给委托变量
这种委托的调用： 委托变量.invoke(3,4);

App.config文件的使用  vs
修改的时候只能在xml文件中修改
<appsetting>
	<app key="ServerIP" value="127.0.0.1"></add>
	<app key="user" value="cc"></add>
</appsetting>

string serverIP = ConfigurationManager.AppSettings["ServerIP"];程序中获取配置文件中的值
string user = ConfigurationManager.AppSettings["user"];程序中获取配置文件中的值
=======
收银系统：
List<FatherClass> list = new List<FatherClass>();  new父类类型的变量，用list
这样放数据的时候都堆到一起了，数据不容易查找，都不知道每个下标存的啥。



List<List<FatherClass>> list = new List<List<FatherClass>>();  
这种方法存的数据里面已经包含了商品类型，商品数量，相当于每次add的时候相当于存的同一类商品


Guid.NewGuid().ToString()；获取唯一编码


构造函数传参方法1：
public Sam(string id, double price, double count): base(id, price, count)


c#可以直接返回数组：
PS：
public static int[] test()
{ 
	int[] a = new int[]{ 1, 2, 3 };//这里是堆还是栈都可以
	//int[] a = { 1, 2, 3 };  这个是栈
	return a;
}
static void Main(string[] args)
{
	int[] vs = test();//直接定义数据变量直接=赋值就行，数组可以直接赋值，相当于一个数据类型
	for (int i = 0; i < vs.Length; i++)
	{
		Console.WriteLine(vs[i]);
	}
}




java-----------
javac hello.java 会编译生成hello.class二进制文件
java hello   会运行此二进制文件，运行的时候不用带.class 
java没有头文件
hello.java-----------java的文件命名
public class hello{
	
	public static void main(String args[]){
		System.out.println("Hello world!");
	}
}

规范：类名首字母大写，文件名与类名要一致。、


数据类型：
int float
int p2[] = {1，2，4}   静态分配，p在栈中，124在堆中
int p[] = new int[100];      数组，在堆
char str[] = new char[100];  数组，在堆 
java里面数组都都在堆中
char str[] = "123"  错误，不能这样定义字符串
应该写String str2 = "123";  正确 
java中堆空间不用的时候直接将指针指向NULL就可以了，java的垃圾回收机制会自动释放堆空间。
小数点数字默认是double类型


函数：
void (*fun)(struct Person *p){}这里实现struct中的函数即可
struct Person{
	void (*fun)(struct Person *p);
};


对于直接在函数中new新对象需要我们主动释放p，不然如果函数重复执行就会大量内存泄露。
void fun()
{
	Person * p = new Person();//p是栈对象指向堆空间，函数结束会释放p的栈空间，但是对空间不会释放
}
解决办法，专门定义一个class
class sp{
	Person * p;//栈对象
	sp(Person * other)
	{
		p = other;
	}
	~sp()
	{
		if(p) delete p;
	}
}

void fun()这个函数中p本身是栈对象，函数结束就会执行sp的析构函数，将Person释放。
{
	sp * p = new Person();
}



委托后加？.Invoke是什么意思
using System;
 
namespace YhTest1
{
    public delegate void GreetDelegate(string name);//定义委托类型
    class Program
    {
        private static void English(string name)
        {
            Console.WriteLine("Hello!" + name);
        }
        private static void Chinse(string name)
        {
            Console.WriteLine("你好!" + name);
        }
        static void Main(string[] args)
        {
            GreetDelegate test1;//用委托类型GreetDelegate 定义变量test1
            test1 = English;//给变量test1赋值English函数
            test1?.Invoke("小明");//这句话可以打印出来，因为此时test1不是null的
            test1 = null;
            test1?.Invoke("lihua");//这句话不可以打印出来，括号里面是给test传的参数
            test1 = Chinse;
            GreetPeople("梨花", test1);//这句话可以打印出来，因为此时test1不是null的
            Console.WriteLine("Ending.........");
        }
    }
}
.Invoke是什么意思：
判断一下这个委托是不是为null；如果是则不执行委托，如果不是则执行该委托---该委托可能同时是多个函数；
如果test1 = fun1;
test1+=fun2;
test1?.Invoke("梨花");  则这里就会执行fun1 再执行fun2。
Hello!梨花
你好!梨花
Ending......
invoke和begininvoke的区别
invoke：在拥有此空间基础窗口句柄的线程上执行指定的委托
begininvoke：在创建控件的基础句柄所在的线程上异步执行指定的委托




