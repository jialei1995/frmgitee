# BMS知识

## DMA

> DMA支持的外设：timer/ADC/SPI/IIC/UART 管理存储器（包括flash和sram）到存储器，设备到存储器，设备到设备的数据传输

---

## 电池相关知识

> chgdet：充电信号线，充电器一接为1，开始充后又变成0
> det 放电信号线，放电时为1
> idel：中颖的一种休眠模式  此模式下可以充放电唤醒，还有别的模式sleep  xxx只能接充电机唤醒。
> bq76930+bq78350：测电压的可以一节一节校准电压的。
> 万用表关机状态下，调节到电流档也是相当于一根导线，开机也是一根导线。

>
> 充电口万用表检测电压≤3V。
> 因为充电mos是关闭的，测的电压是0V，并不会直接链接到b+ b-
>
> 低功耗模式：注意在停机或者待机模式下，RTC、IWDG的时钟不会停止。

---

> bootload是一段写在真实程序之前的程序，最终会与真实的程序并到一起（用一个特定的exe程序）
> 在bootload中会关闭中断，所以我们在后面的程序中一上来就需要__enable_irq();打开中断，否则中断都不会触发。

---

> 一线通：
> tx:
> rx:收数据是在中断中收完的
> cpu用了2根线，但是外部通过硬件电路处理成了一根线

---

> 电流的标定与电压的标定不是一回事，电流的标定其实就是直接获取程序中sh367获取的电流值。

### 深度睡眠与普通睡眠的关系

> 深度睡眠只有电芯欠压会触发，只有充电机信号会恢复;
>
> 普通睡眠就是害怕板子耗电，各项指标没问题检测判断一遍就会进休眠，随便啥信号就可以唤醒。
>
> 保护板运行的过程中并不是一直在运行态，运行态会耗电，有的板子运行3m会采集一次参数然后判断如果参数都正常进入休眠状态，然后隔几秒就被唤醒去采集数据如果正常就去继续休眠。如果参数异常就去做相应的操作。

### timer

> 1. 为啥要有定时器：
>    CPU本身也是可以定时的，但是会消耗大量的时间，交给定时器就不用管了，他会帮忙精准定时，每个定时器都有1个16bit的预分频器，4个独立的通道，每个通道可以用于输入捕获、输出比较、pwm与单脉冲模式输出。

> 2. timer的clock—source选择internal_clock
>    timer中断的开启需要在界面配置，timex_update_interrupt通过类似TIM_START_TI(&timex)的函数。
>    假设时钟为32M，如何配置一个500ms的计时器让它每500ms产生一次中断：
>    配置时钟源后还需要配置预分频系数：32 000
>    需要配置counter：500
>    则32000✖500✖1/32000000=500ms 这样配置的timer就是500ms。
>
>    timer启动还需要在主函数初始化time完成后调用相应的启动函数才可以启动：
>    tim_base_start(); 不带中断的tim启动
>    tim_base_start_it(); 带中断的time启动函数。
>
> 3. pwm的配置，选择相应的timer在界面配置pwm-generation-chx，需要在主函数中调用
>    Time_PWM_start();去启动pwm通道 pwm就是配置占空比来调节io口的输出高低电平比例。
>
> 4. RTC的alarmup作用，每次休眠之前调一下定时唤醒的函数，在隔特定时长后就会自己alarm把cpu唤醒。
>    cubemx生成的工程是默认配置systick的，生成的systick隔1s会加1.不需要配置就自动隔1s加1.
>
> 5. systick也是可以配置时钟与reload的，ms/us的延时都可以做到，一般做成ms级别的
>    Systick的中断是默认已经开启了的，直接使用即可，查看NVIC里面的time base:systick timer可以看到默认开中断的
>
> 6. 如何获取板子开机至当前运行时间长度：定义ss=0;500ms计数ss05=0;mm=0;hh=0
>    在timer的500ms的中断处理函数中给上述的几个变量赋值：
>
> ```c
>    handle()
>    {
>    	ss05++;
>    	if(ss05==2)
>    	{
>    		ss05=0;
>    		ss++;
>    		if(ss==60)
>    		{
>    			ss=0;
>    			mm++;
>    			if(mm=60)
>    			{
>    				mm=0;
>    				hh++;
>    			}
>    		}
>    	}
>    }
> ```

### adc

> 技术指标：
> 分辨率：10bit的位数1024，每改变1引起的实际电压的变化就是分辨率，0.00xV
> 量程：模拟信号的变化范围，实际是可以准确采集到的，只不过位数有限，所以才会有误差
> 位数：
> 转换时间：完成一次ad转换需要的时间-包括：采样保持量化编码。
> cubemx里面只需要将io口配置成中断，然后写回调函数即可。中断的触发时刻是adc转换完成会触发。
>
> ---
>
> adc驱动：
> 	开启DMA功能后，读取的最新adc的数据会自动存到自己定义的变量当中去（自己定义的变量就在内存中）
> 	开启DMA功能后DMA需要知道它要从哪里读取数据，所以需要把adc_data_reg的reg地址define出来
> 	stm32的对应的地址区域内都有特定功能对应的寄存器，例如adc1相关reg的区域是0x1111-0x2222等等
> 	一个通道就是一个pin脚，可以采集一个adc数据，就是把此pin作为adc后从datareg可以读到对应的采集的adc数据
> 	先在peripheral register boundary addresses章节找到对应的外设占用的边界地址，
> 	然后去对应外设的register map章节查找对应reg的偏移量确认reg的精确地址。
> 	或者用第一次找到的addr->datareg  这样去找数据reg
> 	
>
> 	dma_init() dma的初始化
> 	{
> 		定义dma初始化struct变量;
> 		dma_deinit()；复位dma通道x,固定用法
> 		将dma的struct变量初始化
> 		调用dma_init初始化刚才初始化的变量
> 		dma_cmd(dma1_channel,enable);
> 	}
> 	gpio_init()  adc的gpio初始化
> 	{
> 		开对应port时钟
> 		使能对应的dmax时钟---dmax也算是外设
> 		使能对应的adcx时钟
> 		设置gpio为模拟输入
> 		设置变量的pin为对应的pin	
> 	}
> 	adc_init()
> 	{
> 		初始化dma与gpio后，定义adc的struct
> 		初始化adc的变量结构体
> 		调用adc_init初始化刚才的var
> 		设置adc控制器x，adc的通道，采样顺序，采样周期。调用库函数
> 		adc_regularChannelConfig();
> 		adc_dmacmd(); 开启adc1的dma支持
> 		adc_resetCalbration(); 重置adc1校准reg
> 		等待校准重置成功
> 		adc_startcalibration(); 开始adc1校准
> 		等待校准完成
> 		adc_softwareStartConvcmd(); 使能adc1开始转换。
> 	}

---

> cubemx直接生成的LL库的adc初始化函数会卡死，如图部分：
>
> ![image-20211027185938393](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20211027185938393.png)

> 经过同事测试直接删除没不良影响。

### 结构体

```c
typedef union
{
    uint32_t word;
    struct
    {   
        uint8_t byte_1:8; 0x01  在低字节
        uint8_t byte_2:8; 0x02
        uint8_t byte_3:8; 0x03
        uint8_t byte_4:8; 0x04	在高字节
    }bytes;
}S_WORD;  这么定义的变量,用%d打印出来实际上是：0x04 03 02 01
```

### FSMC是扩展外部sram的接口。

### uart

> uart的接收中断有个hal库函数可以设置接到几个byte才发生中断：（相当于idel中断那个标志位）
> hal_uart_receive_it(&uart1,rxbuf,10);表示收到往rxbuf里面放10个byte才会进入中断处理函数。
> 这句话在uart初始完开启中断后就可以调一下。
> 这样我们可以直接在中断处理函数中处理rxbuf中的数据，解析。

> idel中断：https://blog.csdn.net/qq_29413829/article/details/63262321
> 串口的RXNE中断一次只能接收一个字节的数据，没有缓冲区，无法接收一帧多个数据
> rxne:接收buf非空，收满一个byte触发中断。
>
> ---
>
> RS232原理驱动：
> 	与uart驱动完全一样。
> RS485原理驱动：非屏蔽双绞线
> 	连线需要A--A  B--B
> 	uart+1个gpio =经过电平转换芯片= 485
> 	此gpio为h，表示发送状态 为l表示接收状态
> 	rs485_init()
> 	{
> 		初始化1个普通的io端口并设置为低电平；表示接收
> 	}
> 	rs485_printf(char * fmt,...)  发送函数
> 	{
> 		就是uart的发送函数；+gpio高低电平
> 	}

### IIC

> > https://blog.csdn.net/zhanghuaichao/article/details/48266309 对iic的解读，每个函数定义
>
> IIC驱动程序：基于stm32f10x_ll_iic.c 固件库 
> 	分为总线的驱动iic.c与器件的驱动程序lm75a.c 
> 	iic.c中集成：iic配置初始化函数	
> 初始化gpio+初始化iic控制器--注意需要开启对应iic控制器的时钟与对应的gpio的时钟
> 发送一个字节：按照协议->start->sendaddr+rw->senddata->stop
> 发送buffer：start->slaveaddr->while(datelen>0){发送一个byte;datebuf++}->stop
>
> ```c
> readbyte：
> 					{
> 						while(总线是否繁忙)；
> 						start；等待
> 						sendslaveaddr；等待有没有数据
> 						stop（）；
> 						buf=databuf(iic);将收到的datareg中的数据放到buf中返回。					
> 					}
> ```
>
> ​	lm75a.c中集成了：读取温度值函数->iicread_buffer(lm75addr,regaddr,buf,bytenum);
> ​	掉电函数->iicsend_byte(lm75addr,regaddr,1);--->一般不用，对应低功耗的板子才会去关断它。
>
> 手动模拟io口做iic怎么实现：
>
> ```c
> void SH30x_IICPort_Init(SIMIIC_name_t IICNum)
> {
> 	//配置io口的模式，输出类型，上拉下拉，速度
> 	GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
> 	GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
> 	GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
> 	GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
> 	//sda与scl线都是一样的配置，直接初始化对应的pin即可
> 	GPIO_InitStruct.Pin = IIC_GPIO_INFO[SIMIIC_1].SCL_PIN;
> 	LL_GPIO_Init(IIC_GPIO_INFO[SIMIIC_1].SCL_PORT, &GPIO_InitStruct);
> 	GPIO_InitStruct.Pin = IIC_GPIO_INFO[SIMIIC_1].SDA_PIN;
> 	LL_GPIO_Init(IIC_GPIO_INFO[SIMIIC_1].SDA_PORT, &GPIO_InitStruct);
> 	//初始化完成先发下stop信号，保证初始化没有iic通信
> 	SH30x_I2C_Stop(SIMIIC_1);
> }
> ```
>
> //需要看连接的外设的datasheet,不是看cpu里面的iic描述
> //sh367306的电气参数章节，有个关于通信的通信时序图，里面有个告诉得超过多久才能将电平拉低才会起作用
> //一般只有最小值不设置最大值。参考sh367306的56也的电器图
>
> ```c
> void SH30x_I2C_Stop(SIMIIC_name_t IICNum)
> {
> 	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
> 	GPIO_WritePin(IIC_GPIO_INFO[x].SDA_PORT, IIC_GPIO_INFO[x].SDA_PIN, GPIO_PIN_RESET);先让数据线为0
> 	Soft_Delay(2);延时，这里的实现就是让一个数递减，很占用cpu，可以用timer优化吗？
> 	I2C_SCL_1(IICNum);让scl为1
> 	Soft_Delay(1);延时 
> 	I2C_SDA_1(IICNum);数据线为1
> 	Soft_Delay(2);延时
> }
> ```
>
> ```c
> iic连续发多个字节怎么发：
> start->ack->slaveaddr->ack->data->ack->data->ack->data->ack->stop
> ```
>
> 
sda与scl之前类似于之前的一线通的tx引脚与rx引脚电平
只有tx为1的时候才能读rx，否则无效。

在iic中在waitack阶段：
主机的sda为1时，从机才可以控制sda的电平为1/0
主机的sda为0时，从机无法控制主机电平
从机的sda为1时，主机才可以控制sda的电平为1/0
从机的sda为0时，主机无法控制主机电平

从机在waitack之后如果释放了sda总线，此时如果主机不控制sda，则sda就默认是高电平

### gpio
引脚设置为pp输出，读的时候就要读
GPIOB->ODR&GPIO_PIN_X  输出数据寄存器
引脚设置为输入模式，读的时候就要读 
GPIOB->IDR&GPIO_PIN_X  输入数据寄存器
STM32怎么读取输出口电平？
其实你自己在库函数源文件也能找到，以PC13为例：
要是你设置为输入：
GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_13);//读取输入口PC13值
要是你设置为输出：
GPIO_ReadOutputDataBit (GPIOC,GPIO_Pin_13); //读取输入口PC13值
我看的原函数，两个读取函数操作区别在于读取的寄存器不一样，分别是：
GPIOx->IDR
GPIOx->ODR

> 复用的时候Alternate选择AFx怎么确认，在datesheet里面搜alternate function mapping，user manual中没有
>
> ---
>
> 配置gpio-init：
> 	1.初始化struct变量
> 	2.将以上配置init(pinx,portA)
> 	pin的输入模式改成in后，设置的推挽输出就不起作用了，不影响
>
> EXTI中断：
> 	配置可以触发中断的中断号，PX
> 	把对应的gpio初始化为input模式--初始化gpio结构体
> 	初始化exti变量结构体--对应的pin脚
> 	设置优先级+使能中断--就是将EXTI与NVIC对应的通道结合起来
> 	exti0-15对应7个中断处理函数，这就是7个中断向量，NVIC里面定下来的。
> 		stm32的外部引脚中断只有0-15号中断，16以上的中断是内部其他控制器可以触发的中断
> 		exti是外部中断，nvic是arm内核里面的中断向量--exti配置的中断最终会跟nvic的中断对应起来
> 	EXTI_X_IRQ()
> 	{
> 		先判断是哪个中断
> 		{
> 			清除触发此号中断的标志位；
> 			调用回调函数处理中断---可以重写。
> 		}
> 	}

### 片内flash操作

> stm32对flash读写：falsh操作的途中要关闭中断__disable_irq();
>
> ```c
> 	flash写：传入flash中的add，传入要写入的data。
> 	固件库中提供了很多对flash的op函数
> 	{
> 		1.需要在这里或者外部提前开启flash的时钟            
> 		2.flash_unlock();  固定操作，每次操作前都要先解锁
> 		3.清除标志位x,y,z
> 		4.flash_erasepage(add); 清除要写的地址的数据，要以页的方式擦除
> 		5.flash_programword(add,data); 调用固件库函数从指定页的add开始写入data
> 		6.清除标志位x,y,z
> 		7.flash_lock(); 
> 	}
> 	flash读：传入add即可
> 	{
> 		u16 a;
> 		return a=*(u16*)(add); 从指定页的add开始读，只返回16bit的数据
> 	}
> ```
>
> 操作一定是先擦除再写入，每页1024个地址，起始地址0x08000000 
> 擦除以页为单位，写操作必须以16bit为单位，允许跨页写
> 擦除时注意避开用户程序的存储区域，避免擦除掉用户程序
>
> g030的flash大小64k，这64k的前面的地址用来存储code，最后的2k用来存数据.
> 手册里面每个page大小说是2k。
> 总的地址范围是：0x0800 0000---0x0801 0000这是16进制，则大小就是64k了。
> user的可用地址范围是：0x0801 0000-0x800到addr的end（刚好一页大小）
> 我们存到flash里面的数据就这一个dword共8byte，直接映射就得到了当前flash中的值dword = *(__IO uint64_t *)Address;
> flash里面的初始值就都是1，我们平时擦除的时候，就是将flash里面所有的bit置1.

### bootloader分析
> 启动文件：bootloader
> 1.初始化堆栈指针  sp指针由高地址向低地址生长
> 2.初始化pc指针，pc=reset_handle
> 3.初始化中断向量表
> 4.配置系统时钟
> 5.跳转到c里面的main函数
>
> 0x400=1k
> 1G=1ns  1M=1us  1k=1ms

### 看门狗

> 独立看门狗：
> 12bit递减计数器，8bit预分频器，用的内部40kHz的RC振荡器提供时钟，
> 这个振荡器独立于主时钟，所以它可以工作在停机待机模式。
> 通过配置可以配置成硬件或软件启动看门狗。
> 调试模式时，计数器可以被冻结。
>
> 窗口看门狗：
> 7bit递减计数器，可以设置自由运行，由主时钟驱动
>一般看门狗的时钟如果用内部的时钟源则是40k的时钟，如果用外部的时钟源，则选取32.768k的时钟，然后再分频算步进时间

### 中断

> nvic中断分为系统级的与外设级的：
> 系统级的有10个：例如reset，nmi,未定义指令，取指令失败，systick
> 外设级的有60个：各种外设
> nvic是嵌套中断向量控制器，属于内核的外设，管理所有的片上的中断相关的功能。
>
> 外设中断进程调用HAL_Delay(底层就是systick的中断)的时候，要特别注意中断的优先级问题，如果systick的中断优先级低于外设中断优先级，会导致一直在外设中断中阻塞，
> 如果外设中调用了HAL_Delay()，一定要保证Systick的中断优先级高于外设中断优先级，但是，小飞哥是极其不建议在中断中调用HAL_Delay（）函数的
>
> ---
>
> gpio中断设置时可以直接选择gpio_extix，这里这么配置后关于gpio的选项里面才会出现NVIC的配置
> 同时在NVIC里面也要打开EXTI对应的那些line，触发条件边沿触发，
> 使能相应的NVIC通道并选择优先级。
>
> ```c
> EXTI15_10_IRQHandle()
> {
> 	HAL_GPIO_EXTI_IRQHandle(pin)   如果没有hal库就自己在这个handle里面写操作就行，注意清flag。
> 	{
> 		清标志位
> 		执行callback回调函数
> 		{
> 			真正对pin脚的操作。
> 		}
> 	}
> }
> ```
>
> 对应的中断优先级的配置在界面的NVIC控制器里面可以通过对勾开启对应的中断并选择优先级。

### 消抖操作

```c
if(按键被按下)
{
	delay 20ms;   延时一会后按键仍被按下。
	if(案件被按下)
	{
		做真正的操作；
	}
}
判断充电状态的时候需要防抖动，得判断充电time>3才可以真正的去开充电mos。
```

### 寄存器映射

```c
寄存器存在于每个外设中，编程就是通过cpu配置各种外设的reg的值
给有特定功能的内存单元取别名，这个别名就是reg，给这个特定内存单元取别名的过程就是reg映射。

reg的映射过程演变：
1.直接操作地址：
	*(unsigned int)(0x12345678) = 0xffff
2.可以通过操作给每个地址取个名字，例如51单片机中的操作
	sfr p0=0x80；
	sfr tlo=0x40；
	写数据的时候可以直接 *p0=0xffff
3.在stm32中:不是通过sfr，而是通过define给每个地址取个名字。
	#define GPIOB_ODR (unsigned int)(0x12345678)
	操作： *GPIOB_ODR=0xffff；  这种方法往地址写数据
4.为了更方便：
	#define GPIOB_ODR *(unsigned int)(0x12345678)
	操作： GPIOB_ODR=0xffff；   
	c语言对总线外设基地址的映射通过头文件，这里的都是地址的映射，都没有带*
		define ahb  0x1
		define apb ahb+x
		define gpioB apb+x
		define gpidB_date gpioB+x
		define gpioB_ctl gpioB+y
	增加struct后呢？
	typedef struct{
		reg1;reg2;reg3;
	}gpio_typedef;
	只需定义一个gpio_typedef*变量就可以访问通过->访问相关reg。

	这种封装已经在固件库中封装好了，以上是封装的过程，原理。
```

## 无法分类的知识

> 常量存在flash里面，变量存在sram里面。
>
> ---
>
> 固件库分析：
> 1.startup—stm32-hd.s hd表示flash大小，设置堆栈，pc指针，初始化中断向量表，配置sys时钟，调用_main进入c的世界
> 2.system-stm32f10x.c 时钟配置文件,倍频外部时钟8-72m
> 3.外设相关 stm32f10x.h  实现内核之外的外设的reg映射
> 	stm32f10x_xx.c 外设的初始化struct，外设的驱动函数库文件（这个文件很多
> 	种类例如：stm32f10x_gpio.h stm32f10x_uart.h stm32f10x_iic.h等等）
> 4.内核相关 core_cm3.h 实现内核里面的外设的reg映射 
> 5.头文件的配置文件 stm32f10x_conf.h 
> 	头文件的头文件，这个头文件中已经include了所有外设用的头文件
> 	例如：stm32f10x_gpio.h stm32f10x_uart.h stm32f10x_iic.h但是都是屏蔽的
> 	所以我们只需要包含这个一个头文件，将这个文件中的相关的include去掉屏蔽即可。
> 6.专门存放中断服务程序的c文件 stm32f10x_it.h  方便管理。
> nvic嵌套向量中断控制器，系统滴答定时器--misc.h
>
> ---
>
> ENUM
>
> typedef enum{var1,var2,var3} VVV;
> 这里的var1,var2,var3是用VVV定义的变量x只能从这3个数据中取值
> 并且：var1,var2,var3本身也可以直接在程序中去用，把它当成一个define好的宏去用就可以。
>
> typedef union{
> 	uint32_t byte;
> 	struct {
> 		bit1:1;先写的bit是lsb，最下面的bit是msb。低地址
> 		...高地址
> 	};
> }; 这里的这种方法共用地址，定义的变量初始化的时候可以用var.byte=0去初始化
> 往变量里面赋值的时候可以用var.bit的方法去1bit1bit的赋值
> 最后还是用var.byte的方法去读值。这种技巧很适合对于reg的操作。
>
> ---
>
> 移位操作
>
> 不同的数据左右移位之后的数据变化
> int i=1 有符号： 000001 右移之后成0000
>                     左移之后成00010
> int i=-1 有符号： 11111  左移之后右边补0后成11110  这个是-2
>                      右移之后左边补1,还是11111 还是-1，右移几bit都一样是-1
> unsigned int i=1 无符号：000001，右移之后左边补0变成00000
> 						左移之后还是变成2
> unsigned int i=-1，这个也是可以的，意思是i=2^64-1如果用%u输出
> 如果用%d输出还是-1，左移还是变成-2。%d会将原数据默认转换成signed int

---

> 参考程序:
>
> ```c
> int main()
> {
> 	int i=0;
> 	uint8_t buf[12] = {0};
> 	uint16_t var=0x1023; 
> 	buf[0] = var>>8; buf[0]只取var>>8的低8bit
> 	buf[1] = var;buf[1]只取var的低8bit，高bit不管
> 	printf("%x--%x\n",buf[0],buf[1]); 0x10 0x23
>     return 0;
> }
> ```
>
> 

## bootloader

> 为啥要有bootloader：
> flash中存的bootloader+app。0-1000存bootloader  1000+2000 存app.
> 第一次上电从bootloader运行判断是要下载程序还是直接运行，
>
> 1.若下载程序，直接根据新的app大小擦除覆盖1000-2000的数据,然后直接写入flash中新的app程序。
> 2.若要运行程序，直接跳到1000去执行。
>
> ### g030的app程序需要更改3处位置，作bootloader新程序。
>
> flash本身是从8000 000位置开始存放数据
> bootloader越小越好，一般从8000 000-8000 1900之前存bootloader，之后存app
>
> 1. keil设置target中的IROM1:0X80018F8表示新程序从这里开始。
>
> 2. 将main里面的static const uint8_t VERINFO[8] __attribute__((at(0x80018f8)))这句话写上，表示我们在程序最开始位置写gtds头信息(其实写入的并不是GTDSLONG，还|了一下别的参数)
>
> 3. 修改g0xx.c  #define VECT_TAB_OFFSET  0x1900U为啥是1900呢？
>
>      1）.程序开始是中断向量表必须是100的倍数。
>      2）. 本来我们想设置app从1800开始的，但是程序会变成gtdsxxxxxxxxxapp，中间的位置就空了，程序出现断裂， 所以我们直接把程序的开始放到1900往前偏移8byte程序就完全连接起来了。
>

---

> 16进制的数据里面会存放数据的位置信息，但是2进制的数据里面不会存放位置信息，所以2进制程序比16进制程序小很多--一半以上
> 第一次烧写程序的时候放的bootloader+app的16进制文件合并内容，以后再烧写的时候放的是bin文件。

---

> ## bin文件怎么用keil生成呢？
> 在keil配置的User里面选中after build/rebuild.
>
>
> ```shell
> fromelf --bin --output .\black_shield\black_shield.bin .\black_shield\black_shield.axf
> ```
>
> > fromelf --bin --output .\black_shield\black_shield.bin .\black_shield\black_shield.axf
> >
> > .\：为当前keil工程所在的同级路径.
>
> ### bin文件命名规范
>
> ```
> 项目代号_FACTURECODE_PROJECTCODE_HARDCODE_M_软件版本.bin
> jltest_01_620_V102_V100.bin
> 其中中间三项必须与app代码中的一模一样，项目代号与软件版本可以随便写。
> bin文件名字与hex的名字一致才可以生成bin文件。
> 烧写程序的时候监控软件有个硬件子版本号需要跟main刚开始的HARDCODE_S一致，切记
> ```
>
> ![image-20211026120823569](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20211026120823569.png)

![image-20211026175611231](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20211026175611231.png)

#### bootloader修改配置

> 初始化刷程序的uart
>
> 初始化power_en的gpio并设为1
>
> 修改flash大小：不同的片内flash不一样
>
> 修改FIRMWARE_MAXSIZE大小---boot_flash.c
>
> 其他地方不用改就好

#### app修改配置

> #define FLASH_USER_END_ADDR   (FLASH_BASE + 0X8000)    app_flash.h中8000是flash的size,这里用宏替代***
>
> 3.将cinfigure中的IROM1改成800 18f8
>
> system_stm32g0xx.c文件设置中断偏移量VECT_TAB_OFFSET改成1900,这个是程序的开始位置
>
> #define VECT_TAB_OFFSET  0x1900U

#### 调试

> 1.将system_stm32g0xx.c中断偏移量VECT_TAB_OFFSET改成0000
>
> 2.将main.c中刚开始的绝对地址赋值屏蔽。
>
> 3.将cinfigure中的IROM1改成800 0000



# keil报错
abs函数报warning，包含matn.h 与 stdlib.h 缺一不可，都包含就不会报错了

uint8_t is not a type name ; 原因：在某个.h文件中声明的函数名字没写对，只有

void (uint8_t *txdBuf,uint16_t len);

2. ST-link驱动怎么升级？点击device connect然后点击确定（需要将板子+st-link+笔记本连接起来才能升级）


# 其他常识

#### 2v的电芯300a放电有危险吗？

没有，人体电阻1000k。站到300a导线中间，则电流就流不过去了，因为2/1000k=0.000002a一点危险都没有。

#### 测绝缘的机器2500v，为啥把人打不死？
它的输出只有2ma，两端断开的时候它就是2500v，但是人手解除的时候，人是2ma,2ma*2k=4v 接触的同时人身体的电压只有4v，并不是2500v

#### 保护板上的充电mos与放电mos怎么开启的？

正常放电的时候充电mos与放电mos都是闭合的，如放电有保护，则关闭放电mos，则现在不能放电只有充电mos是闭合的。此时如果充电，在放电mos的二极管会有0.7v压降，但是并不影响充电，保护板检测到有充电电流的时候会闭合放电mos，减小功耗的损失。

正常充电的时候充电mos与放电mos都是闭合的，如充电有保护，则关闭充电mos，则现在无法充电了，但是可以放电。放电时充电mos有0.7v压降，但是并不影响放电，保护板检测到放电电流的时候会闭合充电mos，减小功耗的损失。

#### uart

笔记本缺少232驱动 485连接无法通讯

缺少ch340驱动，串口无法通讯。

-----------------------------
三端保险：一个可以通过信号自动断开的保险
因为保险本身是过流才会断开的；电芯过压的时候如果mos坏了，电芯可以一直充电，此时已经是小电流充电，保险不会
断开，但是很危险。此时我们就应该给三端保险信号让他自动销毁。

PTC柜子：放电柜子
PCS：充电柜子

正常储能系统中充放电就是PCS系统控制的一个大ACDC。

同步帧：上位机每隔1s会给下位机发请求数据的帧，n个下位机收到后便会每隔30ms一个一个给上位机回数据。
-------------
4812 4820  48v12AH 48V20AH  电池重要的参数就是电压 容量
电池充满静置的时候电压会掉下去一部分，放电的时候停止放电电压又会升上去一点。--电芯特性
----------------
SPI：
(1)Leading edge=前一个边沿=第一个边沿，对于开始电压是1，
那么就是1变成0的时候，对于开始电压是0，那么就是0变成1的时候；
(2)Trailing edge=后一个边沿=第二个边沿，对于开始电压是1，
那么就是0变成1的时候（即在第一次1变成0之后，才可能有后面的0变成1），
对于开始电压是0，那么就是1变成0的时候；
CPHA=0，表示第一个边沿：
对于CPOL=0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿采样（读），下降沿输出（更改miso方向）
对于CPOL=1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿采样，上升沿输出
CPHA=1，表示第二个边沿：
对于CPOL=0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿采样，上升沿输出
对于CPOL=1，idle时候的是高电平，第二个边沿就是从低变到高，所以是上升沿采样，下降沿输出
有的从机芯片的对极性的设置根本没要求，设置成0或者1都没关系
我们需要看从机手册是哪个边沿读取数据来确定cpu应该设置成哪种相位。
若从机是上升沿读取/采样数据我们需要设置哪种极性与相位的结合
若从机是下降沿读取/采样数据我们需要设置哪种极性与相位的结合

gpio模拟spi：有的spi从机还多有个D/C引脚线，控制你发的是cmd还是数据
1.gpio初始化：
设置cs片选引脚为output
设置SPIMISO为输入input----可见主机的输出对从机来说相当于输入，
						从机的读为上升沿，则主机设置的时候应该是上升沿写，下降沿读
设置SPIMOSI为output
设置SPICLK为output
2.一般从机的初始化函数可以在对应的手册中找到----主机给那些reg发那些数据，发完就初始化完成了
oled_write(cmd)  发cmd的函数
{
	set_dc(0);表示发送的是cmd
	set_cs(0);拉低电平，开始发送数据
	spi_send(cmd);
	set_dc(1);恢复dc
	set_cs(1);拉高cs电平，停止发送数据
}
oled_write(data)  发data的函数，区别就是对d/c引脚设置的不同
{
	set_dc(1);表示发送的是data
	set_cs(0);拉低电平，开始发送数据
	spi_send(data);
	set_dc(1);恢复dc
	set_cs(1);拉高cs电平，停止发送数据
}
spi_send(byte)
{
	for(i = 0;i < 8;i++)//这个从机要求上升沿读，所以我们要在上升沿发数据
	{
		set_clk(0);     拉低clk准备数据，因为我们需要在上升沿发
		set_do(byte & 0x08);  发送数据的最高bit
		set_clk(1);		拉高clk发送数据出去，产生上升沿sck时，do数据已经准备好了并发出去了
		byte<<1;         将数据左移1bit
	}
}
set_do(val)往spi的do引脚发送数据
{
	if(val)GOIO_DO |= 1<<6;
	else GOIO_DO &= ~(1<<6);
}
---------------------野火教程使用spi
spi结构体：
{
	SPI_Direction;  一般都设置的双向全双工模式
	SPI_mode;   设置主从机模式，cpu肯定设置的主机模式呀
	SPI_DataSize;  设置spi的数据帧长度，可选8/16bit，每一帧发1字节还是2字节
	SPI_CPOL; 极性
	SPI_CPHA;  相位，可选奇/偶边沿采样
	SPI_NSS;  设置nss引脚由软件控制还是spi硬件控制
	SPI_BaudRatePrescaler;   设置时钟分频因子
	SPI_FirstBit;    设置MSB/LSB先行，一般设置msb先发
	SPI_CRCPolynomial;   设置CRC校验表达式，一般不需要管
}
对flash的操作需要很多命令：
{
	1.read reg1_status 读状态1寄存器值  给从机发0x50数据，从机就会返回对应的数据
	2.page program   写数据 ，先发0x02命令，然后发要写入的addr，然后发具体的数据1字节
	3.sector erase   擦除数据，先发0x20命令，然后发要擦除的地址，则就会擦除，擦除完成读reg_status看是否成功擦除
	4.read data    有可以读单字节与一次读多字节的命令，格式也不一样
}

spi_init()
{
	spi_initstruct;
	spi_initstruct.SPI_Direction = SPI_2Lines_FullDuplex;  一般都设置的双向全双工模式
	spi_initstruct.SPI_mode = SPI_mode_Master;   设置主从机模式，cpu肯定设置的主机模式呀
	spi_initstruct.SPI_DataSize = SPI_DataSize_8b;  设置spi的数据帧长度，可选8/16bit，每一帧发1字节还是2字节
	spi_initstruct.SPI_CPOL = SPI_CPOL_High; 极性
	spi_initstruct.SPI_CPHA = SPI_CPAH_2Edge;  相位，可选奇/偶边沿采样
	spi_initstruct.SPI_NSS = SPI_NSS_Soft;  设置nss引脚由软件控制还是spi硬件控制,一般设置软件控制，则CSS引脚我们可以随便指定一个io口
	spi_initstruct.SPI_BaudRatePrescaler = SPI_BaudRATEPrescaler_2;   设置时钟分频因子
	spi_initstruct.SPI_FirstBit = SPI_FirstBit_MSB;    设置MSB/LSB先行，一般设置msb先发
	spi_initstruct.SPI_CRCPolynomial = 0;   不使用crc校验，随便设置一个数字
	
	SPI_Init(SPI1,&spi_initstruct);
	SPI_CMD(SPI1,ENABLE);
}

//SPI里面只需要实现一个函数就可以发送并接收数据，并且spi的可以同时实现发送并接收功能
uint8_t SPI_FLASH_SEND_and_RECEIVE_BYTE(uint8_t data){
	//检查并等待spi的tx缓冲区为空，只有tx缓冲区为空我们才可以发送并接收数据
	while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE)==RESET);  //若发送缓冲区不为空则卡死
	{
		//这里最好不要直接写成死循环，应该设置一个超时事件
		if(SPI_TIMEOUT-- == 0) return callback(0);这个回调函数便于我们定位问题
	}
	//执行函数发送数据
	SPI_I2S_SendData(SPI1,data);
	//检查并等待直到SPI的rx缓冲区为非空,rx缓冲区为非空才能读取数据
	while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE)==RESET);
	{
		//这里最好不要直接写成死循环，应该设置一个超时事件
		if(SPI_TIMEOUT-- == 0) return callback(0);这个回调函数便于我们定位问题
	}
	//可以读取了则读取数据并直接返回
	return SPI_I2S_ReceiveData(SPI1);
}

上面的发送函数同时实现了读写功能，就是读的时候每次都需要先发1byte数据，我们可以重定义一个read函数，发没用的0x00然后
收数据，更好。这样读的时候就不需要发有用的cmd，随便发个数据就好了 
uint8_t SPI_FLASH_RECEIVE_BYTE(uint8_t data){
	return SPI_FLASH_SEND_and_RECEIVE_BYTE(0x00);
}
注意注意，真正的spi通信都是调用很多cmd对从机操作然后收数据，写数据了，我们还得集成几个flash手册里面的函数
//读flash的id的函数
uint8_t read_flashid()
{
	uint32_t flashid;
	//片选使能
	SPI_CS_LOW;
	SPI_FLASH_SEND_and_RECEIVE_BYTE(READ_JEDE_ID); 这个READ_JEDE_ID命令就是手册中告知读id的时候需要发这个
	flashid |= SPI_FLASH_RECEIVE_BYTE(0x00);
	flashid <<= 8;
	flashid |= SPI_FLASH_RECEIVE_BYTE(0x00);
	flashid <<= 8;
	flashid |= SPI_FLASH_RECEIVE_BYTE(0x00);
	SPI_CS_HIGH;
	return flashid;
}

//扇区擦除操作,注意调用这个函数的时候后面需要检查是否擦除完成。
void SPI_ERASE_SECTOR(uint32_t addr)
{
	FLASH_SPI_CS_LOW;
	SPI_FLASH_SEND_and_RECEIVE_BYTE(erase_cmd);
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr>>16 & 0xff);
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr>>8 & 0xff);
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr & 0xff);
	FLASH_SPI_CS_HIGH;
}
//检查是否flash的某个动作完成当前状态是不是busy，需要根据手册实现读取状态reg的对应bit的函数
void SPI_WAITFOR_WRITEEND()
{
	uint8_t status;
	FLASH_SPI_CS_LOW
	SPI_FLASH_SEND_and_RECEIVE_BYTE(READ_STATUS);//先发读状态reg的cmd
	do{
		status = SPI_FLASH_SEND_and_RECEIVE_BYTE(DUMMY);//直接返回的寄存器状态，判断reg状态的对应bit是否为1
	}while((status & 0x01) == 1);是不是busy，如果==1，说明busy，则死循环等flash操作完成
	FLASH_SPI_CS_HIGH
}
//读取flash内容
void SPI_READ_DATA(uint32_t addr,uint8_t * buff,uint8_t numtoread)
{
	FLASH_SPI_CS_LOW
	SPI_FLASH_SEND_and_RECEIVE_BYTE(READ_DATA);先发cmd表示要读数据
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr>>16 & 0xff)
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr>>8 & 0xff)
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr & 0xff)
	while(numtoread--)
	{
		*buff=SPI_FLASH_RECEIVE_BYTE(DUMMY);
		buff++;  偏移指针
	}
	FLASH_SPI_CS_HIGH
}

fromelf --bin --output .\g030f6p6_ll\BLX6020_01_162_V120_V025.bin .\g030f6p6_ll\BLX6020_01_162_V120_V025.axf



vertical  采样曲线上下移动  下面的按钮：每格子的电压精度。
positive  采样线左右移动   按下去归零

SPI：因为接收数据的时候可以同时发送数据，所以我们一般会在收到数据后直接走发送数据的流程，
其实也可以收数据的时候只收，收完数据等会再执行发送数据的流程，只不过这样就浪费了SPI全双工的
优势。所以我们一般都会在收到数据后直接就看有没有要发的数据在去发。
发的数据与收的数据本身没有啥关系。

-----------------为啥手接零线还是会触电 
我们摸零线的时候我们与大地与火线其实已经形成了回路，相当于我们接了火线。
----------------为什么一线通的一端要接P-
只是用来证明mos没通的时候无法进行一线通通信，并不会有危险。错错错，会有危险。
因为mos通的时候我们的cpu的gnd与外部usb的gnd共地了才可以通信。usb--信号--CPU
															usb--GND--P- --mos通--B- ------CPU的地  共地
若mos没有通，则无法与CPU共地，则无法传输数据，因为没构成回路，此时USB的5V并不会有啥危险。
为啥有危险：见bms图说明
所有的通信都要共地加信号线。

地有好几种，大地的地  板子的地  电池的地  如果不用DCDC隔离就是共同的地，隔离之后的地就不太一样了吗？

通断--断开，闭合 以后不能再说开关了。
-------------
一线通的TX引脚在进入休眠之前要置为高电平，所以休眠初始化的时候不能初始化此引脚为input。需要避开这个引脚。
预充驱动的引脚同理，在进入休眠之前要开预充引脚，所以此引脚不能直接初始化为input，需要避开。

看门狗的设置不需要用硬件也可以实现，可以在while1里面给SoftWDTTIme清0，在systick中给SoftWDTTIme++。如果加到1000直接
调用NVIC_SystemReset(); 就实现了复位。

软件版本在哪里改：在appconfig.h里面搜 软件版本RWSERVIN

--------------sh367306为啥没有CHGDET也可以充放电唤醒。
其实不是直接唤醒的CPU，是sh367检测到充放电电流后会发出alarm信号，才会唤醒CPU。

VPRO在gpioinit的时候没有置1.需要初始化的时候置1，不然sh367309会进入写eeprom态，无法正常读取电压电流

------------程序里面四舍五入的方法
本来x=y;
四舍五入：x= (10y+5)/10;	若10y的个位数>5 则最终取值+1，若<5则最终取值-1.
本质：x=y+0.5;  就是加个0.5看是否满足进一

---------------------
如果一个数定义成uint类型，则这个数必然不可能成为负数，不可能比0小。
若循环减减某个uint类型的数它最小就是0.
若需要减成负数，则需要定义成signed int类型,使它可能成为负数。



keil中ctrl+b：查找当前keil工程中的所有断点，keil中断点太多了就会警告无法调试。需要取消部分断点再去调试。

SysFlag sysflag;定义此变量之后，若要赋值只能给sysflag=x去赋值，不能直接赋值内部共用体成员的值
ps：sysflag.bits.mem1 = 1   这种操作会报警
正确的做法是：将sysflag.bits.mem1 = 1写在其他函数内部。可以写一个init函数，在函数内部对成员mem1进行初始化。



看到这里有点奇怪，i2c write是以ack+stop结束通信，而i2c read是以nack+stop结束通信的，原因如下：

i2c write的时候，master在写完最后一个字节之后slave会回ACK，然后master发送stop信号结束通信

i2c read的时候，master在接收完slave发送的最后一个字节之后会回NAK，因为这个时候master已经接收到足够的字节，NAK告诉slave不要在发送数据了。


读需要再次发个restart信号，因为读之前需要先写地址。真正读数据的时候需要restart一下，再发读地址，然后才是读的数据。
如果读里面没有restart，总线上发的数据就还是写的，就不是读了。

写直接发送start信号之后就可以一直发数据了

-----对于smbus协议
如果操作的是开关设备，有个quickcmd
s+addr+r/w+ack+stop  不需要发送data，r/w就是1/0就可以控制dcdc的开或关。
IIC的read/write与smbus的read/write不同，我们平时接触的大多IIC器件其实都用的是smbus协议
ps:
iic的block write 
s+addr w+ack+interl reg+ack+datax+ack+stop
smbus的block write 
s+addr w+ack+interl reg+byte_count+ack+datax+ack+stop

iic的block read 
s+addr w+ack+interl reg+ack+restart+addr r+datax+nack+stop
smbus的block read
s+addr w+ack+interl reg+ack+restart+addr r+byte_count+ack+datax+nack+stop

尽量优先使用smbus，大多器件都支持smbus。

## 对enum的学习 struct中的：占位

1. enum ASN{MON=7, TUE, WED=10, THU, FRI};  

2. ASN是个标识符，是一种数据类型（可选项-可有可无）

*enum DAY
{
   MON=1, TUE, WED, THU, FRI, SAT, SUN
};*

enum DAY good_day, bad_day; //变量good_day和bad_day的类型均为枚举型enum DAY

---

enum    //跟第一个定义不同的是，此处的标号DAY省略，这是允许的。
{
    saturday,
    sunday = 0,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday
} workday; //变量workday的类型为枚举型enum DAY，这种无法再定义此类型的变量

---

 typedef enum用法

  typedef enum workday（此处workday是数据类型，通过它可以定义变量）
{
    saturday,
    sunday = 0,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday
};

workday today, tomorrow; //变量today和tomorrow的类型为枚举型workday，即enum workday

-----

*** 对于创建的变量赋值的时候只能赋值括号中的那些数值，默认从0开始。 也可以每个数据都赋别的数值，不然enum就会默认加1.





-----struct中的”：“什么意思

https://blog.csdn.net/q2519008/article/details/81478701

位域：位域出现的原因是由于某些信息的存储表示只需要几个bit位就可以表示而不需要一个完整的字节，同时也是为了节省存储空间和方便处理。

```c
typedef struct  bit_struct

{
    int  bit1:3;

    int  bit2:5;

    int  bit3:7;

}data;
```

bit1、bit2、bit3表示对应的位域

整个位域结构体占用2个字节

bit1占3位，bit2占5位，bit1和bit2共用一个字节

bit3占7位，独占一个字节。

位域必须存储在同一个类型中，不能跨类型，同时也说明位域的长度不会超过所定义类型的长度

----

ringBuffer_t var= {0,0,{0},0,0,100};  对结构体中有数组的变量可以直接在定义的时候初始化。

### 多层while与if嵌套

```c
在多重while嵌套结构中使用break，会退出距离break最近的那一层while循环，且多从if嵌套对break无约束作用，会跳出最外层if，寻找与之最近的最内层while跳出
   exp:https://blog.csdn.net/oykotxuyang/article/details/105876206
```

---

串口初始化流程：

```c
{
	定义LL_USART_InitTypeDef结构体变量；
	定义LL_GPIO_InitTypeDef结构体变量；
        
    使能uart1/2时钟，这个是外设时钟；
    使能具体gpio时钟，uart1/2用的那个管脚
        
    LL_GPIO_InitTypeDef.成员={pin,模式（输入、输出、复用）,速度,
                            输出类型（推挽、开漏）--串口就设置推挽,
                           Pull(no,pull up,pull down)--一般硬件管理？我们设置no即可，
                           Alternate(LL_GPIO_AF_1)--复用哪个功能，有iic，uart，mco，time查datesheet可知}
    配置完之后初始化一下此配置的pin,则当前变量没用了，对下一个pin初始化。
        
    配置中断优先级并且使能中断。
    
    对LL_USART_InitTypeDef结构体变量的初始化。
    PrescalerValue，波特率，datewidth，stopbit，Parity，TransferDirection，HardwareFlowControl，OverSampling
    配置完之后init这个变量
        
    LL_USART_ConfigAsyncMode(USART1); --异步
	LL_USART_EnableIT_RXNE(USART1); --？
	LL_USART_EnableIT_IDLE(USART1); --？

	LL_USART_Enable(USART1);--最后使能串口1
}


```



---

LL库与hal库怎么用的，怎么选择

LL库与HAL库类似，hal库体积比较大，ll库体积小。

在cubemx生成的时候，选择用哪个库，生成代码的时候就会选择对应的库。--趋势

---

#### ADC初始化

```c
定义LL_ADC_InitTypeDef与LL_ADC_REG_InitTypeDef结构体变量
定义LL_GPIO_InitTypeDef 变量
初始化外设时钟adc外设时钟，初始化gpio时钟
变量.Pin，.Mode = LL_GPIO_MODE_ANALOG；.Pull = LL_GPIO_PULL_NO
初始化此变量
//初始化LL_ADC_InitTypeDef
	ADC_InitStruct.Clock = LL_ADC_CLOCK_SYNC_PCLK_DIV2;
	ADC_InitStruct.Resolution = LL_ADC_RESOLUTION_12B;
	ADC_InitStruct.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
	ADC_InitStruct.LowPowerMode = LL_ADC_LP_MODE_NONE;
	LL_ADC_Init(ADC1, &ADC_InitStruct);
//初始化LL_ADC_REG_InitTypeDef
	ADC_REG_InitStruct.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;
	ADC_REG_InitStruct.SequencerLength = LL_ADC_REG_SEQ_SCAN_DISABLE;
	ADC_REG_InitStruct.SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
	ADC_REG_InitStruct.ContinuousMode = LL_ADC_REG_CONV_SINGLE;
	ADC_REG_InitStruct.DMATransfer = LL_ADC_REG_DMA_TRANSFER_NONE;
	ADC_REG_InitStruct.Overrun = LL_ADC_REG_OVR_DATA_PRESERVED;
	LL_ADC_REG_Init(ADC1, &ADC_REG_InitStruct);

	LL_ADC_SetOverSamplingScope(ADC1, LL_ADC_OVS_DISABLE);
	LL_ADC_SetTriggerFrequencyMode(ADC1, LL_ADC_CLOCK_FREQ_MODE_HIGH);
	LL_ADC_SetSamplingTimeCommonChannels(ADC1, LL_ADC_SAMPLINGTIME_COMMON_1, LL_ADC_SAMPLINGTIME_160CYCLES_5);
	LL_ADC_SetSamplingTimeCommonChannels(ADC1, LL_ADC_SAMPLINGTIME_COMMON_2, LL_ADC_SAMPLINGTIME_160CYCLES_5);
	LL_ADC_EnableInternalRegulator(ADC1);
	
	/* Delay for ADC internal voltage regulator stabilization. */
	ADC_VREFINT_CAL= *(uint16_t*)0x1FFF75AA;
	//ADC_VREFINT_DATA= LL_ADC_GetCalibrationFactor(ADC1);
	//printf("ADC_VREFINT_CAL=%d\r\n",ADC_VREFINT_CAL);
	
	ADC_Calibration();
	uint32_t wait_loop_index;
	wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US * (SystemCoreClock / (100000 * 2))) / 10);
	while(wait_loop_index != 0)
	{
		wait_loop_index--;
	}
	//使能内部基准电压
	LL_ADC_SetCommonClock(ADC1_COMMON,LL_ADC_CLOCK_ASYNC_DIV12);
	LL_ADC_SetCommonPathInternalCh(ADC1_COMMON,LL_ADC_PATH_INTERNAL_VREFINT);
/* Configure Regular Channel
	*/
  LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_1, DEF_CH_T1);
  LL_ADC_SetChannelSamplingTime(ADC1, DEF_CH_T1, LL_ADC_SAMPLINGTIME_COMMON_1);

？？？还有问题
```



```c
	LL_TIM_InitTypeDef TIM_InitStruct = {0};

	/* Peripheral clock enable */ 给时钟，因为他没链接pin脚，所以不用给pin脚时钟，定时器是内部的一个部件。
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM16);

	/* TIM16 interrupt Init */
	NVIC_SetPriority(TIM16_IRQn, 0);
	NVIC_EnableIRQ(TIM16_IRQn);   使能中断，使能后中断处理函数在哪里呢？stm32xxx_it.h中由对应的函数定义。
    由于中断产生的时候会将定时器的某个regflag置1，所以进入中断处理函数需要先清除此flag，否则一出中断处理函数就又会进入。

	TIM_InitStruct.Prescaler = 15;  预分频
	TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;  向上计数
	TIM_InitStruct.Autoreload = 500;  计数到500停
	TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;  再分频
	TIM_InitStruct.RepetitionCounter = 0;  
	LL_TIM_Init(TIM16, &TIM_InitStruct);
	
	
	stm32f103:内部8m内部高速时钟
	TIM_TimeBaseStructure.TIM_Period=8-1;		 分频后1m									
	TIM_TimeBaseStructure.TIM_Prescaler= freq*1000;		再分频100，则步进1s/100=10ms进一次中断		    
	TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1; 		
	TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up; 
这里初始化里面没有开定时器的中断，可能在外面是开了的。
    定时器的作用：
    1.计算时间--不开中断，不连接pin脚
    	定时器开--干活--定时器关（差值就是时间长度）  注意将reload设置大一些，不然中途自动reload了。
    2.产生中断，开启中断。又对应的中断处理函数--（中断处理函数可以访问全局变量与当前函数的入参）
    3.链接pin脚，产生固定频率的脉冲
	stm32中有多个定时器：
	tim6 tim7是基本定时器，
		只能向上计数--时钟来源PCLK1，
		没有pin脚资源，
		计数16bit
		pclk1来自apb1，时钟最大36M，但是分到定时器上的时候可以倍频成72m，所以这两个定时器时钟最大72m
		apb1上的其他外设最大时钟36m.
	定时器最主要的部分：时基，包括 
		预分频器 PSC  在时钟来源的基础上配置好TIM_XCLK，然后在TIM_XCLK的基础上再去预分频
		计数器 CNT
		自动重装载寄存器ARR   计数器计数到arr的数值就会自动归零，重新增加
	如何实现1s的定时器呢？
	定时器分频算下来1us一格，我们设置arr为50000（因为最大65535，最多只要65ms就进一次中断）
	我们可以在中断函数中定义全局变量var，每次进入中断时var+++，判断var==20的时候再去执行想执行的函数
	相当于每1s执行一次想执行的函数，就实现了1s的定时。
		
	高级定时器：tim1 tim8 
		计数16bit，可以上/下两边计数 tim1和tim8 
		有4个gpio通道 其中几个通道可以输出PWM脉冲
		时钟来自PCLK2 72M 可分频
		时钟源多了几种选择，
		增加输入捕获，输出比较，断路功能
		
	通用定时器：tim2 tim5 tim3 tim4
		比基本定时器功能多，但是没有GPIO通道，不能输出脉冲
		
	
	
	
```



---

#### rtc初始化

```c
	LL_RTC_TimeTypeDef sTime;	//定义stime
	LL_RTC_DateTypeDef sDate;	//定义stime
	LL_RTC_InitTypeDef RTC_InitStruct = {0};
	SET_BIT(PWR->CR1, PWR_CR1_DBP);
	/* Peripheral clock enable */
	LL_RCC_EnableRTC();
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_RTC);
	/* RTC interrupt Init */
	NVIC_SetPriority(RTC_TAMP_IRQn, 2);
	NVIC_EnableIRQ(RTC_TAMP_IRQn);

	RTC_InitStruct.HourFormat = LL_RTC_HOURFORMAT_24HOUR;
	RTC_InitStruct.AsynchPrescaler = 127;
	RTC_InitStruct.SynchPrescaler = 255;
	LL_RTC_Init(RTC, &RTC_InitStruct);
	/** Enable the WakeUp
	*/
	// LL_RTC_WAKEUP_SetClock(RTC, LL_RTC_WAKEUPCLOCK_DIV_16);

	/* USER CODE BEGIN Check_RTC_BKUP */
	if(initFalg==1)
	{
		LL_RTC_DisableWriteProtection(RTC);
	    if (LL_RTC_IsShadowRegBypassEnabled(RTC) == 0U)
	    {
	        LL_RTC_WaitForSynchro(RTC);
	    }
	    
		LL_RTC_EnableWriteProtection(RTC);
	return ;
	}
	//printf("MX_RTC_ RESET!!!\r\n");
	initFalg=1;

	LL_RTC_TIME_StructInit(&sTime);
	LL_RTC_DATE_StructInit(&sDate);

	/* USER CODE END Check_RTC_BKUP */

	/** Initialize RTC and set the Time and Date
	*/
	sTime.Hours = 14;
	sTime.Minutes = 50;
	sTime.Seconds = 0;
	sTime.TimeFormat= 0;
	if (LL_RTC_TIME_Init(RTC,LL_RTC_FORMAT_BIN, &sTime) != SUCCESS)
	{
	
	}
	sDate.WeekDay = 2;
	sDate.Month = LL_RTC_MONTH_JUNE;
	sDate.Day = 1;
	sDate.Year = 21;

	if (LL_RTC_DATE_Init(RTC,LL_RTC_FORMAT_BIN, &sDate) != SUCCESS)
	{
	}
```
rtc
LL_RTC_BKP_GetRegister  读bkp里面的值，bkp有32bit*8个
rtc有3种可屏蔽中断：
闹钟中断：几点几分产生中断
秒中断：1s一次
溢出中断：计数器溢出并转化为0的中断

tamper是后备寄存器，存到里面的数据是不会改变的，rtcinit的函数中只是用它来决定是不是需要初始化时间。因为复位后程序
重新运行，用变量无法决定，需要用bkp里面的数据去决定是不是需要重新初始化时间。

BCD格式，就是16进制入参。我们需要定时23：58：58  则需要传入参 0x23 0x58 0x58
BIN格式，就是10进制入参。我们需要定时23：58：58  则需要传入参 23 58 58





----

```带操作系统的can初始化
CAN1_SendData(u32 CanID,u8 *buff,u8 bytes)
{
	需要发送的数据需要在结构体里面包着
	GT_CAN_CanMsg CanTxMessage;
	标准函数进行发送     哪个can                  CanTxMessage中的帧id						标准帧还是扩展帧										 数据				数据长度
	CAN_MessageTransmit( can_name_2, ( CAN_id_Status )( TxMsgData->IDE ), ( TxMsgData->IDE == GT_CAN_id_ext ) ? TxMsgData->ExtId : TxMsgData->StdId, TxMsgData->Data, TxMsgData->DLC );	
}

void GT_CAN0_ReceiveMsg( GT_CAN_CanMsg* RxMsgData )
{
	U32 CAN_ID;

	CAN_id_Status   ide;
	//标准函数就行can数据接收       帧类型-标准-扩展   数据					数据长度
	CAN_MessageReceive( can_name_1, &ide , &CAN_ID, RxMsgData->Data, &( RxMsgData->DLC ) );

	if( ide == GT_CAN_id_ext )
	{
		RxMsgData->ExtId = CAN_ID;
		RxMsgData->IDE = ( GT_CAN_id_Status )ide;
	}
	else
	{
		RxMsgData->StdId = CAN_ID;
		RxMsgData->IDE = ( GT_CAN_id_Status )ide;
	}
}
void    CAN_INIT( CAN_name name, CAN_bps bps )
{
	switch( name )
	{
		case can_name_1:
			CAN_1_Int();//配置gpio的模式 速度 
			{
					GPIO_InitTypeDef GPIO_InitStructure;
					//使能io口的时钟
					RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA, ENABLE );
					
					GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
					GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
					GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
					GPIO_Init( GPIOA, &GPIO_InitStructure );

					GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
					GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
					GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
					GPIO_Init( GPIOA, &GPIO_InitStructure );
			}
			CAN_SetBps( name, bps);//配置can控制的can结构体
			{
				CAN_InitTypeDef CAN_InitStructure;
				CAN_TypeDef* CANx;
				if( name == can_name_1 )
				{
				CANx = CAN1;
				RCC_APB1PeriphClockCmd( RCC_APB1Periph_CAN1, ENABLE );//使能对应的can控制器时钟，之前的函数里面已经设置过了
				}
				else if( name == can_name_2 )
				{
				CANx = CAN2;
				RCC_APB1PeriphClockCmd( RCC_APB1Periph_CAN2, ENABLE );//使能对应的can控制器时钟，之前的函数里面已经设置过了
				}
				CAN_DeInit( CANx );//库函数缺省初始化can
				switch( bps )//根据bps不同配置不同的CAN_InitStructure
				{
					case bps_500:
						CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;            /*1-4*/
						CAN_InitStructure.CAN_BS1 = CAN_BS1_9tq;            /*1-16*/
						CAN_InitStructure.CAN_BS2 = CAN_BS2_2tq;            /*1-8*/
						CAN_InitStructure.CAN_Prescaler = 6;                /*波特率36/(6*(1+9+2))
																			36m分频/6/12=0.5m，就是500k
				}
				CAN_InitStructure.CAN_TTCM = DISABLE;   /*时间触发(启用时间触发模式时会替换最后两个字节)*/
				CAN_InitStructure.CAN_ABOM = ENABLE;    /*自动离线管理*/
				CAN_InitStructure.CAN_AWUM = ENABLE;    /*自动唤醒*/
				CAN_InitStructure.CAN_NART = DISABLE;   /*ENABLE:错误不自动重传 DISABLE:重传*/
				CAN_InitStructure.CAN_RFLM = DISABLE;   /*DISABLE:在接收溢出时FIFO未被锁定,当接收到FIFO报文未被读出,下一个收到的报文会覆盖原有的报文 ENABLE:在接收溢出时FIFO被锁定,下一个收到的报文会被丢弃*/
				CAN_InitStructure.CAN_TXFP = DISABLE;   /*DISABLE:发送的FIFO优先级由报文的标识符来决定,ENABLE :发送的FIFO优先级由发送报文的顺序来决定*/
				CAN_InitStructure.CAN_Mode = CAN_Mode_Normal; /*正常传输模式 CAN_Mode_Silent_LoopBack:CAN_Mode_LoopBack;*/
				CAN_Init( CANx, &CAN_InitStructure );  初始化can结构体的配置，初始化can控制器
			}
			CAN_SetFilterExt( 0, 0, 0, CAN_FIFO0); /*设置过滤器对应的 CAN_FilterInitStructure，允许接收所有帧*/
			{	入参：u8 number, u16 ID, u16 Mask, u8 FIFO_Type
				CAN_FilterInitTypeDef  CAN_FilterInitStructure;
				/* CAN 过滤器设置 */
				CAN_FilterInitStructure.CAN_FilterNumber = number;
				CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
				CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
				CAN_FilterInitStructure.CAN_FilterIdHigh = ID;
				CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
				CAN_FilterInitStructure.CAN_FilterMaskIdHigh = Mask;
				CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
				CAN_FilterInitStructure.CAN_FilterFIFOAssignment = FIFO_Type;
				CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
				CAN_FilterInit( &CAN_FilterInitStructure );初始化过滤器结构体
			}
			CAN_ITConfig( CAN1, CAN_IT_FMP0, ENABLE );//设置接收fifo的pending中断，就是多会发生can的中断
			{
				#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!< FIFO 0 message pending Interrupt*/
				#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!< FIFO 0 full Interrupt*/
				#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!< FIFO 0 overrun Interrupt*/
				#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/
				#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/
				#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/
			}
			BSP_IntVectSet( BSP_INT_ID_USB_LP_CAN_RX0, STM_Can1_RX_ISR );/*注册irq将优先级与函数对应*/
			BSP_IntEn( BSP_INT_ID_USB_LP_CAN_RX0 );//ucos操作开启这个中断
			break;
	}
}

void STM_Can1_RX_ISR(void)  can对应的中断处理函数
{
	CanRxMsg   RxMessage;
	CAN_Receive( CAN1, CAN_FIFO0, &RxMessage );
	CAN1_ISR_Code( &RxMessage ); /*对收到的can数据怎么处理的代码*/
}
```
不带操作系统的can初始化
void CAN1_Init(void)
{
	有这4个结构体需要初始化。
	GPIO_InitTypeDef GPIO_InitStructure; 
	NVIC_InitTypeDef NVIC_InitStructure;
	CAN_InitTypeDef        CAN_InitStructure;
	CAN_FilterInitTypeDef  CAN_FilterInitStructure;

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	/* 复用功能和GPIOB端口时钟使能*/    
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA, ENABLE);                                                                      

	/* CAN1 控制器时钟使能 */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); 

	/* Configure CAN pin: RX  引脚初始化 */  // PA11
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;       //上拉输入
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	/* Configure CAN pin: TX  引脚初始化*/   // PA12
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;     //复用推挽输出
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	CAN_StructInit(&CAN_InitStructure);     //先缺省初始化CAN_InitStruct结构体

	/* CAN cell init */
	CAN_InitStructure.CAN_TTCM=DISABLE;         //没有使能时间触发模式
	CAN_InitStructure.CAN_ABOM=ENABLE;         //使能自动离线管理
	CAN_InitStructure.CAN_AWUM=ENABLE;         //使能自动唤醒模式
	CAN_InitStructure.CAN_NART=DISABLE;         //没有使能非自动重传模式
	CAN_InitStructure.CAN_RFLM=DISABLE;         //没有使能接收FIFO锁定模式
	CAN_InitStructure.CAN_TXFP=DISABLE;         //没有使能发送FIFO优先级
	CAN_InitStructure.CAN_Mode=CAN_Mode_Normal; //CAN设置为正常模式
	CAN_InitStructure.CAN_SJW=CAN_SJW_1tq;      //重新同步跳跃宽度1个时间单位
	CAN_InitStructure.CAN_BS1=CAN_BS1_2tq;      //时间段1为3个时间单位
	CAN_InitStructure.CAN_BS2=CAN_BS2_3tq;      //时间段2为2个时间单位
	CAN_InitStructure.CAN_Prescaler=12;         
	CAN_Init(CAN1,&CAN_InitStructure);         //利用这个can结构体初始化can控制器

	/* CAN 过滤器设置 */
	CAN_FilterInitStructure.CAN_FilterNumber = 0;
	CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
	CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
	CAN_FilterInitStructure.CAN_FilterIdHigh = 0;
	CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0;
	CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
	CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
	CAN_FilterInit( &CAN_FilterInitStructure );  //初始化can过滤器
    
	/* enabling interrupt */
	NVIC_InitStructure.NVIC_IRQChannel=USB_LP_CAN1_RX0_IRQn;对应can的中断处理函数
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
	CAN_ITConfig(CAN1,CAN_IT_FMP0, ENABLE);  //设置接收fifo的pending中断，就是多会发生can的中断
}

typedef struct{
	int32_t Current;
	uint8_t RateVal;
	uint8_t CMD;
	uint8_t IDVal;
	
	uint8_t BatCnt;
	uint32_t BatUseFlag;
	uint8_t RcvFlag;
	uint8_t RcvNoDataTime;

}CANRCV;CANRCV canrcv;
void USB_LP_CAN1_RX0_IRQHandler()//针对收到的can数据，怎么处理
{
	S_HALFWORD val;
	CanRxMsg RxMessage;

	CAN_Receive(CAN1, CAN_FIFO0, &RxMessage);	收到的can数据存放到RxMessage结构体变量中		       
	if( RxMessage.StdId == 0x100 )//如果收到的标准帧id是100
	{
		val.bytes.byte_h = RxMessage.Data[1];
		val.bytes.byte_l = RxMessage.Data[2];
		canrcv.Current = (int32_t)((val.halfword+(int32_t)CurrentDrift)); 将电流存起来
		canrcv.CMD = RxMessage.Data[3];									  将cmd存起来，充放电指令
		canrcv.RcvFlag = 1;												  将rcvflag置1
		canrcv.RcvNoDataTime= 0;										  将DataFramID=1;全局变量
		DataFramID=1;
		TIM_SetAutoreload(TIM3, ((10+ data.ID* 10)* 100));//:10us		  设置定时器频率
		TIM_Cmd(TIM3, ENABLE);//										使能定时器
		TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);				定时器已开启，则定时器中断中就会发对应的数据，按照定时器的频率		

	}
	else if( RxMessage.StdId == 0x101 )//如果收到的标准帧id是101
	{
		canrcv.BatCnt= RxMessage.Data[0];
		canrcv.BatUseFlag= ((RxMessage.Data[1]<<24)|(RxMessage.Data[2]<<16)|(RxMessage.Data[3]<<8)|(RxMessage.Data[4]<<0));
	}
	else if(( RxMessage.StdId == 0x200 )&&(0x47 ==RxMessage.Data[0]))//修改下位机ID的指令
	{
		if((data.ID  == RxMessage.Data[1])||(0xff  == RxMessage.Data[1]))
		{			
				if((RxMessage.Data[2]<=24)&&(RxMessage.Data[2]>=1)) 
				{
					canrcv.IDVal = RxMessage.Data[2];
					flag.bits.IDChange = 1;						
				}		
		}
		
	}
	if((0x130 == RxMessage.StdId)&&(0x89 == RxMessage.Data[0])&&(0x89 == RxMessage.Data[1])
		&&(0xAB == RxMessage.Data[2])&&(0xAB == RxMessage.Data[3])
	&&(data.ID == RxMessage.Data[4]))
	{
		NVIC_SystemReset();				//收到此指令则复位
	}

	if((0x188 == RxMessage.StdId)&&((data.ID == RxMessage.Data[0])||(0xff == RxMessage.Data[0])))
	{		
		CHG_LED = RxMessage.Data[1];	
		DSG_LED = RxMessage.Data[2];
		WARN_LED = RxMessage.Data[3];
		CHG_SWITH = RxMessage.Data[4];
		DSG_SWITH = RxMessage.Data[5];
	}		
	if((0x189 == RxMessage.StdId)&&(data.ID == RxMessage.Data[0]))
	{		
		if((RxMessage.Data[2]<=125)&&(RxMessage.Data[2]>=85)&&(RxMessage.Data[1]==0x48))
		{
				canrcv.RateVal = RxMessage.Data[2];
				flag.bits.RateChange = 1;	
		}
	}	

}


uint8_t CAN_SendMsg(uint32_t id,uint8_t* buf,uint8_t len)
{ 
    uint8_t mbox;
    uint32_t i=0; 
    CanTxMsg TxMessage;  
	if( id < 0x7ff )
	{
		TxMessage.StdId=id;     
		TxMessage.IDE=CAN_ID_STD;   //使用STD识符
	}
	else
	{
		TxMessage.ExtId=id;     
		TxMessage.IDE=CAN_ID_EXT;   //使用扩展标识符
	}

    TxMessage.RTR=CAN_RTR_DATA;
    TxMessage.DLC=len;            
    for(i=0;i<len;i++)
	{
		TxMessage.Data[i] = buf[i];  结构体中存放要发送的can数据
	}
	i = 0;
    mbox= CAN_Transmit(CAN1, &TxMessage);  //TxMessage里面包含了can的结构与数据
    while((CAN_TransmitStatus(CAN1, mbox)!=CANTXOK)&&(i<0xFFFF))判断can发送状态是否成功
    {
        i++;    
    }
    if(i>=0xFFFF)
        return 0;
    return 1;
}








---

##### iic本身是主机占据主导地位，由主机发起开始或者结束信号的，主机也可以不结束，马上发起起始信号进行对另一个从机的寻址。

在总线的一次传输过程中，数据串数方向在整个过程中不变方向

![image-20210929160051719](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20210929160051719.png)

在传输过程中，当需要改变传递方向时，起始信号与从机地址都被重新发一下，并且改变要读还是要写的那1bit。

![image-20210929161958795](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20210929161958795.png)

## stm32的每个管脚都可以开启中断，但是不可以同时开启A1,B1,C1,D1，因为A1,B1,C1,D1这种序号一样的管脚只有一个管脚可以用来开启，不能同时将这几个管脚开启中断。

```c
IIC作为从机怎么配置使用
#define 每个管脚的时候也需要define出相应管脚的port组。
需要定义的var：
/*---------IIC1---------------*/
uint8_t  Buffer_Rx_IIC1[40];//接收缓存，接收buf
uint8_t  Rx_Idx_IIC1=0;    //接收计数，记下当前读到哪里了
uint8_t  Flag_RcvOK_IIC1 = 0;// 接收完成标志 
uint8_t  Tx_Idx_IIC1=0;    //发送计数，记下当前发到哪里了
u8 Response_Message[40];  //发送缓存，发送buf

RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE); 使能port组时钟与iic外设时钟
RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);

# GPIO配置初始化
GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;//必须设置为开漏输出，实现iic的线与逻辑
GPIO_InitStructure.GPIO_PuPd =  GPIO_PuPd_NOPULL;
//管脚配置中GPIO_InitStructure.GPIO_PuPd必须配置为GPIO_PuPd_NOPULL，若配置为 GPIO_PuPd_UP或GPIO_PuPd_DOWN，IIC总线会一直繁忙，导致总线出错，检测不到IIC从机。

void I2C1_Configuration(void)
{
    I2C_InitTypeDef 定义iicinit结构体;
    NVIC_InitTypeDef 定义nvicinit结构体;

    I2C_DeInit(I2C1);
    .I2C_Mode = I2C_Mode_I2C;
    .I2C_DutyCycle = I2C_DutyCycle_2;
    .I2C_OwnAddress1 = I2C1_Slave_Address; //从机地址，一定要设置正确                          
    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
    I2C_InitStructure.I2C_AcknowledgedAddress= I2C_AcknowledgedAddress_7bit;
    I2C_InitStructure.I2C_ClockSpeed = 100000;
    I2C_Init(I2C1, &I2C_InitStructure);  初始化iic结构体
        
    NVIC_InitStructure.NVIC_IRQChannel    = I2C1_EV_IRQn;//事件中断
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Init(&NVIC_InitStructure);  初始化iic事件中断

    NVIC_InitStructure.NVIC_IRQChannel = I2C1_ER_IRQn;//错误中断
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;                 
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Init(&NVIC_InitStructure);   初始化iic的err中断

    I2C_ITConfig(I2C1, I2C_IT_BUF | I2C_IT_EVT |I2C_IT_ERR, ENABLE);   
    I2C_Cmd(I2C1, ENABLE);                                             
}

从机的中断处理程序：
void I2C1_EV_IRQHandler(void)
{
  SR1Register = I2C1->SR1;
  SR2Register = I2C1->SR2;

    /* I2C1是从机(MSL = 0) */
  if((SR2Register &0x0001) != 0x0001)  //判断当前是从机模式
  {
    /* 主机已发送地址，地址为被置位·(ADDR = 1: EV1(包括发送和接收)) 
       从模式下：地址匹配-0：地址不匹配或没有收到地址；1：收到的地址匹配
       表示有主机要与自己通信*/
    if((SR1Register & 0x0002) == 0x0002)
    {
        /* 清除标志位 */
        SR1Register = 0;
        SR2Register = 0;

        Rx_Idx_IIC1=0;
        Tx_Idx_IIC1=0;
    }

    /* 接收数据(RXNE=1: EV2) rxne接收数据reg，0（数据寄存器为空），1（数据寄存器非空）*/
    if((SR1Register & 0x0040) == 0x0040)
    {
        Buffer_Rx_IIC1[Rx_Idx_IIC1++] = I2C1->DR; 把数据reg中的数据放到接收buf
        SR1Register = 0;
        SR2Register = 0;
    }
    /* 检测到停止条件(STOPF =1: EV4)
    0（没有检测到停止条件），1（检测到停止条件*/
    if(( SR1Register & 0x0010) == 0x0010)
    {
        I2C1->CR1 |= 0x0001;（PE-I2C模块使能，定义：0（禁用I2C模块），1（启用I2C模块：根据SMBus位的设置，相应的I/O口需配置为复用功能）
    注：如果清除该位时通讯正在进行，在当前通讯结束后，I2C模块被禁用并返回空闲状态。由于在通讯结束后发生PE＝0，所有的位被清除。
        在主模式下，通讯结束之前，绝不能清除该位。）
        SR1Register = 0;
        SR2Register = 0;
        Flag_RcvOK_IIC1 = 1;            
    }

    /* 发送数据(TxE = 1: EV3、EV3-1) 
    TxE数据寄存器是否为空(发送时)，定义：0（数据寄存器非空）,1（数据寄存器空）-注意：在发送数据时，数据寄存器为空时该位被置’1’，在发送地址阶段不设置该位*/
    if((SR1Register & 0x0080) == 0x0080)
    {
        I2C1->DR = Response_Message[Tx_Idx_IIC1++]; 把发送buf中的数据拷贝到tx发送reg
        SR1Register = 0;
        SR2Register = 0;
    }
    /* 检测到非应答(AF =1: EV3-2) --0（无起始或停止条件出错），1（起始或停止条件出错）*/
    if(( SR1Register & 0x0400) == 0x0400)
    {
        I2C1->SR1 &= 0xFDFF;
        SR1Register = 0;
        SR2Register = 0;        
    }       
  }

}
上述中断程序中，当主机读取和写入数据时，都会引起地址位被置位，即发生EV1事件（即本中断处理程序中将发送和接收的EV1合并了）；
　　当主机写入数据时，中断的执行顺序是EV1—>EV2—>EV4，其中有多个数据EV2会多次执行；
　　当主机读取数据时，中断的执行顺序是EV1—>EV3—>EV3-2，本中断程序中将EV3和EV3-1合并了，若有多个数据，EV3将多次执行。

    
void I2C1_ER_IRQHandler(void) {

  __IO uint32_t SR1Register =0;
  __IO uint32_t SR2Register =0;
  SR1Register = I2C1->SR1;
  SR2Register = I2C1->SR2;

    if(I2C_GetITStatus(I2C1,I2C_IT_SMBALERT)) {
    }
    else if(I2C_GetITStatus(I2C1, I2C_IT_TIMEOUT)) {
    } 
    else if(I2C_GetITStatus(I2C1, I2C_IT_PECERR)) {
    } 
    else if(I2C_GetITStatus(I2C1, I2C_IT_OVR)) {
    }
    else if(I2C_GetITStatus(I2C1, I2C_IT_AF)) {
        I2C_ClearITPendingBit(I2C1, I2C_IT_AF);
    }
    else if(I2C_GetITStatus(I2C1, I2C_IT_ARLO)) {
    }
    else if(I2C_GetITStatus(I2C1, I2C_IT_BERR)) {
    }
        I2C1->CR1 |= 0x0001;
        SR1Register = 0;
        SR2Register = 0;    
}发送各种错误进行错误中断不做对应的处理，最后只进行清除寄存器（SR1和SR2）操作。
```
野火I2C硬件初始化流程：
I2C_InitTypeDef 定义iicinit结构体，用这个结构体变量去初始化iic控制器

1.初始化iic相关的gpio--pb6,pb7
2.配置iic外设的工作模式
3.编写iic的读写函数，有byte_write page_write  radom_read 函数 

1.初始化iic相关的gpio--pb6,pb7
2.配置iic外设的工作模式
I2C_EEPROM_CONFIG()
{
	//打开i2c的gpio的时钟
	//打开i2c控制器的时钟
	设置gpio结构体中scl的GPIO_MODE=GPIO_Mode_AF_OD;  推挽复用模式
	设置gpio结构体中sda的GPIO_MODE=GPIO_Mode_AF_OD;  推挽复用模式
	
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;  使能或关闭ack，一般都要使能ack
	I2C_InitStructure.I2C_AcknowledgedAddress= I2C_AcknowledgedAddress_7bit;  指定地址长度7或10 bit
	I2C_InitStructure.I2C_ClockSpeed = 100000;  指定速度100k
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;  指定占空比，火哥说好像没啥实际作用，默认随便配一个就行
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;  			还有smbus模式
	I2C_InitStructure.I2C_OwnAddress1 = I2C1_Slave_Address; //从机地址，一定要设置正确                          
	I2C_Init(I2C1,&I2C_InitStructure);  初始化i2c1控制器
	I2C_cmd(I2C1,enable);  使能i2c
}
3.编写iic的读写函数，有byte_write page_write  radom_byte_read radom_bytes_read函数 

void EEPROM_write_byte(uint8_t addr,uint8_t data)往哪里写就得在哪里读
{
	//产生起始信号
	I2C_GenerateSTART(I2C1,ENABLE);
	//检测EV5事件,即I2C_EVENT_MASTER_MODE_SELECT，若start失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)==ERROR);
	
	//发送设备地址,是写操作，所以是I2C_Direction_Transmitter方向
	I2C_Send7bitAddress(I2C1,从机地址，I2C_Direction_Transmitter);
	//检测EV6事件，即 I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED,若发送地址失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)==ERROR);
	
	//发送要写的存储单元地址
	I2C_SendData(I2C1,addr);
	//检测EV8事件，还未完成
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)==ERROR);
	
	//发送要写的数据
	I2C_SendData(I2C1,data);
	//检测EV8_2事件,发送完成
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)==ERROR);
	
	//产生结束信号
	I2C_GenerateSTOP(I2C1,ENABLE);
}

每次写入不能超过8字节
需要注意at24c10类型的EEPROM用的时候如果要8字节，8字节写数据的时候，每次给定的写入地址都应该是8的倍数，否则就会出现问题。

void EEPROM_page_write(uint8_t addr,uint8_t *data，uint8_t num_to_write)
{
	//产生起始信号
	I2C_GenerateSTART(I2C1,ENABLE);
	//检测EV5事件,即I2C_EVENT_MASTER_MODE_SELECT，若start失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)==ERROR);
	
	//发送设备地址,是写操作，所以是I2C_Direction_Transmitter方向
	I2C_Send7bitAddress(I2C1,从机地址，I2C_Direction_Transmitter);
	//检测EV6事件，即 I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED,若发送地址失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)==ERROR);
	
	//发送要写的存储单元地址
	I2C_SendData(I2C1,addr);
	//检测EV8事件，还未完成
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)==ERROR);
	
	while(num_to_write)
	{
		//发送要写的数据
		I2C_SendData(I2C1,*data);
		//检测EV8_2事件,发送完成
		while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)==ERROR);
		data++;
		num_to_write--;
	}
	//产生结束信号
	I2C_GenerateSTOP(I2C1,ENABLE);
}

void radom_bytes_read(uint8_t addr,uint8_t* data,uint8_t num_to_read)从哪个地址读，读到哪里缓冲区，读多少个
{
	//第一次产生起始信号
	I2C_GenerateSTART(I2C1,ENABLE);
	//检测EV5事件,即I2C_EVENT_MASTER_MODE_SELECT，若start失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)==ERROR);
	
	//发送设备地址,是写操作，所以是I2C_Direction_Transmitter方向
	I2C_Send7bitAddress(I2C1,从机地址，I2C_Direction_Transmitter);
	//检测EV6事件，即 I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED,若发送地址失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)==ERROR);
	
	//发送要读取的存储单元地址
	I2C_SendData(I2C1,addr);
	//检测EV8事件，还未完成
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)==ERROR);
	
	//第2次产生起始信号
	I2C_GenerateSTART(I2C1,ENABLE);
	//检测EV5事件,即I2C_EVENT_MASTER_MODE_SELECT，若start失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)==ERROR);
	
	//发送设备地址,是读操作，所以是I2C_Direction_Receiver方向
	I2C_Send7bitAddress(I2C1,从机地址，I2C_Direction_Receiver);
	//检测EV6读事件，即 I2C_EVENT_MASTER_Receiver_MODE_SELECTED,若发送地址失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_Receiver_MODE_SELECTED)==ERROR);
	
	//接收数据 
	while(num_to_read){
		if(num_to_read == 1){  如果是最后一个字节，则主机要给从机说我读完了，不读了，返回nack信号
			I2C_AcknoledgeConfig(I2C1,DISABLE);
		}
		//检测EV7事件，即数据寄存器已经读到有效数据，此时可以去取数据了
		while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)==ERROR);
		*data = I2C_ReceiveData(I2C1);
		data++;  
		num_to_read--;
	}
	
	//产生结束信号
	I2C_GenerateSTOP(I2C1,ENABLE);
	//重新配置ack使能，则主机默认回复的时候回复ack.如果配置成disable，则每次主机收到数据回复nack信号
	I2C_AcknoledgeConfig(I2C1,ENABLE);
}
---

### 几种时钟的区别

```c
rtc定时器是用来计时从1997年开始的时间到现在，这个是个低频的时钟，一般不在系统里面用，只用来显示年月日的。
time定时器：
systick：类似timer，都是有个reload值，向上计数达到此值触发中断然后处理中断。可以通过定义一个全局变量每次出发中断的时候加1，这个数值可以记下来开机到现在的时间长短。timer与systick还有个功能计算任务耗时时长，任务开始时记录全局变量的值，任务结束时记录全局变量的值，相减即可知任务耗时。


RTC模块和时钟配置系统(RCC_BDCR寄存器)是在后备区域，即在系统复位或从待机模式唤醒后RTC的设置和时间维持不变。但是在系统复位后，会自动禁止访问后备寄存器和RTC，以防止对后备区域(BKP)的意外写操作。所以在要设置时间之前， 先要取消备份区域（BKP）写保护。

RTCAlarm_IRQn  设置每个28日的14：50：10时刻就会被alarm唤醒，这样唤醒的时间就成定值了
  sAlarm.AlarmTime.Hours = 14;
  sAlarm.AlarmTime.Minutes = 50;
  sAlarm.AlarmTime.Seconds = 10;	//设置 10s 后产生闹钟中断
  sAlarm.AlarmTime.SubSeconds = 0;
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_NONE;
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
  sAlarm.AlarmDateWeekDay = 28;
  sAlarm.Alarm = RTC_ALARM_A;//用的闹钟A  一般stm32里面有多个闹钟的
HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN)  开启alarm闹钟唤醒。


/* 设置闹钟下次产生的时间，等会在钩子函数中被调用 */
void setalarm(int hours, int minutes, int seconds)
{
    RTC_AlarmTypeDef sAlarm = {0};
    RTC_DateTypeDef sdate = {0};    
    RTC_TimeTypeDef stime = {0};

    //读取当前时间 
    HAL_RTC_GetTime(&hrtc, &stime, RTC_FORMAT_BIN); 
    HAL_RTC_GetDate(&hrtc, &sdate, RTC_FORMAT_BIN);
    //获取设置中断时的时间
    sAlarm.Alarm = RTC_ALARM_A;
    sAlarm.AlarmTime.Hours   = hours   + stime.Hours;//重新设置被唤醒的hours
    sAlarm.AlarmTime.Minutes = minutes + stime.Minutes;//重新设置被唤醒的min
    sAlarm.AlarmTime.Seconds = seconds + stime.Seconds;//重新设置被唤醒的seconds
    if(sAlarm.AlarmTime.Seconds >= 60)//秒数>60则取余，并且min++。
    {
        sAlarm.AlarmTime.Seconds = sAlarm.AlarmTime.Seconds % 60;
        sAlarm.AlarmTime.Minutes += 1;
        if(sAlarm.AlarmTime.Minutes >= 60)//分钟>60则取余，并且hour++。
        {
            sAlarm.AlarmTime.Minutes = sAlarm.AlarmTime.Minutes % 60;
            sAlarm.AlarmTime.Hours += 1;
            if(sAlarm.AlarmTime.Hours >= 24)//hour>24则取余，并且date++
            {
                sAlarm.AlarmTime.Hours = sAlarm.AlarmTime.Hours % 24;
                sdate.Date += 1;
            }
        }
    }
    sAlarm.AlarmTime.SubSeconds = 0;
    sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
    sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
    sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
    sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_NONE;
    sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
    sAlarm.AlarmDateWeekDay = sdate.Date;   //跨天数定时,需要注意


    if(HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN) != HAL_OK)//重新初始化alarm的定时唤醒时间，
	就在hours小时后， minutes分钟后 seconds秒后
    {
        Error_Handler();
    }
}

/**
  * @brief  Alarm callback 闹钟中断回调函数
  * @param  hrtc : RTC handle
  * @retval None
  */
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{
    static uint16_t sEnterCnt = 0;
    
    setalarm(0,0,5);	//设置当前时候的 5s 后再次产生闹钟中断
    printf("Alarm A Interrupt Cnt:%d \r\n",sEnterCnt++);
}

    
```

---

### 联合体与结构体大小

```c
union长度怎么计算
    struct的大小计算根据成员的对齐，大小肯定是对齐字节的整数倍。
    union的长度取决于其中的长度最大的那个成员变量的长度。即union中成员变量是重叠摆放的，其开始地址相同。union(共用体)的各个成员是以同一个地址开始存放的,每一个时刻只可以存储一个成员
   union   mm{   
  char   a;//元长度1   
  int   b[5];//元长度4   
  double   c;//元长度8   
  int   d[3]; //元长度4
  };   
本来mm的空间应该是sizeof(int)*5=20;但是如果只是20个单元的话,那可以存几个double型(8位)呢?两个半?当然不可以,所以mm的空间延伸为既要大于20,又要满足其他成员所需空间的整数倍,,因为含有double元长度8，故大小为24。
```

----

#### 很多电池组成的pack再去组，就是电池簇。

----

### 不同型号电池特性

```py
18650
	2.7--3.7--4.2   目前松下可达到3000mAh
	笔记本用的18650电芯通常2200mAh,普通18650 2.+AH
磷酸铁锂
	（2-2.5）--3.2--3.65
	有些自己生产的电芯，电芯容量可以做到13Ah，是普通18650的5-6倍的容量。
	电池充放电的单位：
	1C=1A*s 
	1Ah=3600C 1mAh=3.6C
```

	
-------------FreeRTOS：
keil的配置output文件夹下的晶振配置需不需要配置呢？
start.c文件中SYSTEM_CLOCK就是时钟，配置的晶振时钟需要与它一致。

	
在main.c文件最上面需要定义每个任务的栈大小：
StackType_t Task1Stack[20];
StackType_t Task2Stack[20];
StackType_t Task3Stack[20];
...
StackType_t TasknStack[20];

定义任务入口：
void Task1(){任务1代码}
void Task2(){任务2代码} 

任务控制块：
{
	栈顶；
	任务节点；
	任务栈起始地址
	任务名称
}

静态任务创建函数：
TaskHandle_t xTaskCreateStatic(TaskFunction_t pxtaskcode,//任务入口
								char * pcName, // 任务名称，字符串
								uint32_t ulStackDepth,//任务栈大小
								void * const params,//任务形参
								StackType_t * const StackBuffer,//任务栈起始地址
								TCB_t * const pxTasjBuffer;//任务控制块指针
								)
怎么移植：
FreeRTOSConfig.h中定义的configTICK_RATE_HZ  决定了系统多久进行一次任务时间片的分配
	
	
	
	
单任务静态内存调用流程：----需要指定栈空间
main()
{
	bsp_init();//初始化其他外设
	AppTaskCreate_Handle = xTaskCreateStatic(
							(TaskFunction_t)renwufun,
							(const char*)"renwuname"，
							128,堆栈大小
							NULL，给任务函数传参
							(*StackType_t *) StackBuffer,任务堆栈
							(statictask_t *)&renwufun_TCB,任务控制块句柄
							);
	if(AppTaskCreate_Handle != NULL)
	{
		//任务创建成功
		vTaskStartScheduler();//启动任务，开启调度
	}else
	{
		//任务创建失败
	}
}

在renwufun中我们可以继续创建任务
renwufun()
{
	LED_Handle = xTaskCreateStatic(
							(TaskFunction_t)renwuLED,
							(const char*)"LEDname"，
							128,堆栈大小
							NULL，给任务函数传参
							(*StackType_t *) LEDStackBuffer,任务堆栈
							(statictask_t *)&LEDrenwufun_TCB,任务控制块句柄
							);
	if(LED_Handle != NULL)//返回值AppTaskCreate_Handle是任务句柄
	{
		//任务创建成功
		vTaskStartScheduler();//启动任务，开启调度
	}else
	{
		//任务创建失败
	}
}
-----------
单任务动态内存调用流程：------不需要指定栈空间
main()
{
	BaseType ret = pdPass;
	bsp_init();//初始化其他外设
	ret = xTaskCreate (
							(TaskFunction_t)renwufun,
							(const char*)"renwuname"，
							128,堆栈大小
							NULL，给任务函数传参
							(*StackType_t *) StackBuffer,任务堆栈
							(statictask_t *)&renwufun_TCB,任务控制块句柄
							);
	if(ret == pdPass)//返回值AppTaskCreate_Handle是任务句柄
	{
		//任务创建成功
		vTaskStartScheduler();//启动开启调度任务，这个是个空闲任务，优先级是0（最低的优先级）
	}else
	{
		//任务创建失败
	}
}
renwufun函数里面可以定义多个任务。
{
	taskENTER_CRITIVAL();//进入临界区，此时不会被打断？别的进程肯定不会打扰
	xTaskCreate（renwu 1）;
	xTaskCreate（renwu 12）;
	xTaskCreate（renwu n）;
	taskEXIT_CRITIVAL();//退出临界区
}


---------------方法1：main函数初始化硬件与os，最后开始调度--伪代码实现
int main()
{
	//硬件初始化
	hardware_init();
	//rtos初始化，内存，堆，全局var
	rtos_init();
	//创建任务1，但不执行，因为没开启调度
	rtos_taskcreate(task1);
	//创建任务2，但不执行，因为没开启调度
	rtos_taskcreate(task2);
	//启动rtos，开启调度任务，真正开始任务调度
	rtos_start();
}

void task1()
{
	while(1){}
}
---------------方法2用的多：main函数初始化硬件与os，创建一个任务直接启动调度器，在启动任务中创建各种任务
当所有任务创建成功后将自己删除。

int main()
{
	//硬件初始化
	hardware_init();
	//rtos初始化，内存，堆，全局var
	rtos_init();
	//创建主任务
	rtos_taskcreate(apptack);
	//启动rtos，开启调度
	rtos_start();
	
}
void apptack()
{
	rtos_taskcreate(task1);
	rtos_taskcreate(task2);
	...
	rtos_taskdelete(apptack);//所有任务都创建好，删除主任务
}

void task1()
{
	while(1){}
}

--------------任务状态：
就绪态：任务一旦被创建就会进入就绪态
运行态：具有最高优先级的就绪态任务才会抢占CPU进入运行态，运行态的任务被更高优先级任务打断就会
重新进入就绪态等待CPU调度
阻塞态：sleep，等信号量（资源）的时候就会进入阻塞态，
挂起suspend：让一个任务进入挂起态唯一方法就是调用vTaskSuspend(),把挂起任务恢复的唯一办法就是
调用vTaskResume()或者vTaskResumeFromISR()

任务状态切换：
1.就绪态中具有最高优先级的任务就会进入运行态
2.运行态任务被更高优先级任务打断的时候原任务就会重新变成就绪态
3.运行态的任务调用sleep或者等待某个资源，资源不可达时就会进入阻塞态
4.阻塞态任务获得资源时会进入就绪态，可以等待CPU的调度，不会直接变成运行态
5.阻塞态，就绪态，运行态的任务调用函数vTaskSuspend()就会进入挂起状态，挂起的任务恢复的唯一途径就是
调用vTaskResume()或者vTaskResumeFromISR()恢复，恢复之后不会直接进入运行态，而是进入就绪态，等待CPU调度



typedef struct tskTaskControlBlock
{
	pxtopstack;  栈顶指针
	pxstack;   栈首地址指针
	uxpriority;  任务优先级
	taskname[x];  任务名称 
	statelist;	  状态列表
	eventlist;    事件列表
}


调度机制：
1高优先级任务优先执行，可以抢占低优先级任务
2高优先级任务不停止，低优先级任务永远无法执行
(除非在高优先级的任务中主动调用vTaskDelay())，调用后低优先级任务就可以占上CPU了。
3同等优先级任务，轮流执行：时间片轮转

怎么管理任务：
1.找到最高优先级的运行态或就绪态任务，运行它
2.如果大家平级，轮流执行 

谁去调度的？
TICK定时器，在tick中断中去调度。


rtos里面有3类链表：
1.readylist
	{
		根据优先级不同有n个链表
		readylist[0]：优先级为0的任务链表，里面可能有优先级为0的x个任务
		readylist[1]：优先级为1的任务链表，里面可能有优先级为1的x个任务
		readylist[2]：优先级为2的任务链表，里面可能有优先级为2的x个任务
		readylist[3]：优先级为3的任务链表，里面可能有优先级为3的x个任务
		readylist[4]：优先级为4的任务链表，里面可能有优先级为4的x个任务
	}
2.delaylist阻塞链表
	优先级不同也是只有一个链表
3.suspendlist挂起链表
	优先级不同也是只有一个链表
tick中断根据优先级查找可以执行的高优先级任务；程序执行的过程中任务也可能会跳到其他类型的链表中（例如阻塞，sleep）
任务移动到其他链表中后，下次再调度的时候就会变化的 

xQueueCalcHandle = xQueueCreate(); 创建队列，用于任务间数据通信的，生产者消费者




-----------------------------------MDK编译流程
每个.o文件包含=代码段+数据段（变量）
armlink会将所有的.o文件链接起来成axf文件，formelf工具可以将axf文件更改格式输出为bin文件或者hex文件。
keil安装目录中的ARMCC目录中有好多编译软件，以后我们可以自己根据编译的axf文件自己去输出bin/hex文件。
编译后的linking之后有几个段
code+rodata+rwdata+zidata
Code是代码占用的空间;
RO-data是 Read Only 只读常量的大小，如const型，存储在rom(或者说内部flash)中;  自己增加了const char *varchar="1111111111 1111111111";并不会增加RO-DATA大小，why？？？得在main中用到此变量，不然直接编译不会增加。

RW-data是（Read Write） 初始化了的可读写变量的大小;普通可更改全局var。
ZI-data是（Zero Initialize）  没有初始化的可读写变量的大小。直接定义为0的都会算到这个里面。

ZI（zero init）-data不会被算做代码里因为不会被初始化;其实与rwdata性质一样，都可以更改，只不过它的初始化为0而已
自己实验的时候确实是初始化过的也会算到ZI-data里面呀？？？why。必须是直接初始化时直接定义不为0，才会算到RW-data部分，在main里面再去初始化的不会算到编译的RW-DATA里面。

简单的说就是在烧写的时候是FLASH中的被占用的空间为：Code + RO Data + RW Data（rwdata是非0数据，需要存起来）
														zidata是0，不需要存
程序运行的时候，芯片内部RAM使用的空间为： RW Data + ZI Data
程序运行的时候，只读区域：code+rodata 

crf文件--->类似ctags文件，跳转使用
机器代码 					 code 
常量 						rodata 
初始非0全局var   			rwdata 
初始化0全局var 				zidata 
局部var 					zidata 
使用malloc动态分配的空间	zidata

在keil中选择芯片型号的时候：设置里面可以看到rom的size会自动设置好0x8000=512k，ram的size也是，不同的cpu，rom大小不同。ram不同

--------------编译工具链
添加环境变量：控制面板--系统--高级系统设置--高级--环境变量--给path继续赋值 bin所在的目录即可
keil设置里面的output选项表里面有编译的配置，即armcc的编译选项参数

elf：可执行 link 文件file

rtc
LL_RTC_BKP_GetRegister  读bkp里面的值，bkp有32bit*8个
LL_RTC_BKP_SetRegister

tamper是后备寄存器，存到里面的数据是不会改变的，rtcinit的函数中只是用它来决定是不是需要初始化时间。因为复位后程序
重新运行，用变量无法决定，需要用bkp里面的数据去决定是不是需要重新初始化时间。

BCD格式，就是16进制入参。我们需要定时23：58：58  则需要传入参 0x23 0x58 0x58
BIN格式，就是10进制入参。我们需要定时23：58：58  则需要传入参 23 58 58

fromelf --text -v xxx.o > 1.txt  将xxx.o里面的内容显示出来重定位到1.txt中。
fromelf --text -v xxx.axf > 1.txt.o文件都没有指定地址，.axf文件中会将所有的地址与大小都分配好

elf文件分为3中类型：
1.可重定位文件：
包含基础代码(code)与数据(数据段)，但是都没有指定绝对地址，这种文件只用来与其他可重定位文件link
组成可执行文件。例如所有的.o文件。
2.可执行文件，例如可执行的bin/hex，或者linux中总目标文件。
3.共享文件--库文件，可以重定位，因为可以被新插入别的程序中。例如：mdk生成的lib文件，linux中的so文件

shift+右键：打开powershell cmd窗口   win+x：直接打开管理员权限的powershell窗口

fromelf --text -v .\usart.o 查看此.o文件中的
** Section #359

    Name        : .strtab
    Type        : SHT_STRTAB (0x00000003)
    Flags       : None (0x00000000)
    Addr        : 0x00000000
    File Offset : 539325 (0x83abd)
    Size        : 15025 bytes (0x3ab1)
    Link        : SHN_UNDEF
    Info        : 0
    Alignment   : 1
    Entry Size  : 0

MMU--将物理地址重新映射成另一个虚拟地址
单片机 stm32中没有MMU单元，所以物理地址与虚拟地址是一样的。

存在flash中的rodata与rwdata数据是多会copy到内存中的呢？
可以在总的axf中看到：__scatterload分散加载的时候可以看到，通过ldm命令将flash中的数据加载到内存
hex文件格式：
:10 0000 00 C0080020D500000899250008C5190008 7F
:ll aaaa tt [data]                           cc
:  表示每条记录的开头
ll/10 表示主体数据区域的长度-byte--这里刚好16byte--C0080020D500000899250008C5190008
tt/00 表示数据类型：00是普通数据  04表示后面的地址按照这个地址递增。--ps:
:02 0000 04 0800 F2  我们板子里面很多都是从0x0800 0000(前面还有4个0)地址开始的--内部flash地址
cc/7f：校验
这个hex文件表示我们要将这些数据存到0800 0000所在的地址上去。 真正存的数据只有hex文件每行中的data区域。

bin文件大小就是code+ro大小，编译出来的时候就可以看到code+ro段的大小就是bin的大小。
bin文件就是很纯粹的code+ro数据，将来直接往flahs写的数据

其实bin文件就是hex文件中除了:，ll ，aaaa， tt，cc以外的其它的数据就是bin数据。 

程序刚开始是vector中断向量表，包含：
表里面最开始的是init_sp 初始化 
然后是reset_handler  复位处理
中断向量表中还包含几个错误处理中断，NMI_HANDLER HARDFAULT_handler busfault_handler 
reset_handler:
跳到main
执行system_init函数，就是初始化时钟。

map文件
双击工程文件夹即可看到map文件
勾选配置里面的：C/C++中的：one elf section per function选项就会大大减小代码体积。
此文件中包含了每个.o文件对所有的其他文件中的函数的引用关系。
虽然我们吧stm32的所有库都加入到了工程中，但是不用担心会增加总目标文件的体积，因为主main没调用。

睡眠模式可以任意中断唤醒----直接__WFI()就可以进睡眠模式---唤醒后代码是连续的。

需要配置LPMSbit的就是我们普通休眠的配置--stop1模式。enter_stopmod--唤醒后代码是连续的。
但是时钟坏了，需要重新使能HSE时钟，使能PLL，选择PLL为系统时钟源
RCC_HSECONFIG(ENABLE);	等待使能成功
RCC_PLLCMD(ENABLE); 等待使能成功
RCC_SYSCLKCONFIG(RCC_SYSCLKSOURCE_PLLCLK);选择时钟源
默认被唤醒的时后系统时钟选择的是HSI时钟，我们需要自己重新配置外部高速时钟，因为原来正常运行的板子就是外部高速
时钟源的。

待机模式：进入待机模式前必须开启PWR时钟RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR,enable);停止模式与睡眠模式
则不许要这个操作。
enterstandbymode();唤醒之后程序会复位


----------------------各种时钟的使能
LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_SYSCFG);//SYSCFG clock enable--apb2挂了很多外设
LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_PWR);//Power interface clock enable
apb1是低速总线
apb2是高速总线
LL_RCC_HSI_Enable();使能HSI时钟，内部高速
LL_RCC_LSI_Enable();使能lsi时钟，内部低速


LL_PWR_EnableBkUpAccess();启用对RTC和备份寄存器的访问，Enable access to the backup domain
LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);   ahb总线预分频时钟，这里就是不分频
LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_HSI);  设置总的时钟的时钟源。
LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);  设置apb1的预分频
LL_Init1msTick(16000000);  初始化systick的时钟
LL_SetSystemCoreClock(16000000);  设置主时钟源频率sets directly SystemCoreClock CMSIS variable.即使这里更改了，systick的频率仍然是1ms

LL_RCC_SetRTCClockSource(LL_RCC_RTC_CLKSOURCE_LSI);  	设置rtc时钟源，HSE/128,LSE,LSI三种时钟源
LL_RCC_SetADCClockSource(LL_RCC_ADC_CLKSOURCE_SYSCLK);	设置adc时钟源为sysclk，也可以设置成PLL，hsi

可以在uart内部去设置uart的时钟  
set_clksource(PCLK);设置时钟源为PCLK
LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART2);  使能uart时钟
LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);		使能对应的port的时钟


LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);		gpio.c中使能所有的port的时钟
LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOB);
LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOC);
LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOD);



#define PREDisRead  (((GPIOB->ODR&GPIO_PIN_x) == (GPIO_PIN_x)) ? 1UL : 0UL)   这里不能直接改GPIO_PIN_x为0/1，原因：
正确的是：GPIOB->ODR&0x0010 == 0x0010 说明此时GPIOB->ODR的第2bit是高电平。
改成0/1之后成了：GPIOB->ODR&0x0010 表示的是GPIOB->ODR的第2bit可能是0x0000或0x0010都不是1/0可以表示的。


800 0000 ---800 8000  32k的flash范围
800 0000 ---801 0000  64k的flash范围

我们的bootloader的范围与bin文件的范围：  32k的程序
800 0000---800 1300  boot范围    5k
800 18f8---800 7800	 bin文件范围  26k  左右
800 7800---800 8000	 最后还有一页用来存flash数据，所以程序的大小不能超过800 7800

我们的bootloader的范围与bin文件的范围：  64k的程序
800 0000---800 1300  boot范围    5k
800 18f8---800 F800	 bin文件范围  58k  左右
800 F800---801 0000	 最后还有一页用来存flash数据，所以程序的大小不能超过800 f800


vector向量表里面包含各种触发中断之后要跳过去的函数名字：
__initial_sp          我们程序每次复位之前都会执行初始化SP指针，栈
Reset_Handler         复位
NMI_Handler       		    
HardFault_Handler                         
SVC_Handler                              
PendSV_Handler        
SysTick_Handler       
WWDG_IRQHandler                          
RTC_TAMP_IRQHandler   
FLASH_IRQHandler      
RCC_IRQHandler        
EXTI0_1_IRQHandler    
EXTI2_3_IRQHandler    
EXTI4_15_IRQHandler   
TIM16_IRQHandler  
TIM17_IRQHandler  
I2C1_IRQHandler   
I2C2_IRQHandler   
SPI1_IRQHandler   
SPI2_IRQHandler   
USART1_IRQHandler 
USART2_IRQHandler 

Reset_Handler    PROC
                 EXPORT  Reset_Handler                 [WEAK]，我们下面其实是在重写之前别的文件定义的resethandler
        IMPORT  __main  	IMPORT定义表示这是一个外部变量的标号，不是在本程序定义的
        IMPORT  SystemInit		EXPORT ，表示本程序里面用到的变量提供给其他模块调用的。
        LDR     R0, =__initial_sp    ;PC指针刚开始只初始化栈  
        MSR     MSP, R0  	；；EXPORT  __initial_sp，这个初始化栈的底层也不是在这里初始化的，__initial_sp是别的文件里定义的

;;Check if boot space corresponds to test memory    测试
        LDR R0,=0x00000004
        LDR R1, [R0]
        LSRS R1, R1, #24
        LDR R2,=0x1F
        CMP R1, R2
        BNE ApplicationStart  
;; SYSCFG clock enable      RCC寄存器的
        LDR R0,=0x40021018   4002 1000 RCC寄存器里面的LSIRDYIE: LSI ready interrupt enable  启用由LSI引起的中断
        LDR R1,=0x00000001
        STR R1, [R0]
;; Set CFGR1 register with flash memory remap at address 0
        LDR R0,=0x40010000   就是SYSCFG寄存器的SYSCFG_CFGR1，在APB总线上
        LDR R1,=0x00000000   初始化成0
        STR R1, [R0]
		void HAL_SYSCFG_EnableRemap(uint32_t PinRemap)
		{
		  SET_BIT(SYSCFG->CFGR1, PinRemap);    在APB总线上设置CFGR1
		}
ApplicationStart        
	 LDR     R0, =SystemInit  重定位中断向量表
		void SystemInit(void)  在g00x.c中
		{
		  /* Configure the Vector Table location add offset address ------------------*/
		#ifdef VECT_TAB_SRAM
		  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
		#else
		  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* 把中断向量表放到800 1900位置 */
		#endif
		}
	 BLX     R0
	 LDR     R0, =__main跳到c文件种的main
	 BX      R0
	 ENDP




我们平时配置的reg地址范围是多少呢？
查看：Memory organization章节
外设都在AHP  APB 总线地址上挂着
io都在IOPORT 总线上挂着

系统时钟的设置一般在SystemInit（SetSysClock）或者SystemClock_Config中
里面配置了此程序选择的哪个时钟源，分频，各个总线分频等参数。

int buf[x];
buf[i] = 732/10;    则buf[i]实际等于73，会将小数点后面约掉。

keil缩小代码体积的方法：
-O0
最少的优化，可以最大程度上配合产生代码调试信息，可以在任何代码行打断点，特别是死代码处。

-O1
有限的优化，去除无用的inline和无用的static函数、死代码消除等，在影响到调试信息的地方均不进行优化。在适当的代码体积和充分的调试之间平衡，代码编写阶段最常用的优化等级。

-O2
高度优化，调试信息不友好，有可能会修改代码和函数调用执行流程，自动对函数进行内联等。

-O3
最大程度优化，产生极少量的调试信息。会进行更多代码优化，例如循环展开，更激进的函数内联等。所以说不能调试喽

1.1少做乘除运算，使用左/右移位来实现乘除
1.2在不影响运算条件下，使用短类型代替长类型  char---int----float
1.3尽量使用无符号类型数据  				unsigned类型
1.4回避使用浮点类型数据做乘除运算，这样代码量很大
1.5同一类操作多次重复书写，将它们定义一个子函数，每次使用时调用
1.6定义的变量初始化成0，不要初始化成非0值，不然占rwdata空间
1.7使用自减优于自加，比如在做延时的时候for(a=70;a>0;a--) 更好
1.8尽量 不要用自己重新封装的数据类型，例如union，虽然写代码方便，但是占位置，若写成uint16再用位移操作更高效
=======
buf[1] = syspara.chgMos<<7 |syspara.dsgMos<<6 | sysflag.bits.DET_Flag<<3|((~userAlarm.bits.O_V)&0x01);
这里不能直接|~userAlarm.bits.O_V;不然相当于|0xff因为0取反就是0xff，会将所有的bit弄成1.应该只改最后1bit

脚踏板车蹬踏板的时候就会有充电电流，此时并没有充电机链接。
充电mos闭合的时候chgdet是采集不到的，只有chgmos断开的时候读到的chgdet才是有效的。
以后的板子没有chgdet怎么判断充电机链接呢？直接给syspara.batstat?不可以，我们蹬脚踏板或者踩刹车都会触发充电电流
刹车回馈

--------------soc积分策略
1.当前的soc积分策略，上电时根据静态曲线获取一个soc，之后直接安时积分去更新soc，更新的时候会有个加速参数/减速参数
-----为啥要有呢？
其实我们也可以直接根据充电曲线，放电曲线去更新soc，但是那样太不准确了---非常不建议这种策略。
这样综合起来用  积分+加速/减速  参数确定的soc还比较准--所以暂时就是这种策略。
2.充电的时候，确定充电曲线，基准电压，温度曲线，然后确定充电曲线算出来的soc
	if((syspara.SOC>80) &&((abs((int)(syspara.SOC-socv)))>5))//soc>80 && 波动超过5%
	{
		if(100>socv)//根据充电曲线获取的soc在100以内，加速系数会比1000大一点点
		{
			*factor = (uint32_t)(100-syspara.SOC)*1000/(100-socv);
		}
		else
		{
			*factor = 2000;//实际soc>80后，曲线soc也超过实际soc，说明快充满了，加速系数直接翻倍
		}
		if(*factor>1200)
		{
			*factor= 1200;
		}
		else if(*factor<500)
		{
			*factor= 500;//曲线soc<100，那就继续慢慢充，尽量多充一会
		}
	}
	else if((abs((int)(syspara.SOC-socv)))<=1)//如果soc与实际soc差值不大，则校准参数就1000就行
	{
		*factor= 1000;
		 ret = Cal_OK;
	}	
	else if((syspara.SOC<socv)&&(syspara.IntegralPower_C<1000))//充电系数
	{
		*factor = 1000;
		ret = Cal_OK;
	}
	else if((syspara.SOC>socv)&&(syspara.IntegralPower_C>1000))
	{
		*factor = 1000;
		ret = Cal_OK;
	}
3.放电的时候，确定充电曲线，基准电压，温度曲线，然后确定放电曲线算出来的soc
	if(((syspara.SOC>0)&&(syspara.SOC<=CFG_StartSOC))||((socv<=CFG_StartSOC)&&(syspara.tempAvg>60)))
	{
		DSGCaliFlaG= 1;
		if(abs((int)(syspara.SOC-socv))>5)
		{
			if(0 != socv)
			{
				if(socv>0)
				{
					*factor =  (uint16_t)((uint32_t)syspara.SOC*1050L/socv);
				}
			}
			else
			{
				*factor= 2000;
			}
		}
		else if(abs((int)(syspara.SOC-socv))<=1)
		{
			*factor = 1050;
		}
		else if((syspara.SOC<socv)&&(syspara.IntegralPower>1050))
		{
			*factor = 1050;
		}
		if(*factor > 2000)
		{
			*factor= 2000;
		}
		else	if((*factor<1000)&&(syspara.tempAvg>60))
		{
			*factor= 1000;
		}
		else if(*factor < 500)
		{
			*factor= 500;
		}
	}
	else
	{
		DSGCaliFlaG= 0;
	}
	if(DSGCaliFlaG==0)
	{
		ret = Cal_Temp;//还需要继续校准系数  用GetFactor_Cali_DSGTempCoeff
	}
can通讯相比于485最大的特点就是同一个总线上面有仲裁机制，可以保障总线上同一时刻只有一个人在发数据
不让总线冲突。所有板子的代码都是一样的，如果同时发数据，则can就会给这些下位机排序，来让下位机一个一个发数据
485总线上如果同时多个人发数据，则数据就会乱，有很大的问题。


crc校验实际校验的是每包数据校验后的数值传进去再校验，最终就是校验的整个bin文件的校验。
就是将bIN中的每个字节做同样的操作，^ <<等。
看这是每次校验的512字节，其实我们可以用本次校验出来的结果与之后的bin继续校验，最终的结果就是所有bin的crc校验结果。

写程序的时候直接把相关的打印日志用宏给调试出来，然后调试完之后直接将宏给关闭即可-------很方便

刷bin的时候并不会修改flash里面的数据才行----最后一页并不会被覆盖的
白盒子刷程序的时候可以在软件界面设置：采用哪种方式擦除芯片内容，我们一般就会将原来flash中的数据全部擦除。

中颖参数：
EUVR=0:过放电保护状态释放与负载释放无关   过放电-电压过低的恢复与负载释放无关
策略里面只要求放电过流的时候要断开负载，所以这个写0就可以

OCRA=0:不允许电流保护定时恢复，就是电流保护恢复必须断负载或充电机
当寄存器SCONF2中OCRA=1时，此时电流保护恢复条件为下述任意之一：
(1) 放电过流保护发生后，负载释放且延时超过负载释放延时tD1
(2) 充电过流保护发生后，充电器断开且延时超过tD2
(3)
中颖中充电过流只会关闭充电mos，放电过流只会关闭放电mos，不会全部关闭的。


时间矩阵：
给各个下位机编号ID：
下位机发数据的时候按照ID*500MS来往总线上发消息，则数据就不会冲突
为什么485总线上可以挂很多东西但是uart上不能呢？
因为uart只有1个rx 1个tx，如果接了2个东西，如果2个下位机同时发数据，则rx上就乱了
但是485是总线。

主机：会主动发送请求数据的机器就是主机，从机只会被动的回数据，不会主动发起数据请求


keil字体：Lucida Console  加粗，很好用

cpu的供电管脚是vdd供电程序可运行，vbat是后备寄存器供电，保障bkg的数据不会消失，但是此时程序已经不会运行了--因为没有vdd 

在Keil C51 v8.05的汉化版本里面有字体偏移的问题，在代码编辑器里面选择代码时发生错位偏移，让人感觉很不舒服。解决方法很简单，用记事本打开“TOOLS.INI”文件，在里面添加一行“ANSI=1”，问题就解决了。


三元电池特性:
电量集中在平台3600左右

铁锂电芯:
电量在3200集中的容量最多,然后是3400左右也集中的很多容量

中颖里面也有对于电池当前状态的判断,中颖中的状态判断的电流门限可能比较高
我们用的电池状态的判断策略更准确一些

为什么开premos需要一个标志位呢?
保利新16s的代码里面:进入休眠判断说明没有中颖的报警,但是有可能有静态2700的报警呀
有静态2700报警则不能闭合预充mos,但是并不会影响进入休眠.

#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
设置NVIC绝对地址后，再重新定义操作这个位置各个reg的结构体变量，则可以通过指针的方法去操作reg


swd下载：可以用j-link  st-link ，SWD只需要两根线，分别为：SWCLK和SWDIO
isp下载：uart烧录，用的是串口。需要选择BOOT的模式，现在通过CH340G芯片可以实现自动ISP的下载方式，即不需要手动设置BOOT模式

1.为什么设置中断线17:rtc的alarm唤醒---
STM32F10x有20条中断线，其中16条用于IO口中断使用，还有4条用于内部中断事件。EXTI17就是用于内部RTC闹钟唤醒中断事件时使用，所以初始化中除了打开RTC闹钟中断同时打开了EXTI17中断线。
2.为什么RTC闹钟中断服务程序清除EXTI17中断标志位？
因为中断线17接到了RTC闹钟上，RTC闹钟中断后会触发中断线17产生中断事件，所以在RTC中断内清除标志位，这同时是RTC闹钟唤醒停止模式的原因。具体看下图手册描述
如果在EXTI控制器中设置的EXTI线17的中断模式，则会产生RTC闹钟中断。
如果在EXTI控制器中设置的EXTI线17的时间模式，则会产生脉冲，不会产生RTC闹钟中断

RTC_ITConfig(RTC_IT_ALRA|rtc_it_sec, enable);//开启rtc秒中断与闹钟中断





rtc配置：
RTC一次设定值后一秒递增一个单位，每过40秒就触发一个闹钟并进入中断，每经过一秒就将秒数输出到计算机上。下面就是RTC的初始化配置。（第一个程序从正点原子的程序上修改得来）
u8 RTC_Init()
{
	u8 temp = 0;
	NVIC_InitTypeDef NVIC_InitStructure;
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_BKP|RCC_APB1Periph_PWR,ENABLE);//电源时钟和背部时钟
	PWR_BackupAccessCmd(ENABLE);                    //允许背部区域写
	
	if (BKP_ReadBackupRegister(BKP_DR1) != 0xC0B4)		
		{	 			
 
		BKP_DeInit();	
		RCC_LSEConfig(RCC_LSE_ON);	
		while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)	
			{
			    temp++;
			    delay_ms(10);
			}
		if(temp>=250)return 1;   
		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);		   
		RCC_RTCCLKCmd(ENABLE);	 
		RTC_WaitForLastTask();	
		RTC_WaitForSynchro();		
		RTC_ITConfig(RTC_IT_SEC|RTC_IT_ALR, ENABLE);	//打开RTC的秒中断和闹钟中断	
		RTC_WaitForLastTask();	
		RTC_EnterConfigMode();                        //进入配置RTC模式
		RTC_SetPrescaler(32767); 
		
		RTC_SetCounter(0);                            //初始值设定为0s
	    RTC_WaitForLastTask();
		RTC_SetAlarm(40);	                           //闹钟值设定为40s
		RTC_WaitForLastTask();                        //等待上述配置完成
		RTC_ExitConfigMode();                          //退出配置模式
		BKP_WriteBackupRegister(BKP_DR1, 0XC0B4);
		PWR_BackupAccessCmd(DISABLE);                //不允许背部区域写操作
		}
	else
	{
		PWR_BackupAccessCmd(DISABLE);
		RTC_WaitForSynchro();
		RTC_ITConfig(RTC_IT_SEC|RTC_IT_ALR,ENABLE); //打开RTC的秒中断和闹钟中断	
		RTC_WaitForLastTask();
	}
  
	NVIC_InitStructure.NVIC_IRQChannel = RTC_IRQn;		//RTC全局中断的中断配置
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;	
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;	
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;		
	NVIC_Init(&NVIC_InitStructure);		
 
	return 0;
}
//此初始化函数在主函数中的用法
while(RTC_Init())
{
	printf("INIT Programing is ERROR!!\r\n");
}
	
中断处理函数：
void RTC_IRQHandler()
{
	if(RTC_GetITStatus(RTC_IT_ALR)!=RESET) //是否闹钟中断发生
	{
		printf("THE ALARM  READY =%d \r\n",RTC_GetCounter());//输出此时的秒数
		RTC_ClearITPendingBit(RTC_IT_ALR);
		PWR_BackupAccessCmd(ENABLE);
		RTC_EnterConfigMode();	
	    RTC_WaitForLastTask();
		RTC_SetAlarm(40+RTC_GetCounter());	  //配置下次闹钟为40s后
		RTC_WaitForLastTask();
		RTC_ExitConfigMode();   
		PWR_BackupAccessCmd(DISABLE);
	}//要注意的一点就是在中断函数里面如果把判断秒中断的函数写在了判断闹钟中断的前面，就会得到THE ALARM READY=41。。。还有一点就是就算没有写反，下一次闹钟的时间是81秒，如图
    if(RTC_GetITStatus(RTC_IT_SEC)!=RESET)  //是否秒中断发生
	{
		printf("Time is  =%d \r\n",RTC_GetCounter()); //输出此时的秒数
	}
	RTC_ClearITPendingBit(RTC_IT_SEC|RTC_IT_OW); //清除秒中断标志位和溢出位
	RTC_WaitForLastTask();
}

待机模式是功耗最低的一种模式。外部复位(NRST 引脚)、 IWDG 复位、 WKUP 引脚上的上升沿或 RTC 闹钟事件
发生时，STM32从待机模式退出。其中外部复位和WKUP的方法比较简单。主要讲一下RTC闹钟唤醒。
这两个程序一个是让STM32的一个管脚接按键，按键按下的时候STM32进入待机状态，当40秒的闹钟到来时唤醒STM32.
另一个是当按键按下时候进入待机状态，闹钟设置为5S秒后，闹钟来临时唤醒STM32.


最好的处理rtc定时中断的方法：
void RTC_ALARM_Time_COnfig(FunctionalState NewState)
{
	RTC_AlarmTypeDef RTC_AlarmStructure;
	RTC_TimeTypeDef  RTC_TimeNow;
	uint32_t TimeCount= 0;
	RTC_GetTime(RTC_Format_BIN,&RTC_TimeNow);//获取当前时间时刻

	RTC_AlarmStructure.RTC_AlarmTime.RTC_H12     = RTC_H12_AM;
	RTC_AlarmStructure.RTC_AlarmTime.RTC_Hours   = RTC_TimeNow.RTC_Hours;

	TimeCount= RTC_TimeNow.RTC_Minutes*60+RTC_TimeNow.RTC_Seconds+DEF_RTCALARM_sec-1;//定时5s后设置为唤醒时间
	RTC_AlarmStructure.RTC_AlarmTime.RTC_Minutes =((TimeCount/60)%60);
	RTC_AlarmStructure.RTC_AlarmTime.RTC_Seconds =(TimeCount%60);  
	/* Alarm Date Settings : Date = 1st day of the month */
	RTC_AlarmStructure.RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
	RTC_AlarmStructure.RTC_AlarmDateWeekDay = 1;
	/* Set the alarmA Masks 只要分与秒一样就可以进alarm中断，很好的功能*/*****
	RTC_AlarmStructure.RTC_AlarmMask = RTC_AlarmMask_All&(~(RTC_AlarmMask_Minutes|RTC_AlarmMask_Seconds));
	
	RTC_SetAlarm(RTC_Format_BIN, RTC_Alarm_A, &RTC_AlarmStructure);
	/* Enable AlarmA interrupt */
	RTC_AlarmCmd(RTC_Alarm_A,NewState);
	RTC_ITConfig(RTC_IT_ALRA, NewState);
}


---------------------加预充需要修改的地方
进idle关dsg
中颖set_default关dsg
初始化io的时候开预充


uart发送方式，接收方式：
正常在初始化uart的时候可以开启idle与rxen中断；rxne表示，收到1字节数据就会进，idle中断表示收完一整帧数据，就会进入。
我们也可以只开rxen中断，然后开个定时器检测idle中断，判断超过3ms再收不到数据就判定一帧数据收完了，再去解析收到的数据，这样比较快。

正常的sendbyte函数是会卡死的，如果数据量很大，我们发送的时候主程序就无法做其他事情。
void USART2_SendByte(uint8_t *txdBuf, uint16_t len)
{
  uint32_t TimeoutCount = 0xffff;
  RS485_RxDen();
  LL_mDelay(2);
  while (len--)
  {
    USART2->TDR = *txdBuf++;
    TimeoutCount = 0xffff;
    while ((LL_USART_IsActiveFlag_TC(USART2) == RESET) && (TimeoutCount--));卡住一直等数据发送
  }
  RS485_RxEn();
}
还可以通过开启uart的发送中断去发送数据，每次发送完1字节数据后就会自己跳进发送中断中去发送下一字节数据，在发送这一字节数据期间，我们可以去做其他事情，不会被send卡住程序不运行。
void USART2_SendByte( uint16_t len)
{
	RS485_RxDen();
	LL_mDelay(1);
	RS485sendLen= len;
	RS485sendnum= 0;
	RS485sendFlag = 1;
	//LL_USART_EnableIT_TXE_TXFNF(USART2);
	USART2->TDR = SendBuff[RS485sendnum++];
	LL_USART_EnableIT_TC(USART2);//开启发送中断
}
void UART2SendIRQ(void )  发完一字节就会进来继续发下一字节
{
	if(RS485sendLen>RS485sendnum)		//发送数据缓冲区是否还有数据，如果有发送，没有则关闭发送中断
	{
		USART2->TDR = SendBuff[RS485sendnum++];
	}
	else//该发的数据都发完了
	{
		RS485_RxEn();
		LL_USART_DisableIT_TC(USART2);//关闭发送中断
		RS485sendnum= 0;
		RS485sendLen= 0;
		RS485sendFlag = 0;
	}
		
}



------------------定时器的中断处理函数
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
  /* Prevent unused argument(s) compilation warning */
	if(htim->Instance == TIM14)
	{
		timer.SysTCount++;
		sysflag.bits.DET_Flag = CHG_DETSingle_Get();
	}
	if(htim->Instance == TIM16)
	{
		SIF_TIM_IRQPro();
	}
}
一旦：HAL_TIM_Base_Start_IT(&htim16);开启中断后则SIF_TIM_IRQPro就开始执行了
HAL_TIM_Base_Stop_IT(&htim16);停止之后则中断处理函数中的代码就不执行了


modbus协议的解法：
定义接收数据的缓冲区 ，head指向头，tail指向尾位置
typedef struct
{
	uint8_t  dummy;  若没有有效数据则置1，若有有效数据则置0
	uint16_t tailPosition;
	uint16_t headPosition;
	uint8_t  RecData[SIMUARTDATAMAX];
} ringBuffer_t;
处理数据：
while(rs485buf.dummy == 0)有数据待处理
{
	if（读取缓冲区中的第一个数据是否为有效modbus头）
	{
		if（读取缓冲区中数据头后面的数据是否为正确的cmd）
		{
			根据cmd判断要读内部reg的数据还是要写
			{
				
			}
		}else
		{
			RS485Buf.headPosition++;将头位置向后偏移进入下次循环
			RS485Buf.headPosition%=SIMUARTDATAMAX;
		}	
	}else
	{
		RS485Buf.headPosition++;将头位置向后偏移
		RS485Buf.headPosition%=SIMUARTDATAMAX;
	}
}

处理modbus问下位机要的数据
ModBusReprocess(uint8_t cmd,uint16_t Addr, uint8_t len)
{
	if(Addr<=14)  只需要创建一个100大小的数组就够了，虽然内部addr偏移很大，我们可以根据偏移给tongyongReg对应位置赋值
	{
		basicAddr= 0;
		MaxRegAddOffset=15;
		tongyongReg[0]= (RWSERVIN);
		tongyongReg[1]= HARDCODE_M;
		tongyongReg[x]= 5;	
		tongyongReg[14]= 5;	
	}
	else if((Addr>=50)&&(Addr<=54) )
	{
		basicAddr= 50;
		MaxRegAddOffset=5;
		tongyongReg[0]= ID_ASC2HEX(flashpara.bytes.BAT_ID[0]);
		tongyongReg[1]= ID_ASC2HEX(flashpara.bytes.BAT_ID[4]);
		tongyongReg[2]= ID_ASC2HEX(flashpara.bytes.BAT_ID[8]);
		tongyongReg[3]= ID_ASC2HEX(flashpara.bytes.BAT_ID[12]);
	}
	if(!err)//数据正常，只返回某个case中的部分数据，不需要全部返回
	{
		SendBuff[0] = 6;
		ReadAddr= Addr-basicAddr;
		for(i=0;i<len;i++)//返回的数据根据ReadAddr= Addr-basicAddr去偏移，不用从头返回整个tongyongReg中的数据
		{
			SendBuff[3+i*2] = tongyongReg[ReadAddr+i]>>8;
			SendBuff[4+i*2] = tongyongReg[ReadAddr+i]&0xff;
		}
		CRCValue = user_uart_crc(SendBuff,3+i*2);
		SendBuff[3+i*2] = CRCValue;//先发低字节再发高字节
		SendBuff[4+i*2] = CRCValue>>8;
		USART2_SendByte(5+i*2);
	}
}

modbus的写操作处理
ModBusWrprocess(uint8_t cmd,uint16_t Addr, uint8_t len)
{
	if((Addr>=5)&&(Addr<=14) )
	{
		将要写的数据写入对应的reg
	}
	else if((Addr>=380)&&(Addr<=383))
	{
		将要写的数据写入对应的reg
	}
	if(!ret)//没有异常，返回ack结果
	{
		SendBuff[0] = 6;
		SendBuff[1] = cmd;
		CRCValue = user_uart_crc(SendBuff,6);
		SendBuff[6] = CRCValue;
		SendBuff[7] = CRCValue>>8;
	
		USART2_SendByte(8);
	}
}