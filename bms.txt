上电/断电复位 POR/PDR 
可编程电压检测器：PVD 若芯片供电电压过高或过低，可以通过编程设置复位

内嵌的就有温漂精度不大。
HSI:arm内嵌8M的RC振荡器，给arm提供时钟脉冲--一个脉冲执行一条指令
LSI:内嵌40khz的RC振荡器，这个低俗的时钟供rtc使用。
HSE:可外接4-16M 用途，sysclock或者rtc
LSE：32.768kHz rtc
外部晶体比较大无法集成到cpu内部，内部的都是rc振荡器，体积小
产生CPU时钟的PLL信号，pll分频器

DMA支持的外设：timer/ADC/SPI/IIC/UART 管理存储器（包括flash和sram）到存储器，设备到存储器，
设备到设备的数据传输


chgdet：充电信号线，充电器一接为1，开始充后又变成0
det 放电信号线，放电时为1
idel：中颖的一种休眠模式  此模式下可以充放电唤醒，还有别的模式sleep  xxx只能接充电机唤醒。
bq76930+bq78350：测电压的可以一节一节校准电压的。
sh367309：中颖。

充电口万用表检测电压≤3V。
因为充电mos是关闭的，测的电压是0V，并不会直接链接到b+ b-

低功耗模式：注意在停机或者待机模式下，RTC、IWDG的时钟不会停止。

为啥要有定时器：
CPU本身也是可以定时的，但是会消耗大量的时间，交给定时器就不用管了，他会帮忙精准定时
每个定时器都有1个16bit的预分频器，4个独立的通道，每个通道
可以用于输入捕获、输出比较、pwm与单脉冲模式输出。

独立看门狗：
12bit递减计数器，8bit预分频器，用的内部40kHz的RC振荡器提供时钟，
这个振荡器独立于主时钟，所以它可以工作在停机待机模式。
通过配置可以配置成硬件或软件启动看门狗。
调试模式时，计数器可以被冻结。

窗口看门狗：
7bit递减计数器，可以设置自由运行，由主时钟驱动
 
iic总线上的所有设备与单片机需要共地

spi的速度可达到18M/s，iic最大1m
uart+电平转化芯片就可以变成 232 485

一般显示屏等需要快速通信的设备会用spi通信

can：每个can设备都可以是主设备，也可以是从设备。
usb：速度也很快可以达到：12M/s，注意时钟必须由外部高速晶振产生。

基本定时器是内部资源，可以不连接外部的gpio
高级定时器有链接外部的gpio输出pwm信号
hse 外部高速时钟
hsi 内部高速时钟，有温漂不稳定，当hse失效时系统自动切换成his

芯片中的icode总线，就是instruction总线，我们写好的程序二进制在flash中，cpu读取就通过icode总线，它是专门用来取指令的总线。
常量是存放在flash中的，变量存放在sram中 

寄存器存在于每个外设中，编程就是通过cpu配置各种外设的reg的值
给有特定功能的内存单元取别名，这个别名就是reg，给这个特定内存单元取别名的过程就是reg映射。

reg的映射过程演变：
1.直接操作地址：
	*(unsigned int)(0x12345678) = 0xffff
2.可以通过操作给每个地址取个名字，例如51单片机中的操作
	sfr p0=0x80；
	sfr tlo=0x40；
	写数据的时候可以直接 *p0=0xffff
3.在stm32中:不是通过sfr，而是通过define给每个地址取个名字。
	#define GPIOB_ODR (unsigned int)(0x12345678)
	操作： *GPIOB_ODR=0xffff；  这种方法往地址写数据
4.为了更方便：
	#define GPIOB_ODR *(unsigned int)(0x12345678)
	操作： GPIOB_ODR=0xffff；   
	c语言对总线外设基地址的映射通过头文件，这里的都是地址的映射，都没有带*
		define ahb  0x1
		define apb ahb+x
		define gpioB apb+x
		define gpidB_date gpioB+x
		define gpioB_ctl gpioB+y
	增加struct后呢？
	typedef struct{
		reg1;reg2;reg3;
	}gpio_typedef;
	只需定义一个gpio_typedef*变量就可以访问通过->访问相关reg。

	这种封装已经在固件库中封装好了，以上是封装的过程，原理。

不同的数据左右移位之后的数据变化
int i=1 有符号： 000001 右移之后成0000
                       左移之后成00010
int i=-1 有符号： 11111  左移之后右边补0后成11110  这个是-2
                        右移之后左边补1,还是11111 还是-1，右移几bit都一样是-1
unsigned int i=1 无符号：000001，右移之后左边补0变成00000
						左移之后还是变成2
unsigned int i=-1，这个也是可以的，意思是i=2^64-1如果用%u输出
如果用%d输出还是-1，左移还是变成-2。%d会将原数据默认转换成signed int

固件库分析：
1.startup—stm32-hd.s hd表示flash大小，设置堆栈，pc指针，初始化中断向量表，配置sys时钟，调用_main进入c的世界
2.system-stm32f10x.c 时钟配置文件,倍频外部时钟8-72m
3.外设相关 stm32f10x.h  实现内核之外的外设的reg映射
	stm32f10x_xx.c 外设的初始化struct，外设的驱动函数库文件（这个文件很多
	种类例如：stm32f10x_gpio.h stm32f10x_uart.h stm32f10x_iic.h等等）
4.内核相关 core_cm3.h 实现内核里面的外设的reg映射 
5.头文件的配置文件 stm32f10x_conf.h 
	头文件的头文件，这个头文件中已经include了所有外设用的头文件
	例如：stm32f10x_gpio.h stm32f10x_uart.h stm32f10x_iic.h但是都是屏蔽的
	所以我们只需要包含这个一个头文件，将这个文件中的相关的include去掉屏蔽即可。
6.专门存放中断服务程序的c文件 stm32f10x_it.h  方便管理。
  nvic嵌套向量中断控制器，系统滴答定时器--misc.h

nvic中断分为系统级的与外设级的：
系统级的有10个：例如reset，nmi,未定义指令，取指令失败，systick
外设级的有60个：各种外设
nvic是嵌套中断向量控制器，属于内核的外设，管理所有的片上的中断相关的功能。
--------------------------------------
stm32对flash读写：
	flash写：传入flash中的add，传入要写入的data。
	固件库中提供了很多对flash的op函数
	{
		1.需要在这里或者外部提前开启flash的时钟
		2.flash_unlock();  固定操作，每次操作前都要先解锁
		3.清除标志位x,y,z
		4.flash_erasepage(add); 清除要写的地址的数据，要以页的方式擦除
		5.flash_programword(add,data); 调用固件库函数从指定页的add开始写入data
		6.清除标志位x,y,z
		7.flash_lock(); 
	}
	flash读：传入add即可
	{
		u16 a;
		return a=*(u16*)(add); 从指定页的add开始读，只返回16bit的数据
	}
操作一定是先擦除再写入，每页1024个地址，起始地址0x08000000 
擦除以页为单位，写操作必须以16bit为单位，允许跨页写
擦除时注意避开用户程序的存储区域，避免擦除掉用户程序
---------------------------------------------------------
配置gpio-init：
	1.初始化struct变量
	2.将以上配置init(pinx,portA)
	pin的输入模式改成in后，设置的推挽输出就不起作用了，不影响

EXTI中断：
	配置可以触发中断的中断号，PX
	把对应的gpio初始化为input模式--初始化gpio结构体
	初始化exti变量结构体--对应的pin脚
	设置优先级+使能中断--就是将EXTI与NVIC对应的通道结合起来
		stm32的外部引脚中断只有0-15号中断，16以上的中断是内部其他控制器可以触发的中断
		exti是外部中断，nvic是arm内核里面的中断向量--exti配置的中断最终会跟nvic的中断对应起来
	EXTI_X_IRQ()
	{
		先判断是哪个中断
		{
			清除触发此号中断的标志位；
			调用回调函数处理中断---可以重写。
		}
	}
	
--------------------------------------------------------------------
IIC驱动程序：基于stm32f10x_ll_iic.c 固件库 
	分为总线的驱动iic.c与器件的驱动程序lm75a.c 
	iic.c中集成：iic配置初始化函数	
					初始化gpio+初始化iic控制器--注意需要开启对应iic控制器的时钟与对应的gpio的时钟
					发送一个字节：按照协议->start->sendaddr+rw->senddata->stop
					发送buffer：start->slaveaddr->while(datelen>0){发送一个byte;datebuf++}->stop
					readbyte：
					{
						while(总线是否繁忙)；
						start；等待
						sendslaveaddr；等待有没有数据
						stop（）；
						buf=databuf(iic);将收到的datareg中的数据放到buf中返回。					
					}
	lm75a.c中集成了：读取温度值函数->iicread_buffer(lm75addr,regaddr,buf,bytenum);
	掉电函数->iicsend_byte(lm75addr,regaddr,1);--->一般不用，对应低功耗的板子才会去关断它。

----------------------------------
RS232原理驱动：
	与uart驱动完全一样。
RS485原理驱动：非屏蔽双绞线
	连线需要A--A  B--B
	uart+1个gpio =经过电平转换芯片= 485
	此gpio为h，表示发送状态 为l表示接收状态
	rs485_init()
	{
		初始化1个普通的io端口并设置为低电平；表示接收
		
	}
	rs485_printf(char * fmt,...)  发送函数
	{
		就是uart的发送函数；+gpio高低电平
	}
-------------------------
品图标里面+.c文件
魔术棒里面加对应的c文件的头文件路径

	