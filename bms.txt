# BMS知识

## DMA

> DMA支持的外设：timer/ADC/SPI/IIC/UART 管理存储器（包括flash和sram）到存储器，设备到存储器，设备到设备的数据传输

---

## 电池相关知识

> chgdet：充电信号线，充电器一接为1，开始充后又变成0
> det 放电信号线，放电时为1
> idel：中颖的一种休眠模式  此模式下可以充放电唤醒，还有别的模式sleep  xxx只能接充电机唤醒。
> bq76930+bq78350：测电压的可以一节一节校准电压的。
> 万用表关机状态下，调节到电流档也是相当于一根导线，开机也是一根导线。

>
> 充电口万用表检测电压≤3V。
> 因为充电mos是关闭的，测的电压是0V，并不会直接链接到b+ b-
>
> 低功耗模式：注意在停机或者待机模式下，RTC、IWDG的时钟不会停止。

---

> bootload是一段写在真实程序之前的程序，最终会与真实的程序并到一起（用一个特定的exe程序）
> 在bootload中会关闭中断，所以我们在后面的程序中一上来就需要__enable_irq();打开中断，否则中断都不会触发。

---

> 一线通：
> tx:
> rx:收数据是在中断中收完的
> cpu用了2根线，但是外部通过硬件电路处理成了一根线

---

> 电流的标定与电压的标定不是一回事，电流的标定其实就是直接获取程序中sh367获取的电流值。

### 深度睡眠与普通睡眠的关系

> 深度睡眠只有电芯欠压会触发，只有充电机信号会恢复;
>
> 普通睡眠就是害怕板子耗电，各项指标没问题检测判断一遍就会进休眠，随便啥信号就可以唤醒。
>
> 保护板运行的过程中并不是一直在运行态，运行态会耗电，有的板子运行3m会采集一次参数然后判断如果参数都正常进入休眠状态，然后隔几秒就被唤醒去采集数据如果正常就去继续休眠。如果参数异常就去做相应的操作。

### timer

> 1. 为啥要有定时器：
>    CPU本身也是可以定时的，但是会消耗大量的时间，交给定时器就不用管了，他会帮忙精准定时，每个定时器都有1个16bit的预分频器，4个独立的通道，每个通道可以用于输入捕获、输出比较、pwm与单脉冲模式输出。

> 2. timer的clock—source选择internal_clock
>    timer中断的开启需要在界面配置，timex_update_interrupt通过类似TIM_START_TI(&timex)的函数。
>    假设时钟为32M，如何配置一个500ms的计时器让它每500ms产生一次中断：
>    配置时钟源后还需要配置预分频系数：32 000
>    需要配置counter：500
>    则32000✖500✖1/32000000=500ms 这样配置的timer就是500ms。
>
>    timer启动还需要在主函数初始化time完成后调用相应的启动函数才可以启动：
>    tim_base_start(); 不带中断的tim启动
>    tim_base_start_it(); 带中断的time启动函数。
>
> 3. pwm的配置，选择相应的timer在界面配置pwm-generation-chx，需要在主函数中调用
>    Time_PWM_start();去启动pwm通道 pwm就是配置占空比来调节io口的输出高低电平比例。
>
> 4. RTC的alarmup作用，每次休眠之前调一下定时唤醒的函数，在隔特定时长后就会自己alarm把cpu唤醒。
>    cubemx生成的工程是默认配置systick的，生成的systick隔1s会加1.不需要配置就自动隔1s加1.
>
> 5. systick也是可以配置时钟与reload的，ms/us的延时都可以做到，一般做成ms级别的
>    Systick的中断是默认已经开启了的，直接使用即可，查看NVIC里面的time base:systick timer可以看到默认开中断的
>
> 6. 如何获取板子开机至当前运行时间长度：定义ss=0;500ms计数ss05=0;mm=0;hh=0
>    在timer的500ms的中断处理函数中给上述的几个变量赋值：
>
> ```c
>    handle()
>    {
>    	ss05++;
>    	if(ss05==2)
>    	{
>    		ss05=0;
>    		ss++;
>    		if(ss==60)
>    		{
>    			ss=0;
>    			mm++;
>    			if(mm=60)
>    			{
>    				mm=0;
>    				hh++;
>    			}
>    		}
>    	}
>    }
> ```

### adc

> 技术指标：
> 分辨率：10bit的位数1024，每改变1引起的实际电压的变化就是分辨率，0.00xV
> 量程：模拟信号的变化范围，实际是可以准确采集到的，只不过位数有限，所以才会有误差
> 位数：
> 转换时间：完成一次ad转换需要的时间-包括：采样保持量化编码。
> cubemx里面只需要将io口配置成中断，然后写回调函数即可。中断的触发时刻是adc转换完成会触发。
>
> ---
>
> adc驱动：
> 	开启DMA功能后，读取的最新adc的数据会自动存到自己定义的变量当中去（自己定义的变量就在内存中）
> 	开启DMA功能后DMA需要知道它要从哪里读取数据，所以需要把adc_data_reg的reg地址define出来
> 	stm32的对应的地址区域内都有特定功能对应的寄存器，例如adc1相关reg的区域是0x1111-0x2222等等
> 	一个通道就是一个pin脚，可以采集一个adc数据，就是把此pin作为adc后从datareg可以读到对应的采集的adc数据
> 	先在peripheral register boundary addresses章节找到对应的外设占用的边界地址，
> 	然后去对应外设的register map章节查找对应reg的偏移量确认reg的精确地址。
> 	或者用第一次找到的addr->datareg  这样去找数据reg
> 	
>
> 	dma_init() dma的初始化
> 	{
> 		定义dma初始化struct变量;
> 		dma_deinit()；复位dma通道x,固定用法
> 		将dma的struct变量初始化
> 		调用dma_init初始化刚才初始化的变量
> 		dma_cmd(dma1_channel,enable);
> 	}
> 	gpio_init()  adc的gpio初始化
> 	{
> 		开对应port时钟
> 		使能对应的dmax时钟---dmax也算是外设
> 		使能对应的adcx时钟
> 		设置gpio为模拟输入
> 		设置变量的pin为对应的pin	
> 	}
> 	adc_init()
> 	{
> 		初始化dma与gpio后，定义adc的struct
> 		初始化adc的变量结构体
> 		调用adc_init初始化刚才的var
> 		设置adc控制器x，adc的通道，采样顺序，采样周期。调用库函数
> 		adc_regularChannelConfig();
> 		adc_dmacmd(); 开启adc1的dma支持
> 		adc_resetCalbration(); 重置adc1校准reg
> 		等待校准重置成功
> 		adc_startcalibration(); 开始adc1校准
> 		等待校准完成
> 		adc_softwareStartConvcmd(); 使能adc1开始转换。
> 	}

---

> cubemx直接生成的LL库的adc初始化函数会卡死，如图部分：
>
> ![image-20211027185938393](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20211027185938393.png)

> 经过同事测试直接删除没不良影响。

### 结构体

```c
typedef union
{
    uint32_t word;
    struct
    {   
        uint8_t byte_1:8; 0x01  在低字节
        uint8_t byte_2:8; 0x02
        uint8_t byte_3:8; 0x03
        uint8_t byte_4:8; 0x04	在高字节
    }bytes;
}S_WORD;  这么定义的变量,用%d打印出来实际上是：0x04 03 02 01
```

### FSMC是扩展外部sram的接口。

### uart

> uart的接收中断有个hal库函数可以设置接到几个byte才发生中断：（相当于idel中断那个标志位）
> hal_uart_receive_it(&uart1,rxbuf,10);表示收到往rxbuf里面放10个byte才会进入中断处理函数。
> 这句话在uart初始完开启中断后就可以调一下。
> 这样我们可以直接在中断处理函数中处理rxbuf中的数据，解析。

> idel中断：https://blog.csdn.net/qq_29413829/article/details/63262321
> 串口的RXNE中断一次只能接收一个字节的数据，没有缓冲区，无法接收一帧多个数据
> rxne:接收buf非空，收满一个byte触发中断。
>
> ---
>
> RS232原理驱动：
> 	与uart驱动完全一样。
> RS485原理驱动：非屏蔽双绞线
> 	连线需要A--A  B--B
> 	uart+1个gpio =经过电平转换芯片= 485
> 	此gpio为h，表示发送状态 为l表示接收状态
> 	rs485_init()
> 	{
> 		初始化1个普通的io端口并设置为低电平；表示接收
> 		
>
> 	}
> 	rs485_printf(char * fmt,...)  发送函数
> 	{
> 		就是uart的发送函数；+gpio高低电平
> 	}

> ---
>
> 要使用printf之前需要在uart.c里面增加如下代码：
>
> ```c
> ```
>
> 

### IIC

> > https://blog.csdn.net/zhanghuaichao/article/details/48266309 对iic的解读，每个函数定义
>
> IIC驱动程序：基于stm32f10x_ll_iic.c 固件库 
> 	分为总线的驱动iic.c与器件的驱动程序lm75a.c 
> 	iic.c中集成：iic配置初始化函数	
> 初始化gpio+初始化iic控制器--注意需要开启对应iic控制器的时钟与对应的gpio的时钟
> 发送一个字节：按照协议->start->sendaddr+rw->senddata->stop
> 发送buffer：start->slaveaddr->while(datelen>0){发送一个byte;datebuf++}->stop
>
> ```c
> readbyte：
> 					{
> 						while(总线是否繁忙)；
> 						start；等待
> 						sendslaveaddr；等待有没有数据
> 						stop（）；
> 						buf=databuf(iic);将收到的datareg中的数据放到buf中返回。					
> 					}
> ```
>
> ​	lm75a.c中集成了：读取温度值函数->iicread_buffer(lm75addr,regaddr,buf,bytenum);
> ​	掉电函数->iicsend_byte(lm75addr,regaddr,1);--->一般不用，对应低功耗的板子才会去关断它。
>
> 手动模拟io口做iic怎么实现：
>
> ```c
> void SH30x_IICPort_Init(SIMIIC_name_t IICNum)
> {
> 	//配置io口的模式，输出类型，上拉下拉，速度
> 	GPIO_InitStruct.Mode = LL_GPIO_MODE_OUTPUT;
> 	GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_OPENDRAIN;
> 	GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
> 	GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
> 	//sda与scl线都是一样的配置，直接初始化对应的pin即可
> 	GPIO_InitStruct.Pin = IIC_GPIO_INFO[SIMIIC_1].SCL_PIN;
> 	LL_GPIO_Init(IIC_GPIO_INFO[SIMIIC_1].SCL_PORT, &GPIO_InitStruct);
> 	GPIO_InitStruct.Pin = IIC_GPIO_INFO[SIMIIC_1].SDA_PIN;
> 	LL_GPIO_Init(IIC_GPIO_INFO[SIMIIC_1].SDA_PORT, &GPIO_InitStruct);
> 	//初始化完成先发下stop信号，保证初始化没有iic通信
> 	SH30x_I2C_Stop(SIMIIC_1);
> }
> ```
>
> //需要看连接的外设的datasheet,不是看cpu里面的iic描述
> //sh367306的电气参数章节，有个关于通信的通信时序图，里面有个告诉得超过多久才能将电平拉低才会起作用
> //一般只有最小值不设置最大值。参考sh367306的56也的电器图
>
> ```c
> void SH30x_I2C_Stop(SIMIIC_name_t IICNum)
> {
> 	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
> 	GPIO_WritePin(IIC_GPIO_INFO[x].SDA_PORT, IIC_GPIO_INFO[x].SDA_PIN, GPIO_PIN_RESET);先让数据线为0
> 	Soft_Delay(2);延时，这里的实现就是让一个数递减，很占用cpu，可以用timer优化吗？
> 	I2C_SCL_1(IICNum);让scl为1
> 	Soft_Delay(1);延时 
> 	I2C_SDA_1(IICNum);数据线为1
> 	Soft_Delay(2);延时
> }
> ```
>
> ```c
> iic连续发多个字节怎么发：
> start->ack->slaveaddr->ack->data->ack->data->ack->data->ack->stop
> ```
>
> 

### gpio

> 复用的时候Alternate选择AFx怎么确认，在datesheet里面搜alternate function mapping
>
> ---
>
> 配置gpio-init：
> 	1.初始化struct变量
> 	2.将以上配置init(pinx,portA)
> 	pin的输入模式改成in后，设置的推挽输出就不起作用了，不影响
>
> EXTI中断：
> 	配置可以触发中断的中断号，PX
> 	把对应的gpio初始化为input模式--初始化gpio结构体
> 	初始化exti变量结构体--对应的pin脚
> 	设置优先级+使能中断--就是将EXTI与NVIC对应的通道结合起来
> 	exti0-15对应7个中断处理函数，这就是7个中断向量，NVIC里面定下来的。
> 		stm32的外部引脚中断只有0-15号中断，16以上的中断是内部其他控制器可以触发的中断
> 		exti是外部中断，nvic是arm内核里面的中断向量--exti配置的中断最终会跟nvic的中断对应起来
> 	EXTI_X_IRQ()
> 	{
> 		先判断是哪个中断
> 		{
> 			清除触发此号中断的标志位；
> 			调用回调函数处理中断---可以重写。
> 		}
> 	}

### 片内flash操作

> stm32对flash读写：falsh操作的途中要关闭中断__disable_irq();
>
> ```c
> 	flash写：传入flash中的add，传入要写入的data。
> 	固件库中提供了很多对flash的op函数
> 	{
> 		1.需要在这里或者外部提前开启flash的时钟            
> 		2.flash_unlock();  固定操作，每次操作前都要先解锁
> 		3.清除标志位x,y,z
> 		4.flash_erasepage(add); 清除要写的地址的数据，要以页的方式擦除
> 		5.flash_programword(add,data); 调用固件库函数从指定页的add开始写入data
> 		6.清除标志位x,y,z
> 		7.flash_lock(); 
> 	}
> 	flash读：传入add即可
> 	{
> 		u16 a;
> 		return a=*(u16*)(add); 从指定页的add开始读，只返回16bit的数据
> 	}
> ```
>
> 操作一定是先擦除再写入，每页1024个地址，起始地址0x08000000 
> 擦除以页为单位，写操作必须以16bit为单位，允许跨页写
> 擦除时注意避开用户程序的存储区域，避免擦除掉用户程序
>
> g030的flash大小64k，这64k的前面的地址用来存储code，最后的2k用来存数据.
> 手册里面每个page大小说是2k。
> 总的地址范围是：0x0800 0000---0x0801 0000这是16进制，则大小就是64k了。
> user的可用地址范围是：0x0801 0000-0x800到addr的end（刚好一页大小）
> 我们存到flash里面的数据就这一个dword共8byte，直接映射就得到了当前flash中的值dword = *(__IO uint64_t *)Address;
> flash里面的初始值就都是1，我们平时擦除的时候，就是将flash里面所有的bit置1.

### bootloader分析

> 启动文件：bootloader
> 1.初始化堆栈指针  sp指针由高地址向低地址生长
> 2.初始化pc指针，pc=reset_handle
> 3.初始化中断向量表
> 4.配置系统时钟
> 5.跳转到c里面的main函数
>
> 0x400=1k
> 1G=1ns  1M=1us  1k=1ms

### 看门狗

> 独立看门狗：
> 12bit递减计数器，8bit预分频器，用的内部40kHz的RC振荡器提供时钟，
> 这个振荡器独立于主时钟，所以它可以工作在停机待机模式。
> 通过配置可以配置成硬件或软件启动看门狗。
> 调试模式时，计数器可以被冻结。
>
> 窗口看门狗：
> 7bit递减计数器，可以设置自由运行，由主时钟驱动

### 中断

> nvic中断分为系统级的与外设级的：
> 系统级的有10个：例如reset，nmi,未定义指令，取指令失败，systick
> 外设级的有60个：各种外设
> nvic是嵌套中断向量控制器，属于内核的外设，管理所有的片上的中断相关的功能。
>
> 外设中断进程调用HAL_Delay(底层就是systick的中断)的时候，要特别注意中断的优先级问题，如果systick的中断优先级低于外设中断优先级，会导致一直在外设中断中阻塞，
> 如果外设中调用了HAL_Delay()，一定要保证Systick的中断优先级高于外设中断优先级，但是，小飞哥是极其不建议在中断中调用HAL_Delay（）函数的
>
> ---
>
> gpio中断设置时可以直接选择gpio_extix，这里这么配置后关于gpio的选项里面才会出现NVIC的配置
> 同时在NVIC里面也要打开EXTI对应的那些line，触发条件边沿触发，
> 使能相应的NVIC通道并选择优先级。
>
> ```c
> EXTI15_10_IRQHandle()
> {
> 	HAL_GPIO_EXTI_IRQHandle(pin)   如果没有hal库就自己在这个handle里面写操作就行，注意清flag。
> 	{
> 		清标志位
> 		执行callback回调函数
> 		{
> 			真正对pin脚的操作。
> 		}
> 	}
> }
> ```
>
> 对应的中断优先级的配置在界面的NVIC控制器里面可以通过对勾开启对应的中断并选择优先级。

### 消抖操作

```c
if(按键被按下)
{
	delay 20ms;   延时一会后按键仍被按下。
	if(案件被按下)
	{
		做真正的操作；
	}
}
判断充电状态的时候需要防抖动，得判断充电time>3才可以真正的去开充电mos。
```

### 寄存器映射

```c
寄存器存在于每个外设中，编程就是通过cpu配置各种外设的reg的值
给有特定功能的内存单元取别名，这个别名就是reg，给这个特定内存单元取别名的过程就是reg映射。

reg的映射过程演变：
1.直接操作地址：
	*(unsigned int)(0x12345678) = 0xffff
2.可以通过操作给每个地址取个名字，例如51单片机中的操作
	sfr p0=0x80；
	sfr tlo=0x40；
	写数据的时候可以直接 *p0=0xffff
3.在stm32中:不是通过sfr，而是通过define给每个地址取个名字。
	#define GPIOB_ODR (unsigned int)(0x12345678)
	操作： *GPIOB_ODR=0xffff；  这种方法往地址写数据
4.为了更方便：
	#define GPIOB_ODR *(unsigned int)(0x12345678)
	操作： GPIOB_ODR=0xffff；   
	c语言对总线外设基地址的映射通过头文件，这里的都是地址的映射，都没有带*
		define ahb  0x1
		define apb ahb+x
		define gpioB apb+x
		define gpidB_date gpioB+x
		define gpioB_ctl gpioB+y
	增加struct后呢？
	typedef struct{
		reg1;reg2;reg3;
	}gpio_typedef;
	只需定义一个gpio_typedef*变量就可以访问通过->访问相关reg。

	这种封装已经在固件库中封装好了，以上是封装的过程，原理。
```



## sourceInsight快捷键

ctrl+/ ：搜索当前函数或变量在整个工程中出现的位置，看哪里调用了函数或者修改了变量。

## 无法分类的知识

> 常量存在flash里面，变量存在sram里面。
>
> ---
>
> 固件库分析：
> 1.startup—stm32-hd.s hd表示flash大小，设置堆栈，pc指针，初始化中断向量表，配置sys时钟，调用_main进入c的世界
> 2.system-stm32f10x.c 时钟配置文件,倍频外部时钟8-72m
> 3.外设相关 stm32f10x.h  实现内核之外的外设的reg映射
> 	stm32f10x_xx.c 外设的初始化struct，外设的驱动函数库文件（这个文件很多
> 	种类例如：stm32f10x_gpio.h stm32f10x_uart.h stm32f10x_iic.h等等）
> 4.内核相关 core_cm3.h 实现内核里面的外设的reg映射 
> 5.头文件的配置文件 stm32f10x_conf.h 
> 	头文件的头文件，这个头文件中已经include了所有外设用的头文件
> 	例如：stm32f10x_gpio.h stm32f10x_uart.h stm32f10x_iic.h但是都是屏蔽的
> 	所以我们只需要包含这个一个头文件，将这个文件中的相关的include去掉屏蔽即可。
> 6.专门存放中断服务程序的c文件 stm32f10x_it.h  方便管理。
> nvic嵌套向量中断控制器，系统滴答定时器--misc.h
>
> ---
>
> ENUM
>
> typedef enum{var1,var2,var3} VVV;
> 这里的var1,var2,var3是用VVV定义的变量x只能从这3个数据中取值
> 并且：var1,var2,var3本身也可以直接在程序中去用，把它当成一个define好的宏去用就可以。
>
> typedef enum{
> 	uint32_t byte;
> 	struct {
> 		bit1:1;先写的bit是lsb，最下面的bit是msb。低地址
> 		...高地址
> 	};
> }; 这里的这种方法共用地址，定义的变量初始化的时候可以用var.byte=0去初始化
> 往变量里面赋值的时候可以用var.bit的方法去1bit1bit的赋值
> 最后还是用var.byte的方法去读值。这种技巧很适合对于reg的操作。
>
> ---
>
> 移位操作
>
> 不同的数据左右移位之后的数据变化
> int i=1 有符号： 000001 右移之后成0000
>                     左移之后成00010
> int i=-1 有符号： 11111  左移之后右边补0后成11110  这个是-2
>                      右移之后左边补1,还是11111 还是-1，右移几bit都一样是-1
> unsigned int i=1 无符号：000001，右移之后左边补0变成00000
> 						左移之后还是变成2
> unsigned int i=-1，这个也是可以的，意思是i=2^64-1如果用%u输出
> 如果用%d输出还是-1，左移还是变成-2。%d会将原数据默认转换成signed int

---

> 参考程序:
>
> ```c
> int main()
> {
> 	int i=0;
> 	uint8_t buf[12] = {0};
> 	uint16_t var=0x1023; 
> 	buf[0] = var>>8; buf[0]只取var>>8的低8bit
> 	buf[1] = var;buf[1]只取var的低8bit，高bit不管
> 	printf("%x--%x\n",buf[0],buf[1]); 0x10 0x23
>     return 0;
> }
> ```
>
> 

## bootloader

> 为啥要有bootloader：
> flash中存的bootloader+app。0-1000存bootloader  1000+2000 存app.
> 第一次上电从bootloader运行判断是要下载程序还是直接运行，
>
> 1.若下载程序，直接根据新的app大小擦除覆盖1000-2000的数据,然后直接写入flash中新的app程序。
> 2.若要运行程序，直接跳到1000去执行。
>
> ### g030的app程序需要更改3处位置，作bootloader新程序。
>
> flash本身是从8000 000位置开始存放数据
> bootloader越小越好，一般从8000 000-8000 1900之前存bootloader，之后存app
>
> 1. keil设置target中的IROM1:0X80018F8表示新程序从这里开始。
>
> 2. 将main里面的static const uint8_t VERINFO[8] __attribute__((at(0x80018f8)))这句话写上，表示我们在程序最开始位置写gtds头信息(其实写入的并不是GTDSLONG，还|了一下别的参数)
>
> 3. 修改g0xx.c  #define VECT_TAB_OFFSET  0x1900U为啥是1900呢？
>
>      1）.程序开始是中断向量表必须是100的倍数。
>      2）. 本来我们想设置app从1800开始的，但是程序会变成gtdsxxxxxxxxxapp，中间的位置就空了，程序出现断裂， 所以我们直接把程序的开始放到1900往前偏移8byte程序就完全连接起来了。
>

---

> 16进制的数据里面会存放数据的位置信息，但是2进制的数据里面不会存放位置信息，所以2进制程序比16进制程序小很多--一半以上
> 第一次烧写程序的时候放的bootloader+app的16进制文件合并内容，以后再烧写的时候放的是bin文件。

---

> ## bin文件怎么用keil生成呢？
> 在keil配置的User里面选中after build/rebuild.
>
> ![image-20211026113910628](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20211026113910628.png)
>
> ```shell
> fromelf --bin --output .\black_shield\black_shield.bin .\black_shield\black_shield.axf
> ```
>
> > fromelf --bin --output .\black_shield\black_shield.bin .\black_shield\black_shield.axf
> >
> > .\：为当前keil工程所在的同级路径.
>
> ### bin文件命名规范
>
> ```
> 项目代号_FACTURECODE_PROJECTCODE_HARDCODE_M_软件版本.bin
> jltest_01_620_V102_V100.bin
> 其中中间三项必须与app代码中的一模一样，项目代号与软件版本可以随便写。
> bin文件名字与hex的名字一致才可以生成bin文件。
> 烧写程序的时候监控软件有个硬件子版本号需要跟main刚开始的HARDCODE_S一致，切记
> ```
>
> ![image-20211026120823569](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20211026120823569.png)

![image-20211026175611231](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20211026175611231.png)

#### bootloader修改配置

> 初始化刷程序的uart
>
> 初始化power_en的gpio并设为1
>
> 修改flash大小：不同的片内flash不一样
>
> 修改FIRMWARE_MAXSIZE大小---boot_flash.c
>
> 其他地方不用改就好

#### app修改配置

> #define FLASH_USER_END_ADDR   (FLASH_BASE + 0X8000)    app_flash.h中8000是flash的size,这里用宏替代***
>
> 3.将cinfigure中的IROM1改成800 18f8
>
> system_stm32g0xx.c文件设置中断偏移量VECT_TAB_OFFSET改成1900,这个是程序的开始位置
>
> #define VECT_TAB_OFFSET  0x1900U

#### 调试

> 1.将system_stm32g0xx.c中断偏移量VECT_TAB_OFFSET改成0000
>
> 2.将main.c中刚开始的绝对地址赋值屏蔽。
>
> 3.将cinfigure中的IROM1改成800 0000



# keil报错

uint8_t is not a type name ; 原因：在某个.h文件中声明的函数名字没写对，只有

void (uint8_t *txdBuf,uint16_t len);

2. ST-link驱动怎么升级？点击device connect然后点击确定（需要将板子+st-link+笔记本连接起来才能升级）

![image-20211030115323689](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20211030115323689.png)

还是连接不上

![image-20211030115904853](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20211030115904853.png)

# 其他常识

#### 2v的电芯300a放电有危险吗？

没有，人体电阻1000k。站到300a导线中间，则电流就流不过去了，因为2/1000k=0.000002a一点危险都没有。

#### 测绝缘的机器2500v，为啥把人打不死？
它的输出只有2ma，两端断开的时候它就是2500v，但是人手解除的时候，人是2ma,2ma*2k=4v 接触的同时人身体的电压只有4v，并不是2500v

#### 保护板上的充电mos与放电mos怎么开启的？

正常放电的时候充电mos与放电mos都是闭合的，如放电有保护，则关闭放电mos，则现在不能放电只有充电mos是闭合的。此时如果充电，在放电mos的二极管会有0.7v压降，但是并不影响充电，保护板检测到有充电电流的时候会闭合放电mos，减小功耗的损失。

正常充电的时候充电mos与放电mos都是闭合的，如充电有保护，则关闭充电mos，则现在无法充电了，但是可以放电。放电时充电mos有0.7v压降，但是并不影响放电，保护板检测到放电电流的时候会闭合充电mos，减小功耗的损失。

#### uart

笔记本缺少232驱动 485连接无法通讯

缺少ch340驱动，串口无法通讯。

-----------------------------
三端保险：一个可以通过信号自动断开的保险
因为保险本身是过流才会断开的；电芯过压的时候如果mos坏了，电芯可以一直充电，此时已经是小电流充电，保险不会
断开，但是很危险。此时我们就应该给三端保险信号让他自动销毁。

PTC柜子：放电柜子
PCS：充电柜子

正常储能系统中充放电就是PCS系统控制的一个大ACDC。

同步帧：上位机每隔1s会给下位机发请求数据的帧，n个下位机收到后便会每隔30ms一个一个给上位机回数据。
-------------
4812 4820  48v12AH 48V20AH  电池重要的参数就是电压 容量
电池充满静置的时候电压会掉下去一部分，放电的时候停止放电电压又会升上去一点。--电芯特性
----------------
SPI：
(1)Leading edge=前一个边沿=第一个边沿，对于开始电压是1，
那么就是1变成0的时候，对于开始电压是0，那么就是0变成1的时候；
(2)Trailing edge=后一个边沿=第二个边沿，对于开始电压是1，
那么就是0变成1的时候（即在第一次1变成0之后，才可能有后面的0变成1），
对于开始电压是0，那么就是1变成0的时候；
CPHA=0，表示第一个边沿：
对于CPOL=0，idle时候的是低电平，第一个边沿就是从低变到高，所以是上升沿采样（读），下降沿输出（更改miso方向）
对于CPOL=1，idle时候的是高电平，第一个边沿就是从高变到低，所以是下降沿采样，上升沿输出
CPHA=1，表示第二个边沿：
对于CPOL=0，idle时候的是低电平，第二个边沿就是从高变到低，所以是下降沿采样，上升沿输出
对于CPOL=1，idle时候的是高电平，第二个边沿就是从低变到高，所以是上升沿采样，下降沿输出
有的从机芯片的对极性的设置根本没要求，设置成0或者1都没关系
我们需要看从机手册是哪个边沿读取数据来确定cpu应该设置成哪种相位。
若从机是上升沿读取/采样数据我们需要设置哪种极性与相位的结合
若从机是下降沿读取/采样数据我们需要设置哪种极性与相位的结合

gpio模拟spi：有的spi从机还多有个D/C引脚线，控制你发的是cmd还是数据
1.gpio初始化：
设置cs片选引脚为output
设置SPIMISO为输入input----可见主机的输出对从机来说相当于输入，
						从机的读为上升沿，则主机设置的时候应该是上升沿写，下降沿读
设置SPIMOSI为output
设置SPICLK为output
2.一般从机的初始化函数可以在对应的手册中找到----主机给那些reg发那些数据，发完就初始化完成了
oled_write(cmd)  发cmd的函数
{
	set_dc(0);表示发送的是cmd
	set_cs(0);拉低电平，开始发送数据
	spi_send(cmd);
	set_dc(1);恢复dc
	set_cs(1);拉高cs电平，停止发送数据
}
oled_write(data)  发data的函数，区别就是对d/c引脚设置的不同
{
	set_dc(1);表示发送的是data
	set_cs(0);拉低电平，开始发送数据
	spi_send(data);
	set_dc(1);恢复dc
	set_cs(1);拉高cs电平，停止发送数据
}
spi_send(byte)
{
	for(i = 0;i < 8;i++)//这个从机要求上升沿读，所以我们要在上升沿发数据
	{
		set_clk(0);     拉低clk准备数据，因为我们需要在上升沿发
		set_do(byte & 0x08);  发送数据的最高bit
		set_clk(1);		拉高clk发送数据出去，产生上升沿sck时，do数据已经准备好了并发出去了
		byte<<1;         将数据左移1bit
	}
}
set_do(val)往spi的do引脚发送数据
{
	if(val)GOIO_DO |= 1<<6;
	else GOIO_DO &= ~(1<<6);
}
---------------------野火教程使用spi
spi结构体：
{
	SPI_Direction;  一般都设置的双向全双工模式
	SPI_mode;   设置主从机模式，cpu肯定设置的主机模式呀
	SPI_DataSize;  设置spi的数据帧长度，可选8/16bit，每一帧发1字节还是2字节
	SPI_CPOL; 极性
	SPI_CPHA;  相位，可选奇/偶边沿采样
	SPI_NSS;  设置nss引脚由软件控制还是spi硬件控制
	SPI_BaudRatePrescaler;   设置时钟分频因子
	SPI_FirstBit;    设置MSB/LSB先行，一般设置msb先发
	SPI_CRCPolynomial;   设置CRC校验表达式，一般不需要管
}
对flash的操作需要很多命令：
{
	1.read reg1_status 读状态1寄存器值  给从机发0x50数据，从机就会返回对应的数据
	2.page program   写数据 ，先发0x02命令，然后发要写入的addr，然后发具体的数据1字节
	3.sector erase   擦除数据，先发0x20命令，然后发要擦除的地址，则就会擦除，擦除完成读reg_status看是否成功擦除
	4.read data    有可以读单字节与一次读多字节的命令，格式也不一样
}

spi_init()
{
	spi_initstruct;
	spi_initstruct.SPI_Direction = SPI_2Lines_FullDuplex;  一般都设置的双向全双工模式
	spi_initstruct.SPI_mode = SPI_mode_Master;   设置主从机模式，cpu肯定设置的主机模式呀
	spi_initstruct.SPI_DataSize = SPI_DataSize_8b;  设置spi的数据帧长度，可选8/16bit，每一帧发1字节还是2字节
	spi_initstruct.SPI_CPOL = SPI_CPOL_High; 极性
	spi_initstruct.SPI_CPHA = SPI_CPAH_2Edge;  相位，可选奇/偶边沿采样
	spi_initstruct.SPI_NSS = SPI_NSS_Soft;  设置nss引脚由软件控制还是spi硬件控制,一般设置软件控制，则CSS引脚我们可以随便指定一个io口
	spi_initstruct.SPI_BaudRatePrescaler = SPI_BaudRATEPrescaler_2;   设置时钟分频因子
	spi_initstruct.SPI_FirstBit = SPI_FirstBit_MSB;    设置MSB/LSB先行，一般设置msb先发
	spi_initstruct.SPI_CRCPolynomial = 0;   不使用crc校验，随便设置一个数字
	
	SPI_Init(SPI1,&spi_initstruct);
	SPI_CMD(SPI1,ENABLE);
}

//SPI里面只需要实现一个函数就可以发送并接收数据，并且spi的可以同时实现发送并接收功能
uint8_t SPI_FLASH_SEND_and_RECEIVE_BYTE(uint8_t data){
	//检查并等待spi的tx缓冲区为空，只有tx缓冲区为空我们才可以发送并接收数据
	while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE)==RESET);  //若发送缓冲区不为空则卡死
	{
		//这里最好不要直接写成死循环，应该设置一个超时事件
		if(SPI_TIMEOUT-- == 0) return callback(0);这个回调函数便于我们定位问题
	}
	//执行函数发送数据
	SPI_I2S_SendData(SPI1,data);
	//检查并等待直到SPI的rx缓冲区为非空,rx缓冲区为非空才能读取数据
	while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE)==RESET);
	{
		//这里最好不要直接写成死循环，应该设置一个超时事件
		if(SPI_TIMEOUT-- == 0) return callback(0);这个回调函数便于我们定位问题
	}
	//可以读取了则读取数据并直接返回
	return SPI_I2S_ReceiveData(SPI1);
}

上面的发送函数同时实现了读写功能，就是读的时候每次都需要先发1byte数据，我们可以重定义一个read函数，发没用的0x00然后
收数据，更好。这样读的时候就不需要发有用的cmd，随便发个数据就好了 
uint8_t SPI_FLASH_RECEIVE_BYTE(uint8_t data){
	return SPI_FLASH_SEND_and_RECEIVE_BYTE(0x00);
}
注意注意，真正的spi通信都是调用很多cmd对从机操作然后收数据，写数据了，我们还得集成几个flash手册里面的函数
//读flash的id的函数
uint8_t read_flashid()
{
	uint32_t flashid;
	//片选使能
	SPI_CS_LOW;
	SPI_FLASH_SEND_and_RECEIVE_BYTE(READ_JEDE_ID); 这个READ_JEDE_ID命令就是手册中告知读id的时候需要发这个
	flashid |= SPI_FLASH_RECEIVE_BYTE(0x00);
	flashid <<= 8;
	flashid |= SPI_FLASH_RECEIVE_BYTE(0x00);
	flashid <<= 8;
	flashid |= SPI_FLASH_RECEIVE_BYTE(0x00);
	SPI_CS_HIGH;
	return flashid;
}

//扇区擦除操作,注意调用这个函数的时候后面需要检查是否擦除完成。
void SPI_ERASE_SECTOR(uint32_t addr)
{
	FLASH_SPI_CS_LOW;
	SPI_FLASH_SEND_and_RECEIVE_BYTE(erase_cmd);
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr>>16 & 0xff);
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr>>8 & 0xff);
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr & 0xff);
	FLASH_SPI_CS_HIGH;
}
//检查是否flash的某个动作完成当前状态是不是busy，需要根据手册实现读取状态reg的对应bit的函数
void SPI_WAITFOR_WRITEEND()
{
	uint8_t status;
	FLASH_SPI_CS_LOW
	SPI_FLASH_SEND_and_RECEIVE_BYTE(READ_STATUS);//先发读状态reg的cmd
	do{
		status = SPI_FLASH_SEND_and_RECEIVE_BYTE(DUMMY);//直接返回的寄存器状态，判断reg状态的对应bit是否为1
	}while((status & 0x01) == 1);是不是busy，如果==1，说明busy，则死循环等flash操作完成
	FLASH_SPI_CS_HIGH
}
//读取flash内容
void SPI_READ_DATA(uint32_t addr,uint8_t * buff,uint8_t numtoread)
{
	FLASH_SPI_CS_LOW
	SPI_FLASH_SEND_and_RECEIVE_BYTE(READ_DATA);先发cmd表示要读数据
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr>>16 & 0xff)
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr>>8 & 0xff)
	SPI_FLASH_SEND_and_RECEIVE_BYTE(addr & 0xff)
	while(numtoread--)
	{
		*buff=SPI_FLASH_RECEIVE_BYTE(DUMMY);
		buff++;  偏移指针
	}
	FLASH_SPI_CS_HIGH
}

fromelf --bin --output .\g030f6p6_ll\BLX6020_01_162_V120_V025.bin .\g030f6p6_ll\BLX6020_01_162_V120_V025.axf



vertical  采样曲线上下移动  下面的按钮：每格子的电压精度。
positive  采样线左右移动   按下去归零

SPI：因为接收数据的时候可以同时发送数据，所以我们一般会在收到数据后直接走发送数据的流程，
其实也可以收数据的时候只收，收完数据等会再执行发送数据的流程，只不过这样就浪费了SPI全双工的
优势。所以我们一般都会在收到数据后直接就看有没有要发的数据在去发。
发的数据与收的数据本身没有啥关系。

-----------------为啥手接零线还是会触电 
我们摸零线的时候我们与大地与火线其实已经形成了回路，相当于我们接了火线。
----------------为什么一线通的一端要接P-
只是用来证明mos没通的时候无法进行一线通通信，并不会有危险。错错错，会有危险。
因为mos通的时候我们的cpu的gnd与外部usb的gnd共地了才可以通信。usb--信号--CPU
															usb--GND--P- --mos通--B- ------CPU的地  共地
若mos没有通，则无法与CPU共地，则无法传输数据，因为没构成回路，此时USB的5V并不会有啥危险。
为啥有危险：见bms图说明
所有的通信都要共地加信号线。

地有好几种，大地的地  板子的地  电池的地  如果不用DCDC隔离就是共同的地，隔离之后的地就不太一样了吗？

通断--断开，闭合 以后不能再说开关了。
-------------
一线通的TX引脚在进入休眠之前要置为高电平，所以休眠初始化的时候不能初始化此引脚为input。需要避开这个引脚。
预充驱动的引脚同理，在进入休眠之前要开预充引脚，所以此引脚不能直接初始化为input，需要避开。

看门狗的设置不需要用硬件也可以实现，可以在while1里面给SoftWDTTIme清0，在systick中给SoftWDTTIme++。如果加到1000直接
调用NVIC_SystemReset(); 就实现了复位。

软件版本在哪里改：在appconfig.h里面搜 软件版本RWSERVIN

--------------sh367306为啥没有CHGDET也可以充放电唤醒。
其实不是直接唤醒的CPU，是sh367检测到充放电电流后会发出alarm信号，才会唤醒CPU。

VPRO在gpioinit的时候没有置1.需要初始化的时候置1，不然sh367309会进入写eeprom态，无法正常读取电压电流

------------程序里面四舍五入的方法
本来x=y;
四舍五入：x= (10y+5)/10;	若10y的个位数>5 则最终取值+1，若<5则最终取值-1.


---------------------
如果一个数定义成uint类型，则这个数必然不可能成为负数，不可能比0小。
若循环减减某个uint类型的数它最小就是0.
若需要减成负数，则需要定义成signed int类型,使它可能成为负数。



keil中ctrl+b：查找当前keil工程中的所有断点，keil中断点太多了就会警告无法调试。需要取消部分断点再去调试。

SysFlag sysflag;定义此变量之后，若要赋值只能给sysflag=x去赋值，不能直接赋值内部共用体成员的值
ps：sysflag.bits.mem1 = 1   这种操作会报警
正确的做法是：将sysflag.bits.mem1 = 1写在其他函数内部。可以写一个init函数，在函数内部对成员mem1进行初始化。



看到这里有点奇怪，i2c write是以ack+stop结束通信，而i2c read是以nack+stop结束通信的，原因如下：

i2c write的时候，master在写完最后一个字节之后slave会回ACK，然后master发送stop信号结束通信

i2c read的时候，master在接收完slave发送的最后一个字节之后会回NAK，因为这个时候master已经接收到足够的字节，NAK告诉slave不要在发送数据了。


读需要再次发个restart信号，因为读之前需要先写地址。真正读数据的时候需要restart一下，再发读地址，然后才是读的数据。
如果读里面没有restart，总线上发的数据就还是写的，就不是读了。

写直接发送start信号之后就可以一直发数据了

-----对于smbus协议
如果操作的是开关设备，有个quickcmd
s+addr+r/w+ack+stop  不需要发送data，r/w就是1/0就可以控制dcdc的开或关。
IIC的read/write与smbus的read/write不同，我们平时接触的大多IIC器件其实都用的是smbus协议
ps:
iic的block write 
s+addr w+ack+interl reg+ack+datax+ack+stop
smbus的block write 
s+addr w+ack+interl reg+byte_count+ack+datax+ack+stop

iic的block read 
s+addr w+ack+interl reg+ack+restart+addr r+datax+nack+stop
smbus的block read
s+addr w+ack+interl reg+ack+restart+addr r+byte_count+ack+datax+nack+stop

尽量优先使用smbus，大多器件都支持smbus。

## 对enum的学习 struct中的：占位

1. enum ASN{MON=7, TUE, WED=10, THU, FRI};  

2. ASN是个标识符，是一种数据类型（可选项-可有可无）

*enum DAY
{
   MON=1, TUE, WED, THU, FRI, SAT, SUN
};*

enum DAY good_day, bad_day; //变量good_day和bad_day的类型均为枚举型enum DAY

---

enum    //跟第一个定义不同的是，此处的标号DAY省略，这是允许的。
{
    saturday,
    sunday = 0,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday
} workday; //变量workday的类型为枚举型enum DAY，这种无法再定义此类型的变量

---

 typedef enum用法

  typedef enum workday（此处workday是数据类型，通过它可以定义变量）
{
    saturday,
    sunday = 0,
    monday,
    tuesday,
    wednesday,
    thursday,
    friday
};

workday today, tomorrow; //变量today和tomorrow的类型为枚举型workday，即enum workday

-----

*** 对于创建的变量赋值的时候只能赋值括号中的那些数值，默认从0开始。 也可以每个数据都赋别的数值，不然enum就会默认加1.





-----struct中的”：“什么意思

https://blog.csdn.net/q2519008/article/details/81478701

位域：位域出现的原因是由于某些信息的存储表示只需要几个bit位就可以表示而不需要一个完整的字节，同时也是为了节省存储空间和方便处理。

```c
typedef struct  bit_struct

{
    int  bit1:3;

    int  bit2:5;

    int  bit3:7;

}data;
```

bit1、bit2、bit3表示对应的位域

整个位域结构体占用2个字节

bit1占3位，bit2占5位，bit1和bit2共用一个字节

bit3占7位，独占一个字节。

位域必须存储在同一个类型中，不能跨类型，同时也说明位域的长度不会超过所定义类型的长度

----

ringBuffer_t var= {0,0,{0},0,0,100};  对结构体中有数组的变量可以直接在定义的时候初始化。

### 多层while与if嵌套

```c
在多重while嵌套结构中使用break，会退出距离break最近的那一层while循环，且多从if嵌套对break无约束作用，会跳出最外层if，寻找与之最近的最内层while跳出
   exp:https://blog.csdn.net/oykotxuyang/article/details/105876206
```

---

串口初始化流程：

```c
{
	定义LL_USART_InitTypeDef结构体变量；
	定义LL_GPIO_InitTypeDef结构体变量；
        
    使能uart1/2时钟，这个是外设时钟；
    使能具体gpio时钟，uart1/2用的那个管脚
        
    LL_GPIO_InitTypeDef.成员={pin,模式（输入、输出、复用）,速度,
                            输出类型（推挽、开漏）--串口就设置推挽,
                           Pull(no,pull up,pull down)--一般硬件管理？我们设置no即可，
                           Alternate(LL_GPIO_AF_1)--复用哪个功能，有iic，uart，mco，time查datesheet可知}
    配置完之后初始化一下此配置的pin,则当前变量没用了，对下一个pin初始化。
        
    配置中断优先级并且使能中断。
    
    对LL_USART_InitTypeDef结构体变量的初始化。
    PrescalerValue，波特率，datewidth，stopbit，Parity，TransferDirection，HardwareFlowControl，OverSampling
    配置完之后init这个变量
        
    LL_USART_ConfigAsyncMode(USART1); --异步
	LL_USART_EnableIT_RXNE(USART1); --？
	LL_USART_EnableIT_IDLE(USART1); --？

	LL_USART_Enable(USART1);--最后使能串口1
}


```



---

LL库与hal库怎么用的，怎么选择

LL库与HAL库类似，hal库体积比较大，ll库体积小。

在cubemx生成的时候，选择用哪个库，生成代码的时候就会选择对应的库。--趋势

---

#### ADC初始化

```c
定义LL_ADC_InitTypeDef与LL_ADC_REG_InitTypeDef结构体变量
定义LL_GPIO_InitTypeDef 变量
初始化外设时钟adc外设时钟，初始化gpio时钟
变量.Pin，.Mode = LL_GPIO_MODE_ANALOG；.Pull = LL_GPIO_PULL_NO
初始化此变量
//初始化LL_ADC_InitTypeDef
	ADC_InitStruct.Clock = LL_ADC_CLOCK_SYNC_PCLK_DIV2;
	ADC_InitStruct.Resolution = LL_ADC_RESOLUTION_12B;
	ADC_InitStruct.DataAlignment = LL_ADC_DATA_ALIGN_RIGHT;
	ADC_InitStruct.LowPowerMode = LL_ADC_LP_MODE_NONE;
	LL_ADC_Init(ADC1, &ADC_InitStruct);
//初始化LL_ADC_REG_InitTypeDef
	ADC_REG_InitStruct.TriggerSource = LL_ADC_REG_TRIG_SOFTWARE;
	ADC_REG_InitStruct.SequencerLength = LL_ADC_REG_SEQ_SCAN_DISABLE;
	ADC_REG_InitStruct.SequencerDiscont = LL_ADC_REG_SEQ_DISCONT_DISABLE;
	ADC_REG_InitStruct.ContinuousMode = LL_ADC_REG_CONV_SINGLE;
	ADC_REG_InitStruct.DMATransfer = LL_ADC_REG_DMA_TRANSFER_NONE;
	ADC_REG_InitStruct.Overrun = LL_ADC_REG_OVR_DATA_PRESERVED;
	LL_ADC_REG_Init(ADC1, &ADC_REG_InitStruct);

	LL_ADC_SetOverSamplingScope(ADC1, LL_ADC_OVS_DISABLE);
	LL_ADC_SetTriggerFrequencyMode(ADC1, LL_ADC_CLOCK_FREQ_MODE_HIGH);
	LL_ADC_SetSamplingTimeCommonChannels(ADC1, LL_ADC_SAMPLINGTIME_COMMON_1, LL_ADC_SAMPLINGTIME_160CYCLES_5);
	LL_ADC_SetSamplingTimeCommonChannels(ADC1, LL_ADC_SAMPLINGTIME_COMMON_2, LL_ADC_SAMPLINGTIME_160CYCLES_5);
	LL_ADC_EnableInternalRegulator(ADC1);
	
	/* Delay for ADC internal voltage regulator stabilization. */
	ADC_VREFINT_CAL= *(uint16_t*)0x1FFF75AA;
	//ADC_VREFINT_DATA= LL_ADC_GetCalibrationFactor(ADC1);
	//printf("ADC_VREFINT_CAL=%d\r\n",ADC_VREFINT_CAL);
	
	ADC_Calibration();
	uint32_t wait_loop_index;
	wait_loop_index = ((LL_ADC_DELAY_INTERNAL_REGUL_STAB_US * (SystemCoreClock / (100000 * 2))) / 10);
	while(wait_loop_index != 0)
	{
		wait_loop_index--;
	}
	//使能内部基准电压
	LL_ADC_SetCommonClock(ADC1_COMMON,LL_ADC_CLOCK_ASYNC_DIV12);
	LL_ADC_SetCommonPathInternalCh(ADC1_COMMON,LL_ADC_PATH_INTERNAL_VREFINT);
/* Configure Regular Channel
	*/
  LL_ADC_REG_SetSequencerRanks(ADC1, LL_ADC_REG_RANK_1, DEF_CH_T1);
  LL_ADC_SetChannelSamplingTime(ADC1, DEF_CH_T1, LL_ADC_SAMPLINGTIME_COMMON_1);

？？？还有问题
```



```c
	LL_TIM_InitTypeDef TIM_InitStruct = {0};

	/* Peripheral clock enable */ 给时钟，因为他没链接pin脚，所以不用给pin脚时钟，定时器是内部的一个部件。
	LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_TIM16);

	/* TIM16 interrupt Init */
	NVIC_SetPriority(TIM16_IRQn, 0);
	NVIC_EnableIRQ(TIM16_IRQn);   使能中断，使能后中断处理函数在哪里呢？stm32xxx_it.h中由对应的函数定义。
    由于中断产生的时候会将定时器的某个regflag置1，所以进入中断处理函数需要先清除此flag，否则一出中断处理函数就又会进入。

	TIM_InitStruct.Prescaler = 15;  预分频
	TIM_InitStruct.CounterMode = LL_TIM_COUNTERMODE_UP;  向上计数
	TIM_InitStruct.Autoreload = 500;  计数到500停
	TIM_InitStruct.ClockDivision = LL_TIM_CLOCKDIVISION_DIV1;  再分频
	TIM_InitStruct.RepetitionCounter = 0;  
	LL_TIM_Init(TIM16, &TIM_InitStruct);
这里初始化里面没有开定时器的中断，可能在外面是开了的。
    定时器的作用：
    1.计算时间--不开中断，不连接pin脚
    	定时器开--干活--定时器关（差值就是时间长度）  注意将reload设置大一些，不然中途自动reload了。
    2.产生中断，开启中断。又对应的中断处理函数--（中断处理函数可以访问全局变量与当前函数的入参）
    3.链接pin脚，产生固定频率的脉冲
```



---

#### rtc初始化

```c
	LL_RTC_TimeTypeDef sTime;	//定义stime
	LL_RTC_DateTypeDef sDate;	//定义stime
	LL_RTC_InitTypeDef RTC_InitStruct = {0};
	SET_BIT(PWR->CR1, PWR_CR1_DBP);
	/* Peripheral clock enable */
	LL_RCC_EnableRTC();
	LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_RTC);
	/* RTC interrupt Init */
	NVIC_SetPriority(RTC_TAMP_IRQn, 2);
	NVIC_EnableIRQ(RTC_TAMP_IRQn);

	RTC_InitStruct.HourFormat = LL_RTC_HOURFORMAT_24HOUR;
	RTC_InitStruct.AsynchPrescaler = 127;
	RTC_InitStruct.SynchPrescaler = 255;
	LL_RTC_Init(RTC, &RTC_InitStruct);
	/** Enable the WakeUp
	*/
	// LL_RTC_WAKEUP_SetClock(RTC, LL_RTC_WAKEUPCLOCK_DIV_16);

	/* USER CODE BEGIN Check_RTC_BKUP */
	if(initFalg==1)
	{
		LL_RTC_DisableWriteProtection(RTC);
	    if (LL_RTC_IsShadowRegBypassEnabled(RTC) == 0U)
	    {
	        LL_RTC_WaitForSynchro(RTC);
	    }
	    
		LL_RTC_EnableWriteProtection(RTC);
	return ;
	}
	//printf("MX_RTC_ RESET!!!\r\n");
	initFalg=1;

	LL_RTC_TIME_StructInit(&sTime);
	LL_RTC_DATE_StructInit(&sDate);

	/* USER CODE END Check_RTC_BKUP */

	/** Initialize RTC and set the Time and Date
	*/
	sTime.Hours = 14;
	sTime.Minutes = 50;
	sTime.Seconds = 0;
	sTime.TimeFormat= 0;
	if (LL_RTC_TIME_Init(RTC,LL_RTC_FORMAT_BIN, &sTime) != SUCCESS)
	{
	
	}
	sDate.WeekDay = 2;
	sDate.Month = LL_RTC_MONTH_JUNE;
	sDate.Day = 1;
	sDate.Year = 21;

	if (LL_RTC_DATE_Init(RTC,LL_RTC_FORMAT_BIN, &sDate) != SUCCESS)
	{
	}
```





----

```带操作系统的can初始化
CAN1_SendData(u32 CanID,u8 *buff,u8 bytes)
{
	需要发送的数据需要在结构体里面包着
	GT_CAN_CanMsg CanTxMessage;
	标准函数进行发送     哪个can                  CanTxMessage中的帧id						标准帧还是扩展帧										 数据				数据长度
	CAN_MessageTransmit( can_name_2, ( CAN_id_Status )( TxMsgData->IDE ), ( TxMsgData->IDE == GT_CAN_id_ext ) ? TxMsgData->ExtId : TxMsgData->StdId, TxMsgData->Data, TxMsgData->DLC );	
}

void GT_CAN0_ReceiveMsg( GT_CAN_CanMsg* RxMsgData )
{
	U32 CAN_ID;

	CAN_id_Status   ide;
	//标准函数就行can数据接收       帧类型-标准-扩展   数据					数据长度
	CAN_MessageReceive( can_name_1, &ide , &CAN_ID, RxMsgData->Data, &( RxMsgData->DLC ) );

	if( ide == GT_CAN_id_ext )
	{
		RxMsgData->ExtId = CAN_ID;
		RxMsgData->IDE = ( GT_CAN_id_Status )ide;
	}
	else
	{
		RxMsgData->StdId = CAN_ID;
		RxMsgData->IDE = ( GT_CAN_id_Status )ide;
	}
}
void    CAN_INIT( CAN_name name, CAN_bps bps )
{
	switch( name )
	{
		case can_name_1:
			CAN_1_Int();//配置gpio的模式 速度 
			{
					GPIO_InitTypeDef GPIO_InitStructure;
					//使能io口的时钟
					RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOA, ENABLE );
					
					GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
					GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
					GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
					GPIO_Init( GPIOA, &GPIO_InitStructure );

					GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
					GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
					GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
					GPIO_Init( GPIOA, &GPIO_InitStructure );
			}
			CAN_SetBps( name, bps);//配置can控制的can结构体
			{
				CAN_InitTypeDef CAN_InitStructure;
				CAN_TypeDef* CANx;
				if( name == can_name_1 )
				{
				CANx = CAN1;
				RCC_APB1PeriphClockCmd( RCC_APB1Periph_CAN1, ENABLE );//使能对应的can控制器时钟，之前的函数里面已经设置过了
				}
				else if( name == can_name_2 )
				{
				CANx = CAN2;
				RCC_APB1PeriphClockCmd( RCC_APB1Periph_CAN2, ENABLE );//使能对应的can控制器时钟，之前的函数里面已经设置过了
				}
				CAN_DeInit( CANx );//库函数缺省初始化can
				switch( bps )//根据bps不同配置不同的CAN_InitStructure
				{
					case bps_500:
						CAN_InitStructure.CAN_SJW = CAN_SJW_1tq;            /*1-4*/
						CAN_InitStructure.CAN_BS1 = CAN_BS1_9tq;            /*1-16*/
						CAN_InitStructure.CAN_BS2 = CAN_BS2_2tq;            /*1-8*/
						CAN_InitStructure.CAN_Prescaler = 6;                /*波特率36/(6*(1+9+2))
																			36m分频/6/12=0.5m，就是500k
				}
				CAN_InitStructure.CAN_TTCM = DISABLE;   /*时间触发(启用时间触发模式时会替换最后两个字节)*/
				CAN_InitStructure.CAN_ABOM = ENABLE;    /*自动离线管理*/
				CAN_InitStructure.CAN_AWUM = ENABLE;    /*自动唤醒*/
				CAN_InitStructure.CAN_NART = DISABLE;   /*ENABLE:错误不自动重传 DISABLE:重传*/
				CAN_InitStructure.CAN_RFLM = DISABLE;   /*DISABLE:在接收溢出时FIFO未被锁定,当接收到FIFO报文未被读出,下一个收到的报文会覆盖原有的报文 ENABLE:在接收溢出时FIFO被锁定,下一个收到的报文会被丢弃*/
				CAN_InitStructure.CAN_TXFP = DISABLE;   /*DISABLE:发送的FIFO优先级由报文的标识符来决定,ENABLE :发送的FIFO优先级由发送报文的顺序来决定*/
				CAN_InitStructure.CAN_Mode = CAN_Mode_Normal; /*正常传输模式 CAN_Mode_Silent_LoopBack:CAN_Mode_LoopBack;*/
				CAN_Init( CANx, &CAN_InitStructure );  初始化can结构体的配置，初始化can控制器
			}
			CAN_SetFilterExt( 0, 0, 0, CAN_FIFO0); /*设置过滤器对应的 CAN_FilterInitStructure，允许接收所有帧*/
			{	入参：u8 number, u16 ID, u16 Mask, u8 FIFO_Type
				CAN_FilterInitTypeDef  CAN_FilterInitStructure;
				/* CAN 过滤器设置 */
				CAN_FilterInitStructure.CAN_FilterNumber = number;
				CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
				CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
				CAN_FilterInitStructure.CAN_FilterIdHigh = ID;
				CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
				CAN_FilterInitStructure.CAN_FilterMaskIdHigh = Mask;
				CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
				CAN_FilterInitStructure.CAN_FilterFIFOAssignment = FIFO_Type;
				CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
				CAN_FilterInit( &CAN_FilterInitStructure );初始化过滤器结构体
			}
			CAN_ITConfig( CAN1, CAN_IT_FMP0, ENABLE );//设置接收fifo的pending中断，就是多会发生can的中断
			{
				#define CAN_IT_FMP0                 ((uint32_t)0x00000002) /*!< FIFO 0 message pending Interrupt*/
				#define CAN_IT_FF0                  ((uint32_t)0x00000004) /*!< FIFO 0 full Interrupt*/
				#define CAN_IT_FOV0                 ((uint32_t)0x00000008) /*!< FIFO 0 overrun Interrupt*/
				#define CAN_IT_FMP1                 ((uint32_t)0x00000010) /*!< FIFO 1 message pending Interrupt*/
				#define CAN_IT_FF1                  ((uint32_t)0x00000020) /*!< FIFO 1 full Interrupt*/
				#define CAN_IT_FOV1                 ((uint32_t)0x00000040) /*!< FIFO 1 overrun Interrupt*/
			}
			BSP_IntVectSet( BSP_INT_ID_USB_LP_CAN_RX0, STM_Can1_RX_ISR );/*注册irq将优先级与函数对应*/
			BSP_IntEn( BSP_INT_ID_USB_LP_CAN_RX0 );//ucos操作开启这个中断
			break;
	}
}

void STM_Can1_RX_ISR(void)  can对应的中断处理函数
{
	CanRxMsg   RxMessage;
	CAN_Receive( CAN1, CAN_FIFO0, &RxMessage );
	CAN1_ISR_Code( &RxMessage ); /*对收到的can数据怎么处理的代码*/
}
```
不带操作系统的can初始化
void CAN1_Init(void)
{
	有这4个结构体需要初始化。
	GPIO_InitTypeDef GPIO_InitStructure; 
	NVIC_InitTypeDef NVIC_InitStructure;
	CAN_InitTypeDef        CAN_InitStructure;
	CAN_FilterInitTypeDef  CAN_FilterInitStructure;

	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
	/* 复用功能和GPIOB端口时钟使能*/    
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO | RCC_APB2Periph_GPIOA, ENABLE);                                                                      

	/* CAN1 控制器时钟使能 */
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN1, ENABLE); 

	/* Configure CAN pin: RX  引脚初始化 */  // PA11
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;       //上拉输入
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	/* Configure CAN pin: TX  引脚初始化*/   // PA12
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;     //复用推挽输出
	GPIO_Init(GPIOA, &GPIO_InitStructure);

	CAN_StructInit(&CAN_InitStructure);     //先缺省初始化CAN_InitStruct结构体

	/* CAN cell init */
	CAN_InitStructure.CAN_TTCM=DISABLE;         //没有使能时间触发模式
	CAN_InitStructure.CAN_ABOM=ENABLE;         //使能自动离线管理
	CAN_InitStructure.CAN_AWUM=ENABLE;         //使能自动唤醒模式
	CAN_InitStructure.CAN_NART=DISABLE;         //没有使能非自动重传模式
	CAN_InitStructure.CAN_RFLM=DISABLE;         //没有使能接收FIFO锁定模式
	CAN_InitStructure.CAN_TXFP=DISABLE;         //没有使能发送FIFO优先级
	CAN_InitStructure.CAN_Mode=CAN_Mode_Normal; //CAN设置为正常模式
	CAN_InitStructure.CAN_SJW=CAN_SJW_1tq;      //重新同步跳跃宽度1个时间单位
	CAN_InitStructure.CAN_BS1=CAN_BS1_2tq;      //时间段1为3个时间单位
	CAN_InitStructure.CAN_BS2=CAN_BS2_3tq;      //时间段2为2个时间单位
	CAN_InitStructure.CAN_Prescaler=12;         
	CAN_Init(CAN1,&CAN_InitStructure);         //利用这个can结构体初始化can控制器

	/* CAN 过滤器设置 */
	CAN_FilterInitStructure.CAN_FilterNumber = 0;
	CAN_FilterInitStructure.CAN_FilterMode = CAN_FilterMode_IdMask;
	CAN_FilterInitStructure.CAN_FilterScale = CAN_FilterScale_32bit;
	CAN_FilterInitStructure.CAN_FilterIdHigh = 0;
	CAN_FilterInitStructure.CAN_FilterIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterMaskIdHigh = 0;
	CAN_FilterInitStructure.CAN_FilterMaskIdLow = 0x0000;
	CAN_FilterInitStructure.CAN_FilterFIFOAssignment = CAN_FIFO0;
	CAN_FilterInitStructure.CAN_FilterActivation = ENABLE;
	CAN_FilterInit( &CAN_FilterInitStructure );  //初始化can过滤器
    
	/* enabling interrupt */
	NVIC_InitStructure.NVIC_IRQChannel=USB_LP_CAN1_RX0_IRQn;对应can的中断处理函数
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
	NVIC_Init(&NVIC_InitStructure);
	CAN_ITConfig(CAN1,CAN_IT_FMP0, ENABLE);  //设置接收fifo的pending中断，就是多会发生can的中断
}

typedef struct{
	int32_t Current;
	uint8_t RateVal;
	uint8_t CMD;
	uint8_t IDVal;
	
	uint8_t BatCnt;
	uint32_t BatUseFlag;
	uint8_t RcvFlag;
	uint8_t RcvNoDataTime;

}CANRCV;CANRCV canrcv;
void USB_LP_CAN1_RX0_IRQHandler()//针对收到的can数据，怎么处理
{
	S_HALFWORD val;
	CanRxMsg RxMessage;

	CAN_Receive(CAN1, CAN_FIFO0, &RxMessage);	收到的can数据存放到RxMessage结构体变量中		       
	if( RxMessage.StdId == 0x100 )//如果收到的标准帧id是100
	{
		val.bytes.byte_h = RxMessage.Data[1];
		val.bytes.byte_l = RxMessage.Data[2];
		canrcv.Current = (int32_t)((val.halfword+(int32_t)CurrentDrift)); 将电流存起来
		canrcv.CMD = RxMessage.Data[3];									  将cmd存起来，充放电指令
		canrcv.RcvFlag = 1;												  将rcvflag置1
		canrcv.RcvNoDataTime= 0;										  将DataFramID=1;全局变量
		DataFramID=1;
		TIM_SetAutoreload(TIM3, ((10+ data.ID* 10)* 100));//:10us		  设置定时器频率
		TIM_Cmd(TIM3, ENABLE);//										使能定时器
		TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);				定时器已开启，则定时器中断中就会发对应的数据，按照定时器的频率		

	}
	else if( RxMessage.StdId == 0x101 )//如果收到的标准帧id是101
	{
		canrcv.BatCnt= RxMessage.Data[0];
		canrcv.BatUseFlag= ((RxMessage.Data[1]<<24)|(RxMessage.Data[2]<<16)|(RxMessage.Data[3]<<8)|(RxMessage.Data[4]<<0));
	}
	else if(( RxMessage.StdId == 0x200 )&&(0x47 ==RxMessage.Data[0]))//修改下位机ID的指令
	{
		if((data.ID  == RxMessage.Data[1])||(0xff  == RxMessage.Data[1]))
		{			
				if((RxMessage.Data[2]<=24)&&(RxMessage.Data[2]>=1)) 
				{
					canrcv.IDVal = RxMessage.Data[2];
					flag.bits.IDChange = 1;						
				}		
		}
		
	}
	if((0x130 == RxMessage.StdId)&&(0x89 == RxMessage.Data[0])&&(0x89 == RxMessage.Data[1])
		&&(0xAB == RxMessage.Data[2])&&(0xAB == RxMessage.Data[3])
	&&(data.ID == RxMessage.Data[4]))
	{
		NVIC_SystemReset();				//收到此指令则复位
	}

	if((0x188 == RxMessage.StdId)&&((data.ID == RxMessage.Data[0])||(0xff == RxMessage.Data[0])))
	{		
		CHG_LED = RxMessage.Data[1];	
		DSG_LED = RxMessage.Data[2];
		WARN_LED = RxMessage.Data[3];
		CHG_SWITH = RxMessage.Data[4];
		DSG_SWITH = RxMessage.Data[5];
	}		
	if((0x189 == RxMessage.StdId)&&(data.ID == RxMessage.Data[0]))
	{		
		if((RxMessage.Data[2]<=125)&&(RxMessage.Data[2]>=85)&&(RxMessage.Data[1]==0x48))
		{
				canrcv.RateVal = RxMessage.Data[2];
				flag.bits.RateChange = 1;	
		}
	}	

}


uint8_t CAN_SendMsg(uint32_t id,uint8_t* buf,uint8_t len)
{ 
    uint8_t mbox;
    uint32_t i=0; 
    CanTxMsg TxMessage;  
	if( id < 0x7ff )
	{
		TxMessage.StdId=id;     
		TxMessage.IDE=CAN_ID_STD;   //使用STD识符
	}
	else
	{
		TxMessage.ExtId=id;     
		TxMessage.IDE=CAN_ID_EXT;   //使用扩展标识符
	}

    TxMessage.RTR=CAN_RTR_DATA;
    TxMessage.DLC=len;            
    for(i=0;i<len;i++)
	{
		TxMessage.Data[i] = buf[i];  结构体中存放要发送的can数据
	}
	i = 0;
    mbox= CAN_Transmit(CAN1, &TxMessage);  //TxMessage里面包含了can的结构与数据
    while((CAN_TransmitStatus(CAN1, mbox)!=CANTXOK)&&(i<0xFFFF))判断can发送状态是否成功
    {
        i++;    
    }
    if(i>=0xFFFF)
        return 0;
    return 1;
}








---

##### iic本身是主机占据主导地位，由主机发起开始或者结束信号的，主机也可以不结束，马上发起起始信号进行对另一个从机的寻址。

在总线的一次传输过程中，数据串数方向在整个过程中不变方向

![image-20210929160051719](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20210929160051719.png)

在传输过程中，当需要改变传递方向时，起始信号与从机地址都被重新发一下，并且改变要读还是要写的那1bit。

![image-20210929161958795](C:\Users\X1 YOGA\AppData\Roaming\Typora\typora-user-images\image-20210929161958795.png)

## stm32的每个管脚都可以开启中断，但是不可以同时开启A1,B1,C1,D1，因为A1,B1,C1,D1这种序号一样的管脚只有一个管脚可以用来开启，不能同时将这几个管脚开启中断。

```c
IIC作为从机怎么配置使用
#define 每个管脚的时候也需要define出相应管脚的port组。
需要定义的var：
/*---------IIC1---------------*/
uint8_t  Buffer_Rx_IIC1[40];//接收缓存，接收buf
uint8_t  Rx_Idx_IIC1=0;    //接收计数，记下当前读到哪里了
uint8_t  Flag_RcvOK_IIC1 = 0;// 接收完成标志 
uint8_t  Tx_Idx_IIC1=0;    //发送计数，记下当前发到哪里了
u8 Response_Message[40];  //发送缓存，发送buf

RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE); 使能port组时钟与iic外设时钟
RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);

# GPIO配置初始化
GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;//必须设置为开漏输出，实现iic的线与逻辑
GPIO_InitStructure.GPIO_PuPd =  GPIO_PuPd_NOPULL;
//管脚配置中GPIO_InitStructure.GPIO_PuPd必须配置为GPIO_PuPd_NOPULL，若配置为 GPIO_PuPd_UP或GPIO_PuPd_DOWN，IIC总线会一直繁忙，导致总线出错，检测不到IIC从机。

void I2C1_Configuration(void)
{
    I2C_InitTypeDef 定义iicinit结构体;
    NVIC_InitTypeDef 定义nvicinit结构体;

    I2C_DeInit(I2C1);
    .I2C_Mode = I2C_Mode_I2C;
    .I2C_DutyCycle = I2C_DutyCycle_2;
    .I2C_OwnAddress1 = I2C1_Slave_Address; //从机地址，一定要设置正确                          
    I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
    I2C_InitStructure.I2C_AcknowledgedAddress= I2C_AcknowledgedAddress_7bit;
    I2C_InitStructure.I2C_ClockSpeed = 100000;
    I2C_Init(I2C1, &I2C_InitStructure);  初始化iic结构体
        
    NVIC_InitStructure.NVIC_IRQChannel    = I2C1_EV_IRQn;//事件中断
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority        = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Init(&NVIC_InitStructure);  初始化iic事件中断

    NVIC_InitStructure.NVIC_IRQChannel = I2C1_ER_IRQn;//错误中断
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;                 
    NVIC_InitStructure.NVIC_IRQChannelCmd                = ENABLE;
    NVIC_Init(&NVIC_InitStructure);   初始化iic的err中断

    I2C_ITConfig(I2C1, I2C_IT_BUF | I2C_IT_EVT |I2C_IT_ERR, ENABLE);   
    I2C_Cmd(I2C1, ENABLE);                                             
}

从机的中断处理程序：
void I2C1_EV_IRQHandler(void)
{
  SR1Register = I2C1->SR1;
  SR2Register = I2C1->SR2;

    /* I2C1是从机(MSL = 0) */
  if((SR2Register &0x0001) != 0x0001)  //判断当前是从机模式
  {
    /* 主机已发送地址，地址为被置位·(ADDR = 1: EV1(包括发送和接收)) 
       从模式下：地址匹配-0：地址不匹配或没有收到地址；1：收到的地址匹配
       表示有主机要与自己通信*/
    if((SR1Register & 0x0002) == 0x0002)
    {
        /* 清除标志位 */
        SR1Register = 0;
        SR2Register = 0;

        Rx_Idx_IIC1=0;
        Tx_Idx_IIC1=0;
    }

    /* 接收数据(RXNE=1: EV2) rxne接收数据reg，0（数据寄存器为空），1（数据寄存器非空）*/
    if((SR1Register & 0x0040) == 0x0040)
    {
        Buffer_Rx_IIC1[Rx_Idx_IIC1++] = I2C1->DR; 把数据reg中的数据放到接收buf
        SR1Register = 0;
        SR2Register = 0;
    }
    /* 检测到停止条件(STOPF =1: EV4)
    0（没有检测到停止条件），1（检测到停止条件*/
    if(( SR1Register & 0x0010) == 0x0010)
    {
        I2C1->CR1 |= 0x0001;（PE-I2C模块使能，定义：0（禁用I2C模块），1（启用I2C模块：根据SMBus位的设置，相应的I/O口需配置为复用功能）
    注：如果清除该位时通讯正在进行，在当前通讯结束后，I2C模块被禁用并返回空闲状态。由于在通讯结束后发生PE＝0，所有的位被清除。
        在主模式下，通讯结束之前，绝不能清除该位。）
        SR1Register = 0;
        SR2Register = 0;
        Flag_RcvOK_IIC1 = 1;            
    }

    /* 发送数据(TxE = 1: EV3、EV3-1) 
    TxE数据寄存器是否为空(发送时)，定义：0（数据寄存器非空）,1（数据寄存器空）-注意：在发送数据时，数据寄存器为空时该位被置’1’，在发送地址阶段不设置该位*/
    if((SR1Register & 0x0080) == 0x0080)
    {
        I2C1->DR = Response_Message[Tx_Idx_IIC1++]; 把发送buf中的数据拷贝到tx发送reg
        SR1Register = 0;
        SR2Register = 0;
    }
    /* 检测到非应答(AF =1: EV3-2) --0（无起始或停止条件出错），1（起始或停止条件出错）*/
    if(( SR1Register & 0x0400) == 0x0400)
    {
        I2C1->SR1 &= 0xFDFF;
        SR1Register = 0;
        SR2Register = 0;        
    }       
  }

}
上述中断程序中，当主机读取和写入数据时，都会引起地址位被置位，即发生EV1事件（即本中断处理程序中将发送和接收的EV1合并了）；
　　当主机写入数据时，中断的执行顺序是EV1—>EV2—>EV4，其中有多个数据EV2会多次执行；
　　当主机读取数据时，中断的执行顺序是EV1—>EV3—>EV3-2，本中断程序中将EV3和EV3-1合并了，若有多个数据，EV3将多次执行。

    
void I2C1_ER_IRQHandler(void) {

  __IO uint32_t SR1Register =0;
  __IO uint32_t SR2Register =0;
  SR1Register = I2C1->SR1;
  SR2Register = I2C1->SR2;

    if(I2C_GetITStatus(I2C1,I2C_IT_SMBALERT)) {
    }
    else if(I2C_GetITStatus(I2C1, I2C_IT_TIMEOUT)) {
    } 
    else if(I2C_GetITStatus(I2C1, I2C_IT_PECERR)) {
    } 
    else if(I2C_GetITStatus(I2C1, I2C_IT_OVR)) {
    }
    else if(I2C_GetITStatus(I2C1, I2C_IT_AF)) {
        I2C_ClearITPendingBit(I2C1, I2C_IT_AF);
    }
    else if(I2C_GetITStatus(I2C1, I2C_IT_ARLO)) {
    }
    else if(I2C_GetITStatus(I2C1, I2C_IT_BERR)) {
    }
        I2C1->CR1 |= 0x0001;
        SR1Register = 0;
        SR2Register = 0;    
}发送各种错误进行错误中断不做对应的处理，最后只进行清除寄存器（SR1和SR2）操作。
```
野火I2C硬件初始化流程：
I2C_InitTypeDef 定义iicinit结构体，用这个结构体变量去初始化iic控制器

1.初始化iic相关的gpio--pb6,pb7
2.配置iic外设的工作模式
3.编写iic的读写函数，有byte_write page_write  radom_read 函数 

1.初始化iic相关的gpio--pb6,pb7
2.配置iic外设的工作模式
I2C_EEPROM_CONFIG()
{
	//打开i2c的gpio的时钟
	//打开i2c控制器的时钟
	设置gpio结构体中scl的GPIO_MODE=GPIO_Mode_AF_OD;  推挽复用模式
	设置gpio结构体中sda的GPIO_MODE=GPIO_Mode_AF_OD;  推挽复用模式
	
	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;  使能或关闭ack，一般都要使能ack
	I2C_InitStructure.I2C_AcknowledgedAddress= I2C_AcknowledgedAddress_7bit;  指定地址长度7或10 bit
	I2C_InitStructure.I2C_ClockSpeed = 100000;  指定速度100k
	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;  指定占空比，火哥说好像没啥实际作用，默认随便配一个就行
	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;  			还有smbus模式
	I2C_InitStructure.I2C_OwnAddress1 = I2C1_Slave_Address; //从机地址，一定要设置正确                          
	I2C_Init(I2C1,&I2C_InitStructure);  初始化i2c1控制器
	I2C_cmd(I2C1,enable);  使能i2c
}
3.编写iic的读写函数，有byte_write page_write  radom_byte_read radom_bytes_read函数 

void EEPROM_write_byte(uint8_t addr,uint8_t data)往哪里写就得在哪里读
{
	//产生起始信号
	I2C_GenerateSTART(I2C1,ENABLE);
	//检测EV5事件,即I2C_EVENT_MASTER_MODE_SELECT，若start失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)==ERROR);
	
	//发送设备地址,是写操作，所以是I2C_Direction_Transmitter方向
	I2C_Send7bitAddress(I2C1,从机地址，I2C_Direction_Transmitter);
	//检测EV6事件，即 I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED,若发送地址失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)==ERROR);
	
	//发送要写的存储单元地址
	I2C_SendData(I2C1,addr);
	//检测EV8事件，还未完成
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)==ERROR);
	
	//发送要写的数据
	I2C_SendData(I2C1,data);
	//检测EV8_2事件,发送完成
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)==ERROR);
	
	//产生结束信号
	I2C_GenerateSTOP(I2C1,ENABLE);
}

每次写入不能超过8字节
需要注意at24c10类型的EEPROM用的时候如果要8字节，8字节写数据的时候，每次给定的写入地址都应该是8的倍数，否则就会出现问题。

void EEPROM_page_write(uint8_t addr,uint8_t *data，uint8_t num_to_write)
{
	//产生起始信号
	I2C_GenerateSTART(I2C1,ENABLE);
	//检测EV5事件,即I2C_EVENT_MASTER_MODE_SELECT，若start失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)==ERROR);
	
	//发送设备地址,是写操作，所以是I2C_Direction_Transmitter方向
	I2C_Send7bitAddress(I2C1,从机地址，I2C_Direction_Transmitter);
	//检测EV6事件，即 I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED,若发送地址失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)==ERROR);
	
	//发送要写的存储单元地址
	I2C_SendData(I2C1,addr);
	//检测EV8事件，还未完成
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)==ERROR);
	
	while(num_to_write)
	{
		//发送要写的数据
		I2C_SendData(I2C1,*data);
		//检测EV8_2事件,发送完成
		while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTED)==ERROR);
		data++;
		num_to_write--;
	}
	//产生结束信号
	I2C_GenerateSTOP(I2C1,ENABLE);
}

void radom_bytes_read(uint8_t addr,uint8_t* data,uint8_t num_to_read)从哪个地址读，读到哪里缓冲区，读多少个
{
	//第一次产生起始信号
	I2C_GenerateSTART(I2C1,ENABLE);
	//检测EV5事件,即I2C_EVENT_MASTER_MODE_SELECT，若start失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)==ERROR);
	
	//发送设备地址,是写操作，所以是I2C_Direction_Transmitter方向
	I2C_Send7bitAddress(I2C1,从机地址，I2C_Direction_Transmitter);
	//检测EV6事件，即 I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED,若发送地址失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED)==ERROR);
	
	//发送要读取的存储单元地址
	I2C_SendData(I2C1,addr);
	//检测EV8事件，还未完成
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_TRANSMITTING)==ERROR);
	
	//第2次产生起始信号
	I2C_GenerateSTART(I2C1,ENABLE);
	//检测EV5事件,即I2C_EVENT_MASTER_MODE_SELECT，若start失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_MODE_SELECT)==ERROR);
	
	//发送设备地址,是读操作，所以是I2C_Direction_Receiver方向
	I2C_Send7bitAddress(I2C1,从机地址，I2C_Direction_Receiver);
	//检测EV6读事件，即 I2C_EVENT_MASTER_Receiver_MODE_SELECTED,若发送地址失败则阻塞
	while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_Receiver_MODE_SELECTED)==ERROR);
	
	//接收数据 
	while(num_to_read){
		if(num_to_read == 1){  如果是最后一个字节，则主机要给从机说我读完了，不读了，返回nack信号
			I2C_AcknoledgeConfig(I2C1,DISABLE);
		}
		//检测EV7事件，即数据寄存器已经读到有效数据，此时可以去取数据了
		while(I2C_CheckEvent(I2C1,I2C_EVENT_MASTER_BYTE_RECEIVED)==ERROR);
		*data = I2C_ReceiveData(I2C1);
		data++;  
		num_to_read--;
	}
	
	//产生结束信号
	I2C_GenerateSTOP(I2C1,ENABLE);
	//重新配置ack使能，则主机默认回复的时候回复ack.如果配置成disable，则每次主机收到数据回复nack信号
	I2C_AcknoledgeConfig(I2C1,ENABLE);
}
---

### 几种时钟的区别

```c
rtc定时器是用来计时从1997年开始的时间到现在，这个是个低频的时钟，一般不在系统里面用，只用来显示年月日的。
time定时器：
systick：类似timer，都是有个reload值，向上计数达到此值触发中断然后处理中断。可以通过定义一个全局变量每次出发中断的时候加1，这个数值可以记下来开机到现在的时间长短。timer与systick还有个功能计算任务耗时时长，任务开始时记录全局变量的值，任务结束时记录全局变量的值，相减即可知任务耗时。
    
```

---

### 联合体与结构体大小

```c
union长度怎么计算
    struct的大小计算根据成员的对齐，大小肯定是对齐字节的整数倍。
    union的长度取决于其中的长度最大的那个成员变量的长度。即union中成员变量是重叠摆放的，其开始地址相同。union(共用体)的各个成员是以同一个地址开始存放的,每一个时刻只可以存储一个成员
   union   mm{   
  char   a;//元长度1   
  int   b[5];//元长度4   
  double   c;//元长度8   
  int   d[3]; //元长度4
  };   
本来mm的空间应该是sizeof(int)*5=20;但是如果只是20个单元的话,那可以存几个double型(8位)呢?两个半?当然不可以,所以mm的空间延伸为既要大于20,又要满足其他成员所需空间的整数倍,,因为含有double元长度8，故大小为24。
```

----

#### 很多电池组成的pack再去组，就是电池簇。

----

### 不同型号电池特性

```py
18650
	2.7--3.7--4.2   目前松下可达到3000mAh
	笔记本用的18650电芯通常2200mAh,普通18650 2.+AH
磷酸铁锂
	（2-2.5）--3.2--3.65
	有些自己生产的电芯，电芯容量可以做到13Ah，是普通18650的5-6倍的容量。
	电池充放电的单位：
	1C=1A*s 
	1Ah=3600C 1mAh=3.6C
```


	
	
	
	
	
	
	
	
	
	
	
	
	
-------------FreeRTOS：
keil的配置output文件夹下的晶振配置需不需要配置呢？
start.c文件中SYSTEM_CLOCK就是时钟，配置的晶振时钟需要与它一致。

	
在main.c文件最上面需要定义每个任务的栈大小：
StackType_t Task1Stack[20];
StackType_t Task2Stack[20];
StackType_t Task3Stack[20];
...
StackType_t TasknStack[20];

定义任务入口：
void Task1(){任务1代码}
void Task2(){任务2代码} 

任务控制块：
{
	栈顶；
	任务节点；
	任务栈起始地址
	任务名称
}

静态任务创建函数：
TaskHandle_t xTaskCreateStatic(TaskFunction_t pxtaskcode,//任务入口
								char * pcName, // 任务名称，字符串
								uint32_t ulStackDepth,//任务栈大小
								void * const params,//任务形参
								StackType_t * const StackBuffer,//任务栈起始地址
								TCB_t * const pxTasjBuffer;//任务控制块指针
								)
怎么移植：
FreeRTOSConfig.h中定义的configTICK_RATE_HZ  决定了系统多久进行一次任务时间片的分配
	
	
	
	
单任务静态内存调用流程：----需要指定栈空间
main()
{
	bsp_init();//初始化其他外设
	AppTaskCreate_Handle = xTaskCreateStatic(
							(TaskFunction_t)renwufun,
							(const char*)"renwuname"，
							128,堆栈大小
							NULL，给任务函数传参
							(*StackType_t *) StackBuffer,任务堆栈
							(statictask_t *)&renwufun_TCB,任务控制块句柄
							);
	if(AppTaskCreate_Handle != NULL)
	{
		//任务创建成功
		vTaskStartScheduler();//启动任务，开启调度
	}else
	{
		//任务创建失败
	}
}

在renwufun中我们可以继续创建任务
renwufun()
{
	LED_Handle = xTaskCreateStatic(
							(TaskFunction_t)renwuLED,
							(const char*)"LEDname"，
							128,堆栈大小
							NULL，给任务函数传参
							(*StackType_t *) LEDStackBuffer,任务堆栈
							(statictask_t *)&LEDrenwufun_TCB,任务控制块句柄
							);
	if(LED_Handle != NULL)//返回值AppTaskCreate_Handle是任务句柄
	{
		//任务创建成功
		vTaskStartScheduler();//启动任务，开启调度
	}else
	{
		//任务创建失败
	}
}
-----------
单任务动态内存调用流程：------不需要指定栈空间
main()
{
	BaseType ret = pdPass;
	bsp_init();//初始化其他外设
	ret = xTaskCreate (
							(TaskFunction_t)renwufun,
							(const char*)"renwuname"，
							128,堆栈大小
							NULL，给任务函数传参
							(*StackType_t *) StackBuffer,任务堆栈
							(statictask_t *)&renwufun_TCB,任务控制块句柄
							);
	if(ret == pdPass)//返回值AppTaskCreate_Handle是任务句柄
	{
		//任务创建成功
		vTaskStartScheduler();//启动开启调度任务，这个是个空闲任务，优先级是0（最低的优先级）
	}else
	{
		//任务创建失败
	}
}
renwufun函数里面可以定义多个任务。
{
	taskENTER_CRITIVAL();//进入临界区，此时不会被打断？别的进程肯定不会打扰
	xTaskCreate（renwu 1）;
	xTaskCreate（renwu 12）;
	xTaskCreate（renwu n）;
	taskEXIT_CRITIVAL();//退出临界区
}


---------------方法1：main函数初始化硬件与os，最后开始调度--伪代码实现
int main()
{
	//硬件初始化
	hardware_init();
	//rtos初始化，内存，堆，全局var
	rtos_init();
	//创建任务1，但不执行，因为没开启调度
	rtos_taskcreate(task1);
	//创建任务2，但不执行，因为没开启调度
	rtos_taskcreate(task2);
	//启动rtos，开启调度任务，真正开始任务调度
	rtos_start();
	
}

void task1()
{
	while(1){}
}

void task2()
{
	while(1){}
}

---------------方法2用的多：main函数初始化硬件与os，创建一个任务直接启动调度器，在启动任务中创建各种任务
当所有任务创建成功后将自己删除。

int main()
{
	//硬件初始化
	hardware_init();
	//rtos初始化，内存，堆，全局var
	rtos_init();
	//创建主任务
	rtos_taskcreate(apptack);
	
	//启动rtos，开启调度
	rtos_start();
	
}
void apptack()
{
	rtos_taskcreate(task1);
	rtos_taskcreate(task2);
	...
	rtos_taskdelete(apptack);//所有任务都创建好，删除主任务
}

void task1()
{
	while(1){}
}

void task2()
{
	while(1){}
}


--------------任务状态：
就绪态：任务一旦被创建就会进入就绪态
运行态：具有最高优先级的就绪态任务才会抢占CPU进入运行态，运行态的任务被更高优先级任务打断就会
重新进入就绪态等待CPU调度
阻塞态：sleep，等信号量（资源）的时候就会进入阻塞态，
挂起suspend：让一个任务进入挂起态唯一方法就是调用vTaskSuspend(),把挂起任务恢复的唯一办法就是
调用vTaskResume()或者vTaskResumeFromISR()

任务状态切换：
1.就绪态中具有最高优先级的任务就会进入运行态
2.运行态任务被更高优先级任务打断的时候原任务就会重新变成就绪态
3.运行态的任务调用sleep或者等待某个资源，资源不可达时就会进入阻塞态
4.阻塞态任务获得资源时会进入就绪态，可以等待CPU的调度，不会直接变成运行态
5.阻塞态，就绪态，运行态的任务调用函数vTaskSuspend()就会进入挂起状态，挂起的任务恢复的唯一途径就是
调用vTaskResume()或者vTaskResumeFromISR()恢复，恢复之后不会直接进入运行态，而是进入就绪态，等待CPU调度



typedef struct tskTaskControlBlock
{
	pxtopstack;  栈顶指针
	pxstack;   栈首地址指针
	uxpriority;  任务优先级
	taskname[x];  任务名称 
	statelist;	  状态列表
	eventlist;    事件列表
}


调度机制：
1高优先级任务优先执行，可以抢占低优先级任务
2高优先级任务不停止，低优先级任务永远无法执行
(除非在高优先级的任务中主动调用vTaskDelay())，调用后低优先级任务就可以占上CPU了。
3同等优先级任务，轮流执行：时间片轮转

怎么管理任务：
1.找到最高优先级的运行态或就绪态任务，运行它
2.如果大家平级，轮流执行 

谁去调度的？
TICK定时器，在tick中断中去调度。


rtos里面有3类链表：
1.readylist
	{
		根据优先级不同有n个链表
		readylist[0]：优先级为0的任务链表，里面可能有优先级为0的x个任务
		readylist[1]：优先级为1的任务链表，里面可能有优先级为1的x个任务
		readylist[2]：优先级为2的任务链表，里面可能有优先级为2的x个任务
		readylist[3]：优先级为3的任务链表，里面可能有优先级为3的x个任务
		readylist[4]：优先级为4的任务链表，里面可能有优先级为4的x个任务
	}
2.delaylist阻塞链表
	优先级不同也是只有一个链表
3.suspendlist挂起链表
	优先级不同也是只有一个链表
tick中断根据优先级查找可以执行的高优先级任务；程序执行的过程中任务也可能会跳到其他类型的链表中（例如阻塞，sleep）
任务移动到其他链表中后，下次再调度的时候就会变化的 

xQueueCalcHandle = xQueueCreate(); 创建队列，用于任务间数据通信的，生产者消费者

-----------------------------------MDK编译流程
每个.o文件包含=代码段+数据段（变量）
armlink会将所有的.o文件链接起来成axf文件，formelf工具可以将axf文件更改格式输出为bin文件或者hex文件。
keil安装目录中的ARMCC目录中有好多编译软件，以后我们可以自己根据编译的axf文件自己去输出bin/hex文件。
编译后的linking之后有几个段
code+rodata+rwdata+zidata
Code是代码占用的空间;
RO-data是 Read Only 只读常量的大小，如const型，存储在rom(或者说内部flash)中;  自己增加了const char *varchar="1111111111 1111111111";并不会增加RO-DATA大小，why？？？得在main中用到此变量，不然直接编译不会增加。

RW-data是（Read Write） 初始化了的可读写变量的大小;普通可更改全局var。
ZI-data是（Zero Initialize）  没有初始化的可读写变量的大小。直接定义为0的都会算到这个里面。

ZI（zero init）-data不会被算做代码里因为不会被初始化;其实与rwdata性质一样，都可以更改，只不过它的初始化为0而已
自己实验的时候确实是初始化过的也会算到ZI-data里面呀？？？why。必须是直接初始化时直接定义不为0，才会算到RW-data部分，在main里面再去初始化的不会算到编译的RW-DATA里面。

简单的说就是在烧写的时候是FLASH中的被占用的空间为：Code + RO Data + RW Data
程序运行的时候，芯片内部RAM使用的空间为： RW Data + ZI Data
程序运行的时候，只读区域：code+rodata 

crf文件--->类似ctags文件，跳转使用
机器代码 					 code 
常量 						rodata 
初始非0全局var   			rwdata 
初始化0全局var 				zidata 
局部var 					zidata 
使用malloc动态分配的空间	zidata

在keil中选择芯片型号的时候：设置里面可以看到rom的size会自动设置好0x8000=512k，ram的size也是，不同的cpu，rom大小不同。ram不同

--------------编译工具链
添加环境变量：控制面板--系统--高级系统设置--高级--环境变量--给path继续赋值 bin所在的目录即可
keil设置里面的output选项表里面有编译的配置，即armcc的编译选项参数

elf：可执行 link 文件file

rtc
LL_RTC_BKP_GetRegister  读bkp里面的值，bkp有32bit*8个
LL_RTC_BKP_SetRegister

tamper是后备寄存器，存到里面的数据是不会改变的，rtcinit的函数中只是用它来决定是不是需要初始化时间。因为复位后程序
重新运行，用变量无法决定，需要用bkp里面的数据去决定是不是需要重新初始化时间。

BCD格式，就是16进制入参。我们需要定时23：58：58  则需要传入参 0x23 0x58 0x58
BIN格式，就是10进制入参。我们需要定时23：58：58  则需要传入参 23 58 58

fromelf --text -v xxx.o > 1.txt  将xxx.o里面的内容显示出来重定位到1.txt中。
fromelf --text -v xxx.axf > 1.txt .o文件都没有指定地址，.axf文件中会将所有的地址与大小都分配好

































































