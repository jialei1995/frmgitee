上电/断电复位 POR/PDR 
可编程电压检测器：PVD 若芯片供电电压过高或过低，可以通过编程设置复位

内嵌的就有温漂精度不大。
HSI:arm内嵌8M的RC振荡器，给arm提供时钟脉冲--一个脉冲执行一条指令
LSI:内嵌40khz的RC振荡器，这个低俗的时钟供rtc使用。
HSE:可外接4-16M 用途，sysclock或者rtc
LSE：32.768kHz rtc
外部晶体比较大无法集成到cpu内部，内部的都是rc振荡器，体积小
产生CPU时钟的PLL信号，pll分频器

DMA支持的外设：timer/ADC/SPI/IIC/UART 管理存储器（包括flash和sram）到存储器，设备到存储器，
设备到设备的数据传输


chgdet：充电信号线，充电器一接为1，开始充后又变成0
det 放电信号线，放电时为1
idel：中颖的一种休眠模式  此模式下可以充放电唤醒，还有别的模式sleep  xxx只能接充电机唤醒。
bq76930+bq78350：测电压的可以一节一节校准电压的。
sh367309：中颖。

充电口万用表检测电压≤3V。
因为充电mos是关闭的，测的电压是0V，并不会直接链接到b+ b-

低功耗模式：注意在停机或者待机模式下，RTC、IWDG的时钟不会停止。

为啥要有定时器：
CPU本身也是可以定时的，但是会消耗大量的时间，交给定时器就不用管了，他会帮忙精准定时
每个定时器都有1个16bit的预分频器，4个独立的通道，每个通道
可以用于输入捕获、输出比较、pwm与单脉冲模式输出。

独立看门狗：
12bit递减计数器，8bit预分频器，用的内部40kHz的RC振荡器提供时钟，
这个振荡器独立于主时钟，所以它可以工作在停机待机模式。
通过配置可以配置成硬件或软件启动看门狗。
调试模式时，计数器可以被冻结。

窗口看门狗：
7bit递减计数器，可以设置自由运行，由主时钟驱动
 
iic总线上的所有设备与单片机需要共地

spi的速度可达到18M/s，iic最大1m
uart+电平转化芯片就可以变成 232 485

一般显示屏等需要快速通信的设备会用spi通信

can：每个can设备都可以是主设备，也可以是从设备。
usb：速度也很快可以达到：12M/s，注意时钟必须由外部高速晶振产生。

基本定时器是内部资源，可以不连接外部的gpio
高级定时器有链接外部的gpio输出pwm信号
hse 外部高速时钟
hsi 内部高速时钟，有温漂不稳定，当hse失效时系统自动切换成his

芯片中的icode总线，就是instruction总线，我们写好的程序二进制在flash中，cpu读取就通过icode总线，它是专门用来取指令的总线。
常量是存放在flash中的，变量存放在sram中 

寄存器存在于每个外设中，编程就是通过cpu配置各种外设的reg的值
给有特定功能的内存单元取别名，这个别名就是reg，给这个特定内存单元取别名的过程就是reg映射。

reg的映射过程演变：
1.直接操作地址：
	*(unsigned int)(0x12345678) = 0xffff
2.可以通过操作给每个地址取个名字，例如51单片机中的操作
	sfr p0=0x80；
	sfr tlo=0x40；
	写数据的时候可以直接 *p0=0xffff
3.在stm32中:不是通过sfr，而是通过define给每个地址取个名字。
	#define GPIOB_ODR (unsigned int)(0x12345678)
	操作： *GPIOB_ODR=0xffff；  这种方法往地址写数据
4.为了更方便：
	#define GPIOB_ODR *(unsigned int)(0x12345678)
	操作： GPIOB_ODR=0xffff；   
	c语言对总线外设基地址的映射通过头文件，这里的都是地址的映射，都没有带*
		define ahb  0x1
		define apb ahb+x
		define gpioB apb+x
		define gpidB_date gpioB+x
		define gpioB_ctl gpioB+y
	增加struct后呢？
	typedef struct{
		reg1;reg2;reg3;
	}gpio_typedef;
	只需定义一个gpio_typedef*变量就可以访问通过->访问相关reg。

	这种封装已经在固件库中封装好了，以上是封装的过程，原理。

不同的数据左右移位之后的数据变化
int i=1 有符号： 000001 右移之后成0000
                       左移之后成00010
int i=-1 有符号： 11111  左移之后右边补0后成11110  这个是-2
                        右移之后左边补1,还是11111 还是-1，右移几bit都一样是-1
unsigned int i=1 无符号：000001，右移之后左边补0变成00000
						左移之后还是变成2
unsigned int i=-1，这个也是可以的，意思是i=2^64-1如果用%u输出
如果用%d输出还是-1，左移还是变成-2。%d会将原数据默认转换成signed int

固件库分析：
1.startup—stm32-hd.s hd表示flash大小，设置堆栈，pc指针，初始化中断向量表，配置sys时钟，调用_main进入c的世界
2.system-stm32f10x.c 时钟配置文件,倍频外部时钟8-72m
3.外设相关 stm32f10x.h  实现内核之外的外设的reg映射
	stm32f10x_xx.c 外设的初始化struct，外设的驱动函数库文件（这个文件很多
	种类例如：stm32f10x_gpio.h stm32f10x_uart.h stm32f10x_iic.h等等）
4.内核相关 core_cm3.h 实现内核里面的外设的reg映射 
5.头文件的配置文件 stm32f10x_conf.h 
	头文件的头文件，这个头文件中已经include了所有外设用的头文件
	例如：stm32f10x_gpio.h stm32f10x_uart.h stm32f10x_iic.h但是都是屏蔽的
	所以我们只需要包含这个一个头文件，将这个文件中的相关的include去掉屏蔽即可。
6.专门存放中断服务程序的c文件 stm32f10x_it.h  方便管理。
  nvic嵌套向量中断控制器，系统滴答定时器--misc.h

nvic中断分为系统级的与外设级的：
系统级的有10个：例如reset，nmi,未定义指令，取指令失败，systick
外设级的有60个：各种外设
nvic是嵌套中断向量控制器，属于内核的外设，管理所有的片上的中断相关的功能。
--------------------------------------
stm32对flash读写：falsh操作的途中要关闭中断__disable_irq();
	flash写：传入flash中的add，传入要写入的data。
	固件库中提供了很多对flash的op函数
	{
		1.需要在这里或者外部提前开启flash的时钟            
		2.flash_unlock();  固定操作，每次操作前都要先解锁
		3.清除标志位x,y,z
		4.flash_erasepage(add); 清除要写的地址的数据，要以页的方式擦除
		5.flash_programword(add,data); 调用固件库函数从指定页的add开始写入data
		6.清除标志位x,y,z
		7.flash_lock(); 
	}
	flash读：传入add即可
	{
		u16 a;
		return a=*(u16*)(add); 从指定页的add开始读，只返回16bit的数据
	}
操作一定是先擦除再写入，每页1024个地址，起始地址0x08000000 
擦除以页为单位，写操作必须以16bit为单位，允许跨页写
擦除时注意避开用户程序的存储区域，避免擦除掉用户程序
---------------------------------------------------------
配置gpio-init：
	1.初始化struct变量
	2.将以上配置init(pinx,portA)
	pin的输入模式改成in后，设置的推挽输出就不起作用了，不影响

EXTI中断：
	配置可以触发中断的中断号，PX
	把对应的gpio初始化为input模式--初始化gpio结构体
	初始化exti变量结构体--对应的pin脚
	设置优先级+使能中断--就是将EXTI与NVIC对应的通道结合起来
		stm32的外部引脚中断只有0-15号中断，16以上的中断是内部其他控制器可以触发的中断
		exti是外部中断，nvic是arm内核里面的中断向量--exti配置的中断最终会跟nvic的中断对应起来
	EXTI_X_IRQ()
	{
		先判断是哪个中断
		{
			清除触发此号中断的标志位；
			调用回调函数处理中断---可以重写。
		}
	}
	
--------------------------------------------------------------------
IIC驱动程序：基于stm32f10x_ll_iic.c 固件库 
	分为总线的驱动iic.c与器件的驱动程序lm75a.c 
	iic.c中集成：iic配置初始化函数	
					初始化gpio+初始化iic控制器--注意需要开启对应iic控制器的时钟与对应的gpio的时钟
					发送一个字节：按照协议->start->sendaddr+rw->senddata->stop
					发送buffer：start->slaveaddr->while(datelen>0){发送一个byte;datebuf++}->stop
					readbyte：
					{
						while(总线是否繁忙)；
						start；等待
						sendslaveaddr；等待有没有数据
						stop（）；
						buf=databuf(iic);将收到的datareg中的数据放到buf中返回。					
					}
	lm75a.c中集成了：读取温度值函数->iicread_buffer(lm75addr,regaddr,buf,bytenum);
	掉电函数->iicsend_byte(lm75addr,regaddr,1);--->一般不用，对应低功耗的板子才会去关断它。

----------------------------------
RS232原理驱动：
	与uart驱动完全一样。
RS485原理驱动：非屏蔽双绞线
	连线需要A--A  B--B
	uart+1个gpio =经过电平转换芯片= 485
	此gpio为h，表示发送状态 为l表示接收状态
	rs485_init()
	{
		初始化1个普通的io端口并设置为低电平；表示接收
		
	}
	rs485_printf(char * fmt,...)  发送函数
	{
		就是uart的发送函数；+gpio高低电平
	}
485协议：
	
-------------------------
品图标里面+.c文件
魔术棒里面加对应的c文件的头文件路径
-------------------------
adc驱动：
	开启DMA功能后，读取的最新adc的数据会自动存到自己定义的变量当中去（自己定义的变量就在内存中）
	开启DMA功能后DMA需要知道它要从哪里读取数据，所以需要把adc_data_reg的reg地址define出来
	stm32的对应的地址区域内都有特定功能对应的寄存器，例如adc1相关reg的区域是0x1111-0x2222等等
	一个通道就是一个pin脚，可以采集一个adc数据，就是把此pin作为adc后从datareg可以读到对应的采集的adc数据
	先在peripheral register boundary addresses章节找到对应的外设占用的边界地址，
	然后去对应外设的register map章节查找对应reg的偏移量确认reg的精确地址。
	或者用第一次找到的addr->datareg  这样去找数据reg
	
	dma_init() dma的初始化
	{
		定义dma初始化struct变量;
		dma_deinit()；复位dma通道x,固定用法
		将dma的struct变量初始化
		调用dma_init初始化刚才初始化的变量
		dma_cmd(dma1_channel,enable);
	}
	gpio_init()  adc的gpio初始化
	{
		开对应port时钟
		使能对应的dmax时钟---dmax也算是外设
		使能对应的adcx时钟
		设置gpio为模拟输入
		设置变量的pin为对应的pin	
	}
	adc_init()
	{
		初始化dma与gpio后，定义adc的struct
		初始化adc的变量结构体
		调用adc_init初始化刚才的var
		设置adc控制器x，adc的通道，采样顺序，采样周期。调用库函数
		adc_regularChannelConfig();
		adc_dmacmd(); 开启adc1的dma支持
		adc_resetCalbration(); 重置adc1校准reg
		等待校准重置成功
		adc_startcalibration(); 开始adc1校准
		等待校准完成
		adc_softwareStartConvcmd(); 使能adc1开始转换。
	}

------------------------------------------
spi总线驱动：
	ch376--读u盘的芯片
	
---------------------------------------
typedef enum{var1,var2,var3} VVV;
这里的var1,var2,var3是用VVV定义的变量x只能从这3个数据中取值
并且：var1,var2,var3本身也可以直接在程序中去用，把它当成一个define好的宏去用就可以

------------------------------
typedef enum{
	uint32_t byte;
	struct {
		bit1:1;
		...
	};
}; 这里的这种方法共用地址，定义的变量初始化的时候可以用var.byte=0去初始化
往变量里面赋值的时候可以用var.bit的方法去1bit1bit的赋值
最后还是用var.byte的方法去读值。这种技巧很适合对于reg的操作。

判断充电状态的时候需要防抖动，得判断充电time>3才可以真正的去开充电mos。

---------------------------------------------
vscode对齐快捷键：
ctrl+[ 左移  ctrl+]右移 

-----------------------------------------------
FlashInit()
{
	CheckFlash()
	{
		Flash_ReadPara();
		GetCheck();
	}
	if(check-ok)
	{
		FlashParaSetDefault();
		Flash_WritePara();
	}
}	

typedef struct   flash存的啥呢
{
	uint32_t  appmask;
	uint32_t  yuliu;
	uint8_t id[16];
	uint8_t chgMode;  充电模式
	uint8_t workMode; 工作模式
	uint16_t CycleCount; 循环次数
	int16_t currentRate; 电流速度
	uint16_t FistUseData;  第一次用flash时要不要擦除之前的数据，配置默认数据，需要根据此data确定
	uint32_t cyc_CHG;  循环充电次数
	uint32_t shortCnt; 
	int8_t VoltRate[32]; 电压
	uint32_t BKP3_Data;  
	uint16_t P_UV_Count;  
	uint16_t checkh;     上述所有数据的累计和，用来校验用的
}FlashPara;

-------------------------------------------------
while (1)
{
	CyctickmsCount= systickCount; //这个是全局变量，此数据在systick的中断处理函数中会被更改的。 	
	if(RS485Buf.rcvFlag==1)  有485数据发来了中断中会把rcvFlag置1，进入循环的时候就会进if
	{
		RS485Buf.rcvFlag = 0;  //先清标志位
		RS485_Process(void)    //485处理流程
		{
			while(RingBuf_Read(&readVal))   485存储数据的是个循环数组队列，读取成功返回1.
			{
				RS485Buf.dummy = 0;     //现在readval中有数据，则dummy置为0
				while('G' != readVal)   //若485读到的数据不是G，则一直读，直到读到G
				{
					if(0 == RingBuf_Read(&readVal))  //若读取数据失败，readval数据不可用，设dummy=1
					{					
						RS485Buf.dummy = 1;
						break;
					}
				}
				if(!RS485Buf.dummy) //readval中的数据是从G开始的有效数据了
				{		
					RS485Buf.NodataTime= 0;   //有485数据就把它清0，没数据的时候它就会递增，增到3s就说明没485，该休眠就去休眠
					PCMonitor_Process(readVal);
				}
			}
		}			
	}
	if(sysflag.bits.SysWeakFlag==0) //若没有sys唤醒flag，一线通讯，一根线规定好协议也是可以实现通信的。
	{
		SIFProcess(CyctickmsCount);  //传入开始定义的变量执行此process
	}
	if(((abs(CyctickmsCount-Cyc100mstime))>CFG_CURR_COUNT)||(sysflag.bits.SysWeakFlag==1)) //若有唤醒flag或times差>100
	{
		if(RS485Buf.NodataTime<100)
		{
			RS485Buf.NodataTime++;
		}
		Cyc100mstime= CyctickmsCount;
		Process_100ms_CYC();
		Cyc100msCount++;
		if((Cyc100msCount%DEF_500_CYC==0)||(sysflag.bits.SysWeakFlag==1))
		{
			GPIO_WritePin(LED_PORT,LED_Pin,(GPIO_PinState)Flag);
			Flag=!Flag;
			Process_500ms_CYC1();
			Cyc100msCount=0;
		}
		if(Cyc100msCount%DEF_500_CYC==4)
		{
			Process_500ms_CYC2();
		}
		if(sysflag.bits.flashSave_Flag==1)
		{
			sysflag.bits.flashSave_Flag= 0;
			Flash_WritePara();
		}
	}
}

-----------------------------------
ctrl+/：搜当前关键字在所有文件中出现的位置


电流的标定与电压的标定不是一回事，电流的标定其实就是直接获取程序中sh367获取的电流值。

一线通的板子电平为1时，对端收到的1与0数据才能收到。板子电平为0的时候对端无法将电平拉成1

均衡的时候是500ms的循环中在0s的时候开，在400ms的时候关，不是一直开的，中间会休息100ms。

一线通，车载模式收消息时通过串口中断收，500ms循环中只是发送

gpio复用的时候Alternate选择AFx怎么确认，在datesheet里面搜alternate function mapping

idel中断：https://blog.csdn.net/qq_29413829/article/details/63262321
串口的RXNE中断一次只能接收一个字节的数据，没有缓冲区，无法接收一帧多个数据
dual：双倍的
derive：得到、获得
resolution：分辨率
Calibration ：标定

---------------------------------cubemx-study
设置GPIO为uart或其他复用的外设时，管脚的pp，od模式就会固定下来了。只有当作gpio时自己可以挑着选择为固定功能。
选择RCC时钟源的时候可以在pinout->syscore->RCC->将HSE与LSE改成crystal就可以在树图中将默认的HSI与LSI改成HSE与LSE了

配置引脚后在system view中在system core的对应的外设点进去，通过signal中的user lable可以设置该引脚的别名，方便在图纸上查看
引脚配置的sys里面的debug选择sw模式。
CODE_GENERATOR里面最好勾选只运用nessary lib+生成每个外设对应代码。
LL库里面很多函数没有写进.c文件，因为很多是直接宏定义的函数，所以找的时候去对应的.h里面去搜。LL库里面直接操作寄存器。
消抖操作：
if(按键被按下)
{
	delay 20ms;   延时一会后按键仍被按下。
	if(案件被按下)
	{
		做真正的操作；
	}
}

gpio中断设置时可以直接选择gpio_extix，同时在NVIC里面也要打开EXTI对应的那些line。

timer的clock—source选择internal_clock
timer中断的开启是通过函数的，同时需要在界面配置，timex_update_interrupt通过类似于TIM_START_TI(&timex)的函数。hal库于ll库与固件库应该都有类似的函数。

pwm的配置，选择相应的timer在界面配置pwm-generation-chx，需要在主函数中调用
Time_PWM_start();去启动pwm通道 pwm就是配置占空比来调节io口的输出高低电平比例。


